
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Jelech的博客">
    <title>c++进阶学习笔记 - Jelech的博客</title>
    <meta name="author" content="Jelech">
    
        <meta name="keywords" content="博客,算法,HTML/CSS/JS,游戏服务器,游戏,">
    
    
        <link rel="icon" href="https://jelech.top/assets/images/favicon.ico">
        <link rel="Shortcut Icon" type="image/x-icon" href="assets/images/favicon.ico">
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Jelech","sameAs":["https://github.com/jelech","mailto"],"image":"avatar.jpg"},"articleBody":"\n\ncpp进阶学习继承基类和派生类一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：\n1class derived-class: access-specifier base-class\n其中，访问修饰符 access-specifier 是 public、protected 或 private 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。\n继承类型当一个类派生自基类，该基类可以被继承为 public、protected 或 private 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。\n我们几乎不使用 protected 或 private 继承，通常使用 public 继承。当使用不同类型的继承时，遵循以下几个规则：\n\n公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。\n保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。\n私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。\n\n多继承多继承即一个子类可以有多个父类，它继承了多个父类的特性。\nC++ 类可以从多个类继承成员，语法如下：\n1234class &lt;派生类名&gt;:&lt;继承方式1&gt;&lt;基类名1&gt;,&lt;继承方式2&gt;&lt;基类名2&gt;,…&#123;\t&lt;派生类类体&gt;&#125;;\n多继承(环状继承时)A-&gt;D, B-&gt;D, C-&gt;(A，B)，例如：\n1234class D&#123;......&#125;;class B: public D&#123;......&#125;;class A: public D&#123;......&#125;;class C: public B, public A&#123;.....&#125;;\n这个继承会使D创建两个对象,要解决上面问题就要用虚拟继承格式\n格式：class 类名: virtual 继承方式 父类名\n1234class D&#123;......&#125;;class B: virtual public D&#123;......&#125;;class A: virtual public D&#123;......&#125;;class C: public B, public A&#123;.....&#125;;\n虚继承–（在创建对象的时候会创建一个虚表）在创建父类对象的时候\n12A:virtual public DB:virtual public D\n重载运算符可重载运算符/不可重载运算符下面是可重载的运算符列表：\n\n\n\n双目算术运算符\n+ (加)，-(减)，*(乘)，/(除)，% (取模)\n\n\n\n\n关系运算符\n==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于&gt;，&lt;=(小于等于)，&gt;=(大于等于)\n\n\n逻辑运算符\n\\\n\\\n(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非)\n\n\n单目运算符\n+ (正)，-(负)，*(指针)，&amp;(取地址)\n\n\n自增自减运算符\n++(自增)，–(自减)\n\n\n位运算符\n\\\n(按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移)\n\n\n赋值运算符\n=, +=, -=, *=, /= , % = , &amp;=, \\\n=, ^=, &lt;&lt;=, &gt;&gt;=\n\n\n空间申请与释放\nnew, delete, new[ ] , delete[]\n\n\n其他运算符\n()(函数调用)，-&gt;(成员访问)，,(逗号)，\n\n\n\n下面是不可重载的运算符列表：\n\n.：成员访问运算符\n., -&gt;：成员指针访问运算符\n::：域运算符\nsizeof：长度运算符\n?:：条件运算符\n#： 预处理符号\n\n类成员访问运算符类成员访问运算符（ -&gt; ）可以被重载，但它较为麻烦。它被定义用于为一个类赋予”指针”行为。运算符 -&gt; 必须是一个成员函数。如果使用了 -&gt; 运算符，返回类型必须是指针或者是类的对象。\n运算符 -&gt; 通常与指针引用运算符 * 结合使用，用于实现”智能指针”的功能。这些指针是行为与正常指针相似的对象，唯一不同的是，当您通过指针访问对象时，它们会执行其他的任务。比如，当指针销毁时，或者当指针指向另一个对象时，会自动删除对象。\n间接引用运算符 -&gt; 可被定义为一个一元后缀运算符。也就是说，给出一个类：\n1234class Ptr&#123;   //...   X * operator-&gt;();&#125;;\n类 Ptr 的对象可用于访问类 X 的成员，使用方式与指针的用法十分相似。例如：\n1234void f(Ptr p )&#123;   p-&gt;m = 10 ; // (p.operator-&gt;())-&gt;m = 10&#125;\n语句 p-&gt;m 被解释为 (p.operator-&gt;())-&gt;m。\n值得注意的是:\n1、运算重载符不可以改变语法结构。\n2、运算重载符不可以改变操作数的个数。\n3、运算重载符不可以改变优先级。\n4、运算重载符不可以改变结合性。\n\n静态多态或静态链接 - 函数调用在程序执行前就准备好了。有时候这也被称为早绑定，因为 area() 函数在程序编译期间就已经设置好了。\n但现在，让我们对程序稍作修改，在 Shape 类中，area() 的声明前放置关键字 virtual。此时，编译器看的是指针的内容，而不是它的类型。因此，由于 tri 和 rec 类的对象的地址存储在 shape 中，所以会调用各自的 area() 函数。\n正如您所看到的，每个子类都有一个函数 area() 的独立实现。这就是多态的一般使用方式。有了多态，您可以有多个不同的类，都带有同一个名称但具有不同实现的函数，函数的参数甚至可以是相同的。\n虚函数虚函数 是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。\n我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。\n纯虚函数您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。\n我们可以把基类中的虚函数 area() 改写如下：\n123456789101112class Shape &#123;protected:       \tint width, height;public:       \tShape( int a=0, int b=0) &#123;\t\twidth = a;\t\theight = b;\t&#125;\t// pure virtual function\tvirtual int area() = 0; &#125;;\n数据抽象数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。\n例如，您的程序可以调用 sort() 函数，而不需要知道函数中排序数据所用到的算法。实际上，函数排序的底层实现会因库的版本不同而有所差异，只要接口不变，函数调用就可以照常工作。\n访问标签强制抽象在 C++ 中，我们使用访问标签来定义类的抽象接口。一个类可以包含零个或多个访问标签：\n\n使用公共标签定义的成员都可以访问该程序的所有部分。一个类型的数据抽象视图是由它的公共成员来定义的。\n使用私有标签定义的成员无法访问到使用类的代码。私有部分对使用类型的代码隐藏了实现细节。\n\n访问标签出现的频率没有限制。每个访问标签指定了紧随其后的成员定义的访问级别。指定的访问级别会一直有效，直到遇到下一个访问标签或者遇到类主体的关闭右括号为止。\n\n\n类的内部受到保护，不会因无意的用户级错误导致对象状态受损。\n类实现可能随着时间的推移而发生变化，以便应对不断变化的需求，或者应对那些要求不改变用户级代码的错误报告。\n\n\n数据封装\n程序语句（代码）：这是程序中执行动作的部分，它们被称为函数。\n程序数据：数据是程序的信息，会受到程序函数的影响。\n\n数据封装是一种把数据和操作数据的函数捆绑在一起的机制，数据抽象是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。\n接口（抽象类）如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。\n抽象类不能被用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误。因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数。\n异常处理C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。\n\nthrow: 当问题出现时，程序会抛出一个异常。这是通过使用 throw 关键字来完成的。可以使用 throw 语句在代码块中的任何地方抛出异常\n  1234if( b == 0 )&#123;  throw \"Division by zero condition!\";&#125;\n\ncatch: 在您想要处理问题的地方，通过异常处理程序捕获异常。catch 关键字用于捕获异常。\n\ntry: try 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。下面的代码会捕获一个类型为 ExceptionName 的异常。如果您想让 catch 块能够处理 try 块抛出的任何类型的异常，则必须在异常声明的括号内使用省略号 ...\n  1234567try&#123;   // 保护代码&#125;catch( ExceptionName e )&#123;  // 处理 ExceptionName 异常的代码&#125;\n\n\nC++ 提供了一系列标准的异常，定义在 &lt;exception&gt;中。\n\n异常表\n\n\n异常\n描述\n\n\n\n\nstd::exception\n该异常是所有标准 C++ 异常的父类。\n\n\nstd::bad_alloc\n该异常可以通过 new 抛出。\n\n\nstd::bad_cast\n该异常可以通过 dynamic_cast 抛出。\n\n\nstd::bad_exception\n这在处理 C++ 程序中无法预期的异常时非常有用。\n\n\nstd::bad_typeid\n该异常可以通过 typeid 抛出。\n\n\nstd::logic_error\n理论上可以通过读取代码来检测到的异常。\n\n\nstd::domain_error\n当使用了一个无效的数学域时，会抛出该异常。\n\n\nstd::invalid_argument\n当使用了无效的参数时，会抛出该异常。\n\n\nstd::length_error\n当创建了太长的 std::string 时，会抛出该异常。\n\n\nstd::out_of_range\n该异常可以通过方法抛出，例如 std::vector 和 std::bitset&lt;&gt;::operator。\n\n\nstd::runtime_error\n理论上不可以通过读取代码来检测到的异常。\n\n\nstd::overflow_error\n当发生数学上溢时，会抛出该异常。\n\n\nstd::range_error\n当尝试存储超出范围的值时，会抛出该异常。\n\n\nstd::underflow_error\n当发生数学下溢时，会抛出该异常。\n\n\n\nC++ 动态内存\n栈：在函数内部声明的所有变量都将占用栈内存。\n堆：这是程序中未使用的内存，在程序运行时可用于动态分配内存。\n\n在 C++ 中，您可以使用特殊的运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。这种运算符即 new 运算符。\n如果您不再需要动态分配的内存空间，可以使用 delete 运算符，删除之前由 new 运算符分配的内存。\n模板模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。\n12345678910template &lt;class type&gt; ret-type func-name(parameter list)&#123;   // 函数的主体&#125;// eg.template &lt;typename T&gt; inline T const&amp; Max (T const&amp; a, T const&amp; b) &#123;     return a &lt; b ? b:a; &#125;\n类模板正如我们定义函数模板一样，我们也可以定义类模板\n123template &lt;class type&gt; class class-name &#123;\t// class thing&#125;\n预处理器#define 预处理指令用于创建符号常量。该符号常量通常称为宏.\n条件编译 #ifndef #define #endif。可以使用 #if 0 语句注释掉程序的一部分\n# 运算符会把 replacement-text 令牌转换为用引号引起来的字符串。\n## 运算符用于连接两个令牌。\n1234567#define MKSTR( x ) #xint main ()&#123;    cout &lt;&lt; MKSTR(HELLO C++) &lt;&lt; endl;    return 0;&#125;//out-&gt; HELLO C++\n其他特殊编译符号\n123456789101112131415161718#include &lt;iostream&gt;using namespace std; int main ()&#123;    cout &lt;&lt; \"Value of __LINE__ : \" &lt;&lt; __LINE__ &lt;&lt; endl;    cout &lt;&lt; \"Value of __FILE__ : \" &lt;&lt; __FILE__ &lt;&lt; endl;    cout &lt;&lt; \"Value of __DATE__ : \" &lt;&lt; __DATE__ &lt;&lt; endl;    cout &lt;&lt; \"Value of __TIME__ : \" &lt;&lt; __TIME__ &lt;&lt; endl;     return 0;&#125;/*Value of __LINE__ : 6Value of __FILE__ : test.cppValue of __DATE__ : Feb 28 2011Value of __TIME__ : 18:52:48*/\n多线程一般情况下，两种类型的多任务处理：基于进程和基于线程。\n\n基于进程的多任务处理是程序的并发执行。\n基于线程的多任务处理是同一程序的片段的并发执行。\n\n假设在linux系统下\n创建一个 POSIX 线程：#include &lt;pthread.h&gt;\npthread_create (thread, attr, start_routine, arg)\n\n\n\n参数\n描述\n\n\n\n\nthread\n指向线程标识符指针。\n\n\nattr\n一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。\n\n\nstart_routine\n线程运行函数起始地址，一旦线程被创建就会执行。\n\n\narg\n运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。\n\n\n\n终止：pthread_exit (status)\n连接和分离线程我们可以使用以下两个函数来连接或分离线程：\n12pthread_join (threadid, status) pthread_detach (threadid)\npthread_join() 子程序阻碍调用程序，直到指定的threadid线程终止为止。当创建一个线程时，它的某个属性会定义它是否是可连接的（joinable）或可分离的（detached）。只有创建时定义为可连接的线程才可以被连接。如果线程创建时被定义为可分离的，则它永远也不能被连接。\n什么是 CGI？\n公共网关接口（CGI），是一套标准，定义了信息是如何在 Web 服务器和客户端脚本之间进行交换的。\nCGI 规范目前是由 NCSA 维护的，NCSA 定义 CGI 如下：\n公共网关接口（CGI），是一种用于外部网关程序与信息服务器（如 HTTP 服务器）对接的接口标准。\n目前的版本是 CGI/1.1，CGI/1.2 版本正在推进中。\n\n比如我们点击一个超链接，浏览一个特定的网页或 URL时\n\n您的浏览器联系上 HTTP Web 服务器，并请求 URL，即文件名。\nWeb 服务器将解析 URL，并查找文件名。如果找到请求的文件，Web 服务器会把文件发送回浏览器，否则发送一条错误消息，表明您请求了一个错误的文件。\nWeb 浏览器从 Web 服务器获取响应，并根据接收到的响应来显示文件或错误消息。\n\n以这种方式搭建起来的 HTTP 服务器，不管何时请求目录中的某个文件，HTTP 服务器发送回来的不是该文件，而是以程序形式执行，并把执行产生的输出发送回浏览器显示出来。(比如php的响应echo)\nHTTP 头信息\n\n\n头信息\n描述\n\n\n\n\nContent-type:\nMIME 字符串，定义返回的文件格式。例如 Content-type:text/html。\n\n\nExpires: Date\n信息变成无效的日期。浏览器使用它来判断一个页面何时需要刷新。一个有效的日期字符串的格式应为 01 Jan 1998 12:00:00 GMT。\n\n\nLocation: URL\n这个 URL 是指应该返回的 URL，而不是请求的 URL。你可以使用它来重定向一个请求到任意的文件。\n\n\nLast-modified: Date\n资源的最后修改日期。\n\n\nContent-length: N\n要返回的数据的长度，以字节为单位。浏览器使用这个值来表示一个文件的预计下载时间。\n\n\nSet-Cookie: String\n通过 string 设置 cookie。\n\n\n\nCGI 环境变量\n\n\n变量名\n描述\n\n\n\n\nCONTENT_TYPE\n内容的数据类型。当客户端向服务器发送附加内容时使用。例如，文件上传等功能。\n\n\nCONTENT_LENGTH\n查询的信息长度。只对 POST 请求可用。\n\n\nHTTP_COOKIE\n以键 &amp; 值对的形式返回设置的 cookies。\n\n\nHTTP_USER_AGENT\n用户代理请求标头字段，递交用户发起请求的有关信息，包含了浏览器的名称、版本和其他平台性的附加信息。\n\n\nPATH_INFO\nCGI 脚本的路径。\n\n\nQUERY_STRING\n通过 GET 方法发送请求时的 URL 编码信息，包含 URL 中问号后面的参数。\n\n\nREMOTE_ADDR\n发出请求的远程主机的 IP 地址。这在日志记录和认证时是非常有用的。\n\n\nREMOTE_HOST\n发出请求的主机的完全限定名称。如果此信息不可用，则可以用 REMOTE_ADDR 来获取 IP 地址。\n\n\nREQUEST_METHOD\n用于发出请求的方法。最常见的方法是 GET 和 POST。\n\n\nSCRIPT_FILENAME\nCGI 脚本的完整路径。\n\n\nSCRIPT_NAME\nCGI 脚本的名称。\n\n\nSERVER_NAME\n服务器的主机名或 IP 地址。\n\n\nSERVER_SOFTWARE\n服务器上运行的软件的名称和版本。\n\n\n\nGET/POSTGET 方法发送已编码的用户信息追加到页面请求中。页面和已编码信息通过 ? 字符分隔开，如下所示：\n1http://www.test.com/cgi-bin/cpp.cgi?key1=value1&amp;key2=value2\nGET 方法有大小限制，在一个请求字符串中最多可以传 1024 个字符。敏感信息不要使用 GET 方法。\n在 CGI 中使用 Cookies使用 cookies 是记忆和跟踪有关用户喜好、购买、佣金以及其他为追求更好的游客体验或网站统计所需信息的最有效的方法。\n它是如何工作的服务器以 cookie 的形式向访客的浏览器发送一些数据。如果浏览器接受了 cookie，则 cookie 会以纯文本记录的形式存储在访客的硬盘上。现在，当访客访问网站上的另一个页面时，会检索 cookie。一旦找到 cookie，服务器就知道存储了什么。\n\nExpires : cookie 的过期日期。如果此字段留空，cookie 会在访客退出浏览器时过期。\nDomain : 网站的域名。\nPath : 设置 cookie 的目录或网页的路径。如果您想从任意的目录或网页检索 cookie，此字段可以留空。\nSecure : 如果此字段包含单词 “secure”，那么 cookie 只能通过安全服务器进行检索。如果此字段留空，则不存在该限制。\nName=Value : cookie 以键值对的形式被设置和获取。\n\n常用知识点预编译\npragma once: 让头文件只被引用一次\npragma pack(4): 手动设置文件中的位对其\n#ifdef #ifndef #if #else #error: 预编译阶段的替换判断等。\n#define: 宏定义，会在编译前进行相关字段的替换\n\n构造函数、析构函数、拷贝构造函数\n编译器默认会写有一个构造函数、一个析构函数、一个拷贝构造函数\n\n\n构造函数  用于类在new时候的初始化调用。一般来说，如果类中有在构造时需要进行的操作，或需要传入特殊的参数时，需要定义构造函数。父类调用，在子类调用\n析构函数  用于实体类在被delete时，处理一些东西。子类调用，再父类调用。\n拷贝构造函数  用于在通过一个类来初始化一个新类时、或函数传参时、或函数返回时\n\nextern关键字\n后接 C  c++中是有函数重载的，编译器在编译的时候会将函数名和参数结合起来hash为一个新的名字，而C中名字却只会用函数名和返回值。这是编译的不同点。  那么extern就会告诉编译器以下的部分用C的方式进行编译和运行。这样C++就能完美的融合C的代码了\n后接变量或函数  这样用于表示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义\n现有解决方案  现在业界都是通过在*.h文件提供对外部的接口的声明，在C++中实现，那么其他文件只要include了这个头文件就能直接使用这个接口了。\n\nstatic作用简析\n用于变量  在内存中存放的位置是全局数据区域。这个特性使得他的初始化为0。  在全局使用static的话，则会对其他文件进行隐藏。  在局部使用的话，比如在函数体内进行声明。那么函数运行多次的情况下，这个变量也只会被声明一次，当函数退出时，他仍在全局数据区域。只有程序退出时，才会销毁这个变量。\n用于普通函数  同样的具有隐藏作用。\n类中的static  这样使用的static会使得声明的变量是整个类公共使用的。这个变量是声明在全局数据区域的，不会占类的空间\n\n模板编程1234567template&lt;class T, typename N&gt;    class xx&#123;&#125;    // ...template&lt;typename T&gt;void functionName(T a)&#123;    printf(\"SAY HI\\n\");&#125;\ntemplate中的class和tempname具有同样的作用，多种种类的使用某个变量。但是区分的作用在于能在类中使用另一个typename。\nunion 与 enum\nunion 是联合体，联合体的意义就在于能极大节省空间的让某个变量变为联合体中的一种值。占用空间是空间中最长的字段\nenum 是状态定义的最好选择，他能自动从0开始声明这个名字的变量, 但是，不可以重名，包括外部。默认字段位长为4，如果过长会变为8\n\nstruct大小的计算在c++中，struct和class的唯一区别是struct默认声明的变量、函数是public的，而class是private的。计算以块的形式进行堆叠，char占1，int占4，long占4，double占8。那么在声明到最后前，struct会将变量一个一个的塞到块里，当前行的块够就塞，不够就换新的块，所以struct大小会和变量声明的顺序有关。到最后的时候会变为最大值的整数倍。其中块的大小由其中的变量占位最大的决定、或者由#pragma pack()决定\n\n空的class类会占用1位空间，虚函数表会占用一个指针大小的空间\n\n智能指针\nauto_ptr 在c++11中已经被废弃  这种智能指针能在引用变为0时自动释放，并且可以被抢占\nunique_ptr  它和auto_ptr的区别在于unique的指针是不可抢占型的\nshared_ptr  分享指针在使用时会有count进行计算这个指针的引用次数，当次数为0时会自动释放\nweak_ptr  这个指针是为了解决分享指针的循环引用的问题，他可以转化为share指针，可以调用来使用。一般在循环引用的时候应该使用weak指针。weak指针不能单独使用。\n\nvirtual字段\n在类中函数声明时  此时的virtual使得类有了多态性，这个类可以被子类进行覆盖，但是父类的函数仍然是存在的。而其他的类同样也可以进行自己的声明。  virtual字段告诉编译器在使用这个函数时需要找到对应的类的层所声明的函数进行使用。\n类继承时使用  这是为了解决菱形继承的问题。这个问题在于一个类继承与多个单种的类，造成二义性和空间浪费。virtual字段会在继承时只声明和使用一个这样的基类。那么到最后的子类时，就只会存在一个了\n\n重载运算符new delete 与 malloc free\nnew delete会自动声明类空间大小的内存，并且调用构造和析构函数\nmalloc free则需要自己说明要声明的空间的大小\nnew、delete是运算符，malloc和free是函数\n\nconst pointer\n类中的函数后加const代表不修改类中的成员变量。\n\n\n指针常量：指针是常量。 int* const a;表明指针是常量，不可改变，但是指针所指向的内存空间的值是可以改变的。\n常量指针：常量的指针。 const int* a;表面指针所指的空间是常量，不可改变，但是指针是可以改变的，他可以指向其他的常量。\n常量指针常量：是常量的指针，且指向的内存空间的值也是常量。\n\n指针和引用\n初始化上，指针在声明时可以不用初始化，而引用必须要初始化。\n空间上，指针占用空间，一般为int类型的4字节大小，而引用是变量别名，不一定占用空间。\n引用没有常量一说。\n重新赋值上，指针可以改变对象，而引用不可改变。\n\n_cast关键字\nconst_cast  将一个常量的值转为非常量，一般都是赋值到新的指针中。指针指向的并不是常量。\nstatic_cast  做一些比较自然和低风险的转换，比如整型、浮点数、字符型之间的转换。  不能用于不同类型的指针之间的转换，也不能用于整型和指针之间的转换\nreinterpret_cast  用于指针之间、整型与指针之间、不同引用之间的转换。方式是逐bit进行比较\ndynamic_cast  用于从基类指针或引用强制转换到派生类的指针或引用。相比较于reinterpret来说会有安全性检查。\n\nexpicit关键字这个关键字的作用在于禁止隐式转换。如果构造函数中的参数只有一个，那么编译器有可能会将它识别为将一个这种类型的值用=隐式转换为这个类型。\n123String(int n); // 声明用于构造一个大小为n的字符串。String s1 = 10; // 隐式转换为声明10个大小的字符串String s2 = 'a'; // 这里就有问题了，声明了大小为'a'长度的字符串。也就是97位长的。\n","dateCreated":"2019-05-02T18:09:33+08:00","dateModified":"2019-10-28T21:14:15+08:00","datePublished":"2019-05-02T18:09:33+08:00","description":"","headline":"c++进阶学习笔记","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://jelech.top/posts/26201/"},"publisher":{"@type":"Organization","name":"Jelech","sameAs":["https://github.com/jelech","mailto"],"image":"avatar.jpg","logo":{"@type":"ImageObject","url":"avatar.jpg"}},"url":"https://jelech.top/posts/26201/","keywords":"笔记, c++"}</script>
    <meta name="keywords" content="笔记,c++">
<meta property="og:type" content="blog">
<meta property="og:title" content="c++进阶学习笔记">
<meta property="og:url" content="https://jelech.top/posts/26201/index.html">
<meta property="og:site_name" content="Jelech的博客">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="https://jelech.top/posts/26201/assets/exceptions_in_cpp-1543739044716.png">
<meta property="og:updated_time" content="2019-10-28T13:14:15.012Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="c++进阶学习笔记">
<meta name="twitter:image" content="https://jelech.top/posts/26201/assets/exceptions_in_cpp-1543739044716.png">
<meta name="twitter:creator" content="@twitter">
    
    
        
    
    
        <meta property="og:image" content="https://jelech.top/assets/images/avatar.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-du2xmrqdqrl2ollgeiw050kpl6l4nbyz7bumjuurjgsxyopifvukebxc9lqe.min.css">
    <!--STYLES END-->
    

    
    <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?fc576447bb0c014aee82fbe7d96b4401";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">Jelech的博客</a>
    </div>
    
        
            <a class="header-right-picture " href="#about">
        
        
            <img class="header-picture" src="/assets/images/avatar.jpg" alt="作者的图片">
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.jpg" alt="作者的图片">
                </a>
                <h4 class="sidebar-profile-name">Jelech</h4>
                
                    <h5 class="sidebar-profile-bio"><p>putty本无树,MinGW亦非台</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/ " title="首页">
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-categories" title="分类">
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-tags" title="标签">
                    
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-archives" title="归档">
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/game" title="游戏">
                    
                        <i class="sidebar-button-icon fas fa-gamepad" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">游戏</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="#about" title="关于">
                    
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="https://github.com/jelech" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/mailto" title="邮箱">
                    
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">邮箱</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            c++进阶学习笔记
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2019-05-02T18:09:33+08:00">
	
		    5月 02, 2019
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/学习笔记/">学习笔记</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            
            <h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#cpp进阶学习"><span class="toc-text">cpp进阶学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#继承"><span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基类和派生类"><span class="toc-text">基类和派生类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承类型"><span class="toc-text">继承类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多继承"><span class="toc-text">多继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#多继承-环状继承时"><span class="toc-text">多继承(环状继承时)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重载运算符"><span class="toc-text">重载运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#可重载运算符-不可重载运算符"><span class="toc-text">可重载运算符/不可重载运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#类成员访问运算符"><span class="toc-text">类成员访问运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#值得注意的是"><span class="toc-text">值得注意的是:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态多态"><span class="toc-text">静态多态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚函数"><span class="toc-text">虚函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#纯虚函数"><span class="toc-text">纯虚函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据抽象"><span class="toc-text">数据抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#访问标签强制抽象"><span class="toc-text">访问标签强制抽象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据封装"><span class="toc-text">数据封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口（抽象类）"><span class="toc-text">接口（抽象类）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异常处理"><span class="toc-text">异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#异常表"><span class="toc-text">异常表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-动态内存"><span class="toc-text">C++ 动态内存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模板"><span class="toc-text">模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#类模板"><span class="toc-text">类模板</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#预处理器"><span class="toc-text">预处理器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程"><span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建一个-POSIX-线程："><span class="toc-text">创建一个 POSIX 线程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#连接和分离线程"><span class="toc-text">连接和分离线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是-CGI？"><span class="toc-text">什么是 CGI？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-头信息"><span class="toc-text">HTTP 头信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CGI-环境变量"><span class="toc-text">CGI 环境变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GET-POST"><span class="toc-text">GET/POST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在-CGI-中使用-Cookies"><span class="toc-text">在 CGI 中使用 Cookies</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#它是如何工作的"><span class="toc-text">它是如何工作的</span></a></li></ol></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#常用知识点"><span class="toc-text">常用知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#预编译"><span class="toc-text">预编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造函数、析构函数、拷贝构造函数"><span class="toc-text">构造函数、析构函数、拷贝构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#extern关键字"><span class="toc-text">extern关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static作用简析"><span class="toc-text">static作用简析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模板编程"><span class="toc-text">模板编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#union-与-enum"><span class="toc-text">union 与 enum</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct大小的计算"><span class="toc-text">struct大小的计算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#智能指针"><span class="toc-text">智能指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#virtual字段"><span class="toc-text">virtual字段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重载运算符-1"><span class="toc-text">重载运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new-delete-与-malloc-free"><span class="toc-text">new delete 与 malloc free</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const-pointer"><span class="toc-text">const pointer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#指针和引用"><span class="toc-text">指针和引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cast关键字"><span class="toc-text">_cast关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#expicit关键字"><span class="toc-text">expicit关键字</span></a></li></ol></li>
<a id="more"></a>
<h1 id="cpp进阶学习"><a href="#cpp进阶学习" class="headerlink" title="cpp进阶学习"></a>cpp进阶学习</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="基类和派生类"><a href="#基类和派生类" class="headerlink" title="基类和派生类"></a>基类和派生类</h3><p>一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span>-<span class="title">class</span>:</span> access-specifier base-<span class="class"><span class="keyword">class</span></span></span><br></pre></td></tr></table></figure>
<p>其中，访问修饰符 access-specifier 是 <strong>public、protected</strong> 或 <strong>private</strong> 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。</p>
<h3 id="继承类型"><a href="#继承类型" class="headerlink" title="继承类型"></a>继承类型</h3><p>当一个类派生自基类，该基类可以被继承为 <strong>public、protected</strong> 或 <strong>private</strong> 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。</p>
<p>我们几乎不使用 <strong>protected</strong> 或 <strong>private</strong> 继承，通常使用 <strong>public</strong> 继承。当使用不同类型的继承时，遵循以下几个规则：</p>
<ul>
<li><strong>公有继承（public）：</strong>当一个类派生自<strong>公有</strong>基类时，基类的<strong>公有</strong>成员也是派生类的<strong>公有</strong>成员，基类的<strong>保护</strong>成员也是派生类的<strong>保护</strong>成员，基类的<strong>私有</strong>成员不能直接被派生类访问，但是可以通过调用基类的<strong>公有</strong>和<strong>保护</strong>成员来访问。</li>
<li><strong>保护继承（protected）：</strong> 当一个类派生自<strong>保护</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>保护</strong>成员。</li>
<li><strong>私有继承（private）：</strong>当一个类派生自<strong>私有</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>私有</strong>成员。</li>
</ul>
<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>多继承即一个子类可以有多个父类，它继承了多个父类的特性。</p>
<p>C++ 类可以从多个类继承成员，语法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;派生类名&gt;:</span>&lt;继承方式<span class="number">1</span>&gt;&lt;基类名<span class="number">1</span>&gt;,&lt;继承方式<span class="number">2</span>&gt;&lt;基类名<span class="number">2</span>&gt;,…</span><br><span class="line">&#123;</span><br><span class="line">	&lt;派生类类体&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="多继承-环状继承时"><a href="#多继承-环状继承时" class="headerlink" title="多继承(环状继承时)"></a>多继承(环状继承时)</h4><p>A-&gt;D, B-&gt;D, C-&gt;(A，B)，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class D&#123;......&#125;;</span><br><span class="line">class B: public D&#123;......&#125;;</span><br><span class="line">class A: public D&#123;......&#125;;</span><br><span class="line">class C: public B, public A&#123;.....&#125;;</span><br></pre></td></tr></table></figure>
<p>这个继承会使D创建两个对象,要解决上面问题就要用<code>虚拟继承格式</code></p>
<p>格式：class 类名: virtual 继承方式 父类名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class D&#123;......&#125;;</span><br><span class="line">class B: virtual public D&#123;......&#125;;</span><br><span class="line">class A: virtual public D&#123;......&#125;;</span><br><span class="line">class C: public B, public A&#123;.....&#125;;</span><br></pre></td></tr></table></figure>
<p>虚继承–（在创建对象的时候会创建一个虚表）在创建父类对象的时候</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A:virtual public D</span><br><span class="line">B:virtual public D</span><br></pre></td></tr></table></figure>
<h2 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h2><h3 id="可重载运算符-不可重载运算符"><a href="#可重载运算符-不可重载运算符" class="headerlink" title="可重载运算符/不可重载运算符"></a>可重载运算符/不可重载运算符</h3><p>下面是可重载的运算符列表：</p>
<table>
<thead>
<tr>
<th>双目算术运算符</th>
<th>+ (加)，-(减)，*(乘)，/(除)，% (取模)</th>
</tr>
</thead>
<tbody>
<tr>
<td>关系运算符</td>
<td>==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于&gt;，&lt;=(小于等于)，&gt;=(大于等于)</td>
</tr>
<tr>
<td>逻辑运算符</td>
<td>\</td>
<td>\</td>
<td>(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非)</td>
</tr>
<tr>
<td>单目运算符</td>
<td>+ (正)，-(负)，*(指针)，&amp;(取地址)</td>
</tr>
<tr>
<td>自增自减运算符</td>
<td>++(自增)，–(自减)</td>
</tr>
<tr>
<td>位运算符</td>
<td>\</td>
<td>(按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移)</td>
</tr>
<tr>
<td>赋值运算符</td>
<td>=, +=, -=, *=, /= , % = , &amp;=, \</td>
<td>=, ^=, &lt;&lt;=, &gt;&gt;=</td>
</tr>
<tr>
<td>空间申请与释放</td>
<td>new, delete, new[ ] , delete[]</td>
</tr>
<tr>
<td>其他运算符</td>
<td>()(函数调用)，-&gt;(成员访问)，,(逗号)，<a href="下标"></a></td>
</tr>
</tbody>
</table>
<p>下面是不可重载的运算符列表：</p>
<ul>
<li><code>.</code>：成员访问运算符</li>
<li><code>., -&gt;</code>：成员指针访问运算符</li>
<li><code>::</code>：域运算符</li>
<li><code>sizeof</code>：长度运算符</li>
<li><code>?:</code>：条件运算符</li>
<li><code>#</code>： 预处理符号</li>
</ul>
<h4 id="类成员访问运算符"><a href="#类成员访问运算符" class="headerlink" title="类成员访问运算符"></a>类成员访问运算符</h4><p>类成员访问运算符（ -&gt; ）可以被重载，但它较为麻烦。它被定义用于为一个类赋予”指针”行为。运算符 -&gt; 必须是一个成员函数。如果使用了 -&gt; 运算符，返回类型必须是指针或者是类的对象。</p>
<p>运算符 -&gt; 通常与指针引用运算符 * 结合使用，用于实现”智能指针”的功能。这些指针是行为与正常指针相似的对象，唯一不同的是，当您通过指针访问对象时，它们会执行其他的任务。比如，当指针销毁时，或者当指针指向另一个对象时，会自动删除对象。</p>
<p>间接引用运算符 -&gt; 可被定义为一个一元后缀运算符。也就是说，给出一个类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Ptr&#123;</span><br><span class="line">   //...</span><br><span class="line">   X * operator-&gt;();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类 <strong>Ptr</strong> 的对象可用于访问类 <strong>X</strong> 的成员，使用方式与指针的用法十分相似。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void f(Ptr p )</span><br><span class="line">&#123;</span><br><span class="line">   p-&gt;m = 10 ; // (p.operator-&gt;())-&gt;m = 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>语句 p-&gt;m 被解释为 (p.operator-&gt;())-&gt;m。</p>
<h3 id="值得注意的是"><a href="#值得注意的是" class="headerlink" title="值得注意的是:"></a>值得注意的是:</h3><ul>
<li>1、运算重载符不可以改变语法结构。</li>
<li>2、运算重载符不可以改变操作数的个数。</li>
<li>3、运算重载符不可以改变优先级。</li>
<li>4、运算重载符不可以改变结合性。</li>
</ul>
<h3 id="静态多态"><a href="#静态多态" class="headerlink" title="静态多态"></a>静态多态</h3><p>或<strong>静态链接</strong> - 函数调用在程序执行前就准备好了。有时候这也被称为<strong>早绑定</strong>，因为 area() 函数在程序编译期间就已经设置好了。</p>
<p>但现在，让我们对程序稍作修改，在 Shape 类中，area() 的声明前放置关键字 <strong>virtual</strong>。此时，编译器看的是指针的内容，而不是它的类型。因此，由于 tri 和 rec 类的对象的地址存储在 <em>shape</em> 中，所以会调用各自的 area() 函数。</p>
<p>正如您所看到的，每个子类都有一个函数 area() 的独立实现。这就是<strong>多态</strong>的一般使用方式。有了多态，您可以有多个不同的类，都带有同一个名称但具有不同实现的函数，函数的参数甚至可以是相同的。</p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p><strong>虚函数</strong> 是在基类中使用关键字 <strong>virtual</strong> 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。</p>
<p>我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为<strong>动态链接</strong>，或<strong>后期绑定</strong>。</p>
<h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又<strong>不能对虚函数给出有意义的实现</strong>，这个时候就会用到纯虚函数。</p>
<p>我们可以把基类中的虚函数 area() 改写如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:       </span><br><span class="line">	<span class="keyword">int</span> width, height;</span><br><span class="line"><span class="keyword">public</span>:       </span><br><span class="line">	Shape( <span class="keyword">int</span> a=<span class="number">0</span>, <span class="keyword">int</span> b=<span class="number">0</span>) &#123;</span><br><span class="line">		width = a;</span><br><span class="line">		height = b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// pure virtual function</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">area</span><span class="params">()</span> </span>= <span class="number">0</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a>数据抽象</h2><p>数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。</p>
<p>例如，您的程序可以调用 <strong>sort()</strong> 函数，而不需要知道函数中排序数据所用到的算法。实际上，函数排序的底层实现会因库的版本不同而有所差异，只要接口不变，函数调用就可以照常工作。</p>
<h3 id="访问标签强制抽象"><a href="#访问标签强制抽象" class="headerlink" title="访问标签强制抽象"></a>访问标签强制抽象</h3><p>在 C++ 中，我们使用访问标签来定义类的抽象接口。一个类可以包含零个或多个访问标签：</p>
<ul>
<li>使用公共标签定义的成员都可以访问该程序的所有部分。一个类型的数据抽象视图是由它的公共成员来定义的。</li>
<li>使用私有标签定义的成员无法访问到使用类的代码。私有部分对使用类型的代码隐藏了实现细节。</li>
</ul>
<p>访问标签出现的频率没有限制。每个访问标签指定了紧随其后的成员定义的访问级别。指定的访问级别会一直有效，直到遇到下一个访问标签或者遇到类主体的关闭右括号为止。</p>
<blockquote>
<ul>
<li>类的内部受到保护，不会因无意的用户级错误导致对象状态受损。</li>
<li>类实现可能随着时间的推移而发生变化，以便应对不断变化的需求，或者应对那些要求不改变用户级代码的错误报告。</li>
</ul>
</blockquote>
<h3 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h3><ul>
<li><strong>程序语句（代码）：</strong>这是程序中执行动作的部分，它们被称为函数。</li>
<li><strong>程序数据：</strong>数据是程序的信息，会受到程序函数的影响。</li>
</ul>
<p><strong>数据封装</strong>是一种把数据和操作数据的函数捆绑在一起的机制，<strong>数据抽象</strong>是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。</p>
<h3 id="接口（抽象类）"><a href="#接口（抽象类）" class="headerlink" title="接口（抽象类）"></a>接口（抽象类）</h3><p>如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。</p>
<p>抽象类不能被用于实例化对象，它只能作为<strong>接口</strong>使用。如果试图实例化一个抽象类的对象，会导致编译错误。因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数。</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>C++ 异常是指在程序<code>运行时</code>发生的特殊情况，比如尝试除以零的操作。</p>
<ul>
<li><p><strong>throw:</strong> 当问题出现时，程序会抛出一个异常。这是通过使用 <strong>throw</strong> 关键字来完成的。可以使用 <strong>throw</strong> 语句在代码块中的任何地方抛出异常</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( b == <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">"Division by zero condition!"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>catch:</strong> 在您想要处理问题的地方，通过异常处理程序捕获异常。<strong>catch</strong> 关键字用于捕获异常。</p>
</li>
<li><p><strong>try:</strong> <strong>try</strong> 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。下面的代码会捕获一个类型为 <code>ExceptionName</code> 的异常。如果您想让 catch 块能够处理 try 块抛出的任何类型的异常，则必须在异常声明的括号内使用省略号 <code>...</code></p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 保护代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>( ExceptionName e )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 处理 ExceptionName 异常的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>C++ 提供了一系列标准的异常，定义在 <code>&lt;exception&gt;</code>中。</p>
<p><img src="assets/exceptions_in_cpp-1543739044716.png" alt="C++ 异常的层次结构"></p>
<h3 id="异常表"><a href="#异常表" class="headerlink" title="异常表"></a>异常表</h3><table>
<thead>
<tr>
<th>异常</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>std::exception</strong></td>
<td>该异常是所有标准 C++ 异常的父类。</td>
</tr>
<tr>
<td>std::bad_alloc</td>
<td>该异常可以通过 <strong>new</strong> 抛出。</td>
</tr>
<tr>
<td>std::bad_cast</td>
<td>该异常可以通过 <strong>dynamic_cast</strong> 抛出。</td>
</tr>
<tr>
<td>std::bad_exception</td>
<td>这在处理 C++ 程序中无法预期的异常时非常有用。</td>
</tr>
<tr>
<td>std::bad_typeid</td>
<td>该异常可以通过 <strong>typeid</strong> 抛出。</td>
</tr>
<tr>
<td><strong>std::logic_error</strong></td>
<td>理论上可以通过读取代码来检测到的异常。</td>
</tr>
<tr>
<td>std::domain_error</td>
<td>当使用了一个无效的数学域时，会抛出该异常。</td>
</tr>
<tr>
<td>std::invalid_argument</td>
<td>当使用了无效的参数时，会抛出该异常。</td>
</tr>
<tr>
<td>std::length_error</td>
<td>当创建了太长的 std::string 时，会抛出该异常。</td>
</tr>
<tr>
<td>std::out_of_range</td>
<td>该异常可以通过方法抛出，例如 std::vector 和 std::bitset&lt;&gt;::operator<a href=""></a>。</td>
</tr>
<tr>
<td><strong>std::runtime_error</strong></td>
<td>理论上不可以通过读取代码来检测到的异常。</td>
</tr>
<tr>
<td>std::overflow_error</td>
<td>当发生数学上溢时，会抛出该异常。</td>
</tr>
<tr>
<td>std::range_error</td>
<td>当尝试存储超出范围的值时，会抛出该异常。</td>
</tr>
<tr>
<td>std::underflow_error</td>
<td>当发生数学下溢时，会抛出该异常。</td>
</tr>
</tbody>
</table>
<h3 id="C-动态内存"><a href="#C-动态内存" class="headerlink" title="C++ 动态内存"></a>C++ 动态内存</h3><ul>
<li><strong>栈：</strong>在函数内部声明的所有变量都将占用栈内存。</li>
<li><strong>堆：</strong>这是程序中未使用的内存，在程序运行时可用于动态分配内存。</li>
</ul>
<p>在 C++ 中，您可以使用特殊的运算符为给定类型的变量在运行时分配<code>堆</code>内的内存，这会返回所分配的空间地址。这种运算符即 <strong>new</strong> 运算符。</p>
<p>如果您不再需要动态分配的内存空间，可以使用 <strong>delete</strong> 运算符，删除之前由 new 运算符分配的内存。</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt; <span class="title">ret</span>-<span class="title">type</span> <span class="title">func</span>-<span class="title">name</span>(<span class="title">parameter</span> <span class="title">list</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="comment">// 函数的主体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// eg.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="keyword">const</span>&amp; <span class="title">Max</span> <span class="params">(T <span class="keyword">const</span>&amp; a, T <span class="keyword">const</span>&amp; b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? b:a; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h4><p>正如我们定义函数模板一样，我们也可以定义类模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt; <span class="title">class</span> <span class="title">class</span>-<span class="title">name</span> &#123;</span></span><br><span class="line">	<span class="comment">// class thing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h2><p><code>#define</code> 预处理指令用于创建符号常量。该符号常量通常称为<strong>宏</strong>.</p>
<p>条件编译 <code>#ifndef</code> <code>#define</code> <code>#endif</code>。可以使用 #if 0 语句注释掉程序的一部分</p>
<p><code>#</code> 运算符会把 replacement-text 令牌转换为用引号引起来的字符串。</p>
<p><code>##</code> 运算符用于连接两个令牌。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MKSTR( x ) #x</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; MKSTR(HELLO C++) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//out-&gt; HELLO C++</span></span><br></pre></td></tr></table></figure>
<p>其他特殊编译符号</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Value of __LINE__ : "</span> &lt;&lt; __LINE__ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Value of __FILE__ : "</span> &lt;&lt; __FILE__ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Value of __DATE__ : "</span> &lt;&lt; __DATE__ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Value of __TIME__ : "</span> &lt;&lt; __TIME__ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Value of __LINE__ : 6</span></span><br><span class="line"><span class="comment">Value of __FILE__ : test.cpp</span></span><br><span class="line"><span class="comment">Value of __DATE__ : Feb 28 2011</span></span><br><span class="line"><span class="comment">Value of __TIME__ : 18:52:48</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>一般情况下，两种类型的多任务处理：<strong>基于进程和基于线程</strong>。</p>
<ul>
<li>基于进程的多任务处理是程序的并发执行。</li>
<li>基于线程的多任务处理是同一程序的片段的并发执行。</li>
</ul>
<p>假设在<code>linux</code>系统下</p>
<h3 id="创建一个-POSIX-线程："><a href="#创建一个-POSIX-线程：" class="headerlink" title="创建一个 POSIX 线程："></a>创建一个 POSIX 线程：</h3><p><code>#include &lt;pthread.h&gt;</code></p>
<p><code>pthread_create (thread, attr, start_routine, arg)</code></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>thread</td>
<td>指向线程标识符指针。</td>
</tr>
<tr>
<td>attr</td>
<td>一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。</td>
</tr>
<tr>
<td>start_routine</td>
<td>线程运行函数起始地址，一旦线程被创建就会执行。</td>
</tr>
<tr>
<td>arg</td>
<td>运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。</td>
</tr>
</tbody>
</table>
<p>终止：<code>pthread_exit (status)</code></p>
<h3 id="连接和分离线程"><a href="#连接和分离线程" class="headerlink" title="连接和分离线程"></a>连接和分离线程</h3><p>我们可以使用以下两个函数来连接或分离线程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread_join (threadid, status) </span><br><span class="line">pthread_detach (threadid)</span><br></pre></td></tr></table></figure>
<p><code>pthread_join()</code> 子程序阻碍调用程序，直到指定的<strong>threadid</strong>线程终止为止。当创建一个线程时，它的某个属性会定义它是否是可连接的（joinable）或可分离的（detached）。只有创建时定义为可连接的线程才可以被连接。如果线程创建时被定义为可分离的，则它永远也不能被连接。</p>
<h2 id="什么是-CGI？"><a href="#什么是-CGI？" class="headerlink" title="什么是 CGI？"></a>什么是 CGI？</h2><ul>
<li>公共网关接口（CGI），是一套标准，定义了信息是如何在 Web 服务器和客户端脚本之间进行交换的。</li>
<li>CGI 规范目前是由 NCSA 维护的，NCSA 定义 CGI 如下：</li>
<li>公共网关接口（CGI），是一种用于外部网关程序与信息服务器（如 HTTP 服务器）对接的接口标准。</li>
<li>目前的版本是 CGI/1.1，CGI/1.2 版本正在推进中。</li>
</ul>
<p>比如我们点击一个超链接，浏览一个特定的网页或 URL时</p>
<ul>
<li>您的浏览器联系上 HTTP Web 服务器，并请求 URL，即文件名。</li>
<li>Web 服务器将解析 URL，并查找文件名。如果找到请求的文件，Web 服务器会把文件发送回浏览器，否则发送一条错误消息，表明您请求了一个错误的文件。</li>
<li>Web 浏览器从 Web 服务器获取响应，并根据接收到的响应来显示文件或错误消息。</li>
</ul>
<p>以这种方式搭建起来的 HTTP 服务器，不管何时请求目录中的某个文件，HTTP 服务器发送回来的不是该文件，而是以程序形式执行，并把执行产生的输出发送回浏览器显示出来。(比如php的响应<code>echo</code>)</p>
<h3 id="HTTP-头信息"><a href="#HTTP-头信息" class="headerlink" title="HTTP 头信息"></a>HTTP 头信息</h3><table>
<thead>
<tr>
<th>头信息</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Content-type:</td>
<td>MIME 字符串，定义返回的文件格式。例如 Content-type:text/html。</td>
</tr>
<tr>
<td>Expires: Date</td>
<td>信息变成无效的日期。浏览器使用它来判断一个页面何时需要刷新。一个有效的日期字符串的格式应为 01 Jan 1998 12:00:00 GMT。</td>
</tr>
<tr>
<td>Location: URL</td>
<td>这个 URL 是指应该返回的 URL，而不是请求的 URL。你可以使用它来重定向一个请求到任意的文件。</td>
</tr>
<tr>
<td>Last-modified: Date</td>
<td>资源的最后修改日期。</td>
</tr>
<tr>
<td>Content-length: N</td>
<td>要返回的数据的长度，以字节为单位。浏览器使用这个值来表示一个文件的预计下载时间。</td>
</tr>
<tr>
<td>Set-Cookie: String</td>
<td>通过 <em>string</em> 设置 cookie。</td>
</tr>
</tbody>
</table>
<h3 id="CGI-环境变量"><a href="#CGI-环境变量" class="headerlink" title="CGI 环境变量"></a>CGI 环境变量</h3><table>
<thead>
<tr>
<th>变量名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONTENT_TYPE</td>
<td>内容的数据类型。当客户端向服务器发送附加内容时使用。例如，文件上传等功能。</td>
</tr>
<tr>
<td>CONTENT_LENGTH</td>
<td>查询的信息长度。只对 POST 请求可用。</td>
</tr>
<tr>
<td>HTTP_COOKIE</td>
<td>以键 &amp; 值对的形式返回设置的 cookies。</td>
</tr>
<tr>
<td>HTTP_USER_AGENT</td>
<td>用户代理请求标头字段，递交用户发起请求的有关信息，包含了浏览器的名称、版本和其他平台性的附加信息。</td>
</tr>
<tr>
<td>PATH_INFO</td>
<td>CGI 脚本的路径。</td>
</tr>
<tr>
<td>QUERY_STRING</td>
<td>通过 GET 方法发送请求时的 URL 编码信息，包含 URL 中问号后面的参数。</td>
</tr>
<tr>
<td>REMOTE_ADDR</td>
<td>发出请求的远程主机的 IP 地址。这在日志记录和认证时是非常有用的。</td>
</tr>
<tr>
<td>REMOTE_HOST</td>
<td>发出请求的主机的完全限定名称。如果此信息不可用，则可以用 REMOTE_ADDR 来获取 IP 地址。</td>
</tr>
<tr>
<td>REQUEST_METHOD</td>
<td>用于发出请求的方法。最常见的方法是 GET 和 POST。</td>
</tr>
<tr>
<td>SCRIPT_FILENAME</td>
<td>CGI 脚本的完整路径。</td>
</tr>
<tr>
<td>SCRIPT_NAME</td>
<td>CGI 脚本的名称。</td>
</tr>
<tr>
<td>SERVER_NAME</td>
<td>服务器的主机名或 IP 地址。</td>
</tr>
<tr>
<td>SERVER_SOFTWARE</td>
<td>服务器上运行的软件的名称和版本。</td>
</tr>
</tbody>
</table>
<h3 id="GET-POST"><a href="#GET-POST" class="headerlink" title="GET/POST"></a>GET/POST</h3><p>GET 方法发送已编码的用户信息追加到页面请求中。页面和已编码信息通过 ? 字符分隔开，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.test.com/cgi-bin/cpp.cgi?key1=value1&amp;key2=value2</span><br></pre></td></tr></table></figure>
<p>GET 方法有大小限制，在一个请求字符串中最多可以传 1024 个字符。敏感信息不要使用 GET 方法。</p>
<h3 id="在-CGI-中使用-Cookies"><a href="#在-CGI-中使用-Cookies" class="headerlink" title="在 CGI 中使用 Cookies"></a>在 CGI 中使用 Cookies</h3><p>使用 cookies 是记忆和跟踪有关用户喜好、购买、佣金以及其他为追求更好的游客体验或网站统计所需信息的最有效的方法。</p>
<h4 id="它是如何工作的"><a href="#它是如何工作的" class="headerlink" title="它是如何工作的"></a>它是如何工作的</h4><p>服务器以 cookie 的形式向访客的浏览器发送一些数据。如果浏览器接受了 cookie，则 cookie 会以纯文本记录的形式存储在访客的硬盘上。现在，当访客访问网站上的另一个页面时，会检索 cookie。一旦找到 cookie，服务器就知道存储了什么。</p>
<ul>
<li><strong>Expires :</strong> cookie 的过期日期。如果此字段留空，cookie 会在访客退出浏览器时过期。</li>
<li><strong>Domain :</strong> 网站的域名。</li>
<li><strong>Path :</strong> 设置 cookie 的目录或网页的路径。如果您想从任意的目录或网页检索 cookie，此字段可以留空。</li>
<li><strong>Secure :</strong> 如果此字段包含单词 “secure”，那么 cookie 只能通过安全服务器进行检索。如果此字段留空，则不存在该限制。</li>
<li><strong>Name=Value :</strong> cookie 以键值对的形式被设置和获取。</li>
</ul>
<h1 id="常用知识点"><a href="#常用知识点" class="headerlink" title="常用知识点"></a>常用知识点</h1><h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><ul>
<li><code>pragma once</code>: 让头文件只被引用一次</li>
<li><code>pragma pack(4)</code>: 手动设置文件中的位对其</li>
<li><code>#ifdef #ifndef #if #else #error</code>: 预编译阶段的替换判断等。</li>
<li><code>#define</code>: 宏定义，会在编译前进行相关字段的替换</li>
</ul>
<h2 id="构造函数、析构函数、拷贝构造函数"><a href="#构造函数、析构函数、拷贝构造函数" class="headerlink" title="构造函数、析构函数、拷贝构造函数"></a>构造函数、析构函数、拷贝构造函数</h2><blockquote>
<p>编译器默认会写有一个构造函数、一个析构函数、一个拷贝构造函数</p>
</blockquote>
<ul>
<li>构造函数<br>  用于类在new时候的初始化调用。一般来说，如果类中有在构造时需要进行的操作，或需要传入特殊的参数时，需要定义构造函数。父类调用，在子类调用</li>
<li>析构函数<br>  用于实体类在被delete时，处理一些东西。子类调用，再父类调用。</li>
<li>拷贝构造函数<br>  用于在通过一个类来初始化一个新类时、或函数传参时、或函数返回时</li>
</ul>
<h2 id="extern关键字"><a href="#extern关键字" class="headerlink" title="extern关键字"></a>extern关键字</h2><ul>
<li>后接 <code>C</code><br>  c++中是有函数重载的，编译器在编译的时候会将函数名和参数结合起来hash为一个新的名字，而C中名字却只会用函数名和返回值。这是编译的不同点。<br>  那么<code>extern</code>就会告诉编译器以下的部分用C的方式进行编译和运行。这样C++就能完美的融合C的代码了</li>
<li>后接变量或函数<br>  这样用于表示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义</li>
<li>现有解决方案<br>  现在业界都是通过在<code>*.h</code>文件提供对外部的接口的声明，在C++中实现，那么其他文件只要include了这个头文件就能直接使用这个接口了。</li>
</ul>
<h2 id="static作用简析"><a href="#static作用简析" class="headerlink" title="static作用简析"></a>static作用简析</h2><ul>
<li>用于变量<br>  在内存中存放的位置是全局数据区域。这个特性使得他的初始化为0。<br>  在全局使用static的话，则会对其他文件进行隐藏。<br>  在局部使用的话，比如在函数体内进行声明。那么函数运行多次的情况下，这个变量也只会被声明一次，当函数退出时，他仍在全局数据区域。只有程序退出时，才会销毁这个变量。</li>
<li>用于普通函数<br>  同样的具有隐藏作用。</li>
<li>类中的static<br>  这样使用的static会使得声明的变量是整个类公共使用的。这个变量是声明在全局数据区域的，<strong>不会占类的空间</strong></li>
</ul>
<h2 id="模板编程"><a href="#模板编程" class="headerlink" title="模板编程"></a>模板编程</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">typename</span> <span class="title">N</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">xx</span>&#123;</span>&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionName</span><span class="params">(T a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"SAY HI\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>template</code>中的class和tempname具有同样的作用，多种种类的使用某个变量。但是区分的作用在于能在类中使用另一个typename。</p>
<h2 id="union-与-enum"><a href="#union-与-enum" class="headerlink" title="union 与 enum"></a>union 与 enum</h2><ul>
<li>union 是联合体，联合体的意义就在于能极大节省空间的让某个变量变为联合体中的一种值。占用空间是空间中最长的字段</li>
<li>enum 是状态定义的最好选择，他能自动从0开始声明这个名字的变量, 但是，不可以重名，包括外部。默认字段位长为4，如果过长会变为8</li>
</ul>
<h2 id="struct大小的计算"><a href="#struct大小的计算" class="headerlink" title="struct大小的计算"></a>struct大小的计算</h2><p>在c++中，struct和class的唯一区别是struct默认声明的变量、函数是public的，而class是private的。<br>计算以块的形式进行堆叠，char占1，int占4，long占4，double占8。那么在声明到最后前，struct会将变量一个一个的塞到块里，当前行的块够就塞，不够就换新的块，所以struct大小会和变量声明的顺序有关。到最后的时候会变为最大值的整数倍。其中块的大小由其中的变量占位最大的决定、或者由#pragma pack()决定</p>
<ul>
<li>空的class类会占用1位空间，虚函数表会占用一个指针大小的空间</li>
</ul>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><ul>
<li>auto_ptr 在c++11中已经被废弃<br>  这种智能指针能在引用变为0时自动释放，并且可以被抢占</li>
<li>unique_ptr<br>  它和auto_ptr的区别在于unique的指针是不可抢占型的</li>
<li>shared_ptr<br>  分享指针在使用时会有count进行计算这个指针的引用次数，当次数为0时会自动释放</li>
<li>weak_ptr<br>  这个指针是为了解决分享指针的循环引用的问题，他可以转化为share指针，可以调用来使用。一般在循环引用的时候应该使用weak指针。weak指针不能单独使用。</li>
</ul>
<h2 id="virtual字段"><a href="#virtual字段" class="headerlink" title="virtual字段"></a>virtual字段</h2><ul>
<li>在类中函数声明时<br>  此时的virtual使得类有了多态性，这个类可以被子类进行覆盖，但是父类的函数仍然是存在的。而其他的类同样也可以进行自己的声明。<br>  virtual字段告诉编译器在使用这个函数时需要找到对应的类的层所声明的函数进行使用。</li>
<li>类继承时使用<br>  这是为了解决菱形继承的问题。这个问题在于一个类继承与多个单种的类，造成二义性和空间浪费。virtual字段会在继承时只声明和使用一个这样的基类。那么到最后的子类时，就只会存在一个了</li>
</ul>
<h2 id="重载运算符-1"><a href="#重载运算符-1" class="headerlink" title="重载运算符"></a>重载运算符</h2><h2 id="new-delete-与-malloc-free"><a href="#new-delete-与-malloc-free" class="headerlink" title="new delete 与 malloc free"></a>new delete 与 malloc free</h2><ul>
<li>new delete会自动声明类空间大小的内存，并且调用构造和析构函数</li>
<li>malloc free则需要自己说明要声明的空间的大小</li>
<li>new、delete是运算符，malloc和free是函数</li>
</ul>
<h2 id="const-pointer"><a href="#const-pointer" class="headerlink" title="const pointer"></a>const pointer</h2><blockquote>
<p>类中的函数后加const代表不修改类中的成员变量。</p>
</blockquote>
<ul>
<li>指针常量：指针是常量。 <code>int* const a;</code>表明指针是常量，不可改变，但是指针所指向的内存空间的值是可以改变的。</li>
<li>常量指针：常量的指针。 <code>const int* a;</code>表面指针所指的空间是常量，不可改变，但是指针是可以改变的，他可以指向其他的常量。</li>
<li>常量指针常量：是常量的指针，且指向的内存空间的值也是常量。</li>
</ul>
<h2 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h2><ul>
<li>初始化上，指针在声明时可以不用初始化，而引用必须要初始化。</li>
<li>空间上，指针占用空间，一般为int类型的4字节大小，而引用是变量别名，不一定占用空间。</li>
<li>引用没有常量一说。</li>
<li>重新赋值上，指针可以改变对象，而引用不可改变。</li>
</ul>
<h2 id="cast关键字"><a href="#cast关键字" class="headerlink" title="_cast关键字"></a>_cast关键字</h2><ul>
<li>const_cast<br>  将一个常量的值转为非常量，一般都是赋值到新的指针中。指针指向的并不是常量。</li>
<li>static_cast<br>  做一些比较自然和低风险的转换，比如整型、浮点数、字符型之间的转换。<br>  不能用于不同类型的指针之间的转换，也不能用于整型和指针之间的转换</li>
<li>reinterpret_cast<br>  用于指针之间、整型与指针之间、不同引用之间的转换。方式是逐bit进行比较</li>
<li>dynamic_cast<br>  用于从基类指针或引用强制转换到派生类的指针或引用。相比较于reinterpret来说会有安全性检查。</li>
</ul>
<h2 id="expicit关键字"><a href="#expicit关键字" class="headerlink" title="expicit关键字"></a>expicit关键字</h2><p>这个关键字的作用在于禁止隐式转换。如果构造函数中的参数只有一个，那么编译器有可能会将它识别为将一个这种类型的值用<code>=</code>隐式转换为这个类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String(<span class="keyword">int</span> n); <span class="comment">// 声明用于构造一个大小为n的字符串。</span></span><br><span class="line">String s1 = <span class="number">10</span>; <span class="comment">// 隐式转换为声明10个大小的字符串</span></span><br><span class="line">String s2 = <span class="string">'a'</span>; <span class="comment">// 这里就有问题了，声明了大小为'a'长度的字符串。也就是97位长的。</span></span><br></pre></td></tr></table></figure>

            

        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">标签</span><br>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/c/">c++</a> <a class="tag tag--primary tag--small t-link" href="/tags/笔记/">笔记</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/posts/4539/" data-tooltip="Redis学习（一）" aria-label="上一篇: Redis学习（一）">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/posts/10156/" data-tooltip="关于高并发和秒杀系统的讨论【转】" aria-label="下一篇: 关于高并发和秒杀系统的讨论【转】">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="分享">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://jelech.top/posts/26201/" title="分享到 Facebook">
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=https://jelech.top/posts/26201/" title="分享到 Twitter">
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=https://jelech.top/posts/26201/" title="分享到 Google+">
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
                <style media="screen">.v .vwrap{overflow: inherit;}</style>
                <div id="vcomment"></div>
                <a href="posts/26201/#vcomment" class="disqus-comment-count"></a>
                <span class="valine-comment-count" data-xid="posts/26201/"></span>
                <span> Comment</span>
            
        
    </div>
</article>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 Jelech. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/posts/4539/" data-tooltip="Redis学习（一）" aria-label="上一篇: Redis学习（一）">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/posts/10156/" data-tooltip="关于高并发和秒杀系统的讨论【转】" aria-label="下一篇: 关于高并发和秒杀系统的讨论【转】">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="分享">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://jelech.top/posts/26201/" title="分享到 Facebook">
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=https://jelech.top/posts/26201/" title="分享到 Twitter">
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=https://jelech.top/posts/26201/" title="分享到 Google+">
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                <div id="share-options-bar" class="share-options-bar" data-behavior="4">
    <i id="btn-close-shareoptions" class="fa fa-times"></i>
    <ul class="share-options">
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://jelech.top/posts/26201/">
                    <i class="fab fa-facebook" aria-hidden="true"></i><span>分享到 Facebook</span>
                </a>
            </li>
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=https://jelech.top/posts/26201/">
                    <i class="fab fa-twitter" aria-hidden="true"></i><span>分享到 Twitter</span>
                </a>
            </li>
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="https://plus.google.com/share?url=https://jelech.top/posts/26201/">
                    <i class="fab fa-google-plus" aria-hidden="true"></i><span>分享到 Google+</span>
                </a>
            </li>
        
    </ul>
</div>

            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.jpg" alt="作者的图片">
        
            <h4 id="about-card-name">Jelech</h4>
        
            <div id="about-card-bio"><p>putty本无树,MinGW亦非台</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br>
                <p>在校大学生一枚</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br>
                CHINA.HRB.STU
            </div>
        

        
            <div id="about-card-job">
                <i class="fa fa-envelope"></i>
                <br>
                jelech@hotmail.com
            </div>
        

        
            <div id="about-card-job">
                <i class="fa fa-phone-square"></i>
                <br>
                18.......6
            </div>
        


    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-vufjrm3fmbuttogo1hxuu0w9w0sesk5iyysjuguc2hdhufot9szxg8twijry.min.js"></script>
<!--SCRIPTS END-->

    
        
        <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js" charset="utf-8"></script>
        <script src="//unpkg.com/valine@latest/dist/Valine.min.js" charset="utf-8"></script>
        <script>
            var notify = 'false' == true ? true : false;
            var verify = 'false' == true ? true : false;
            var GUEST_INFO = ['nick','mail','link'];
            var guest_info = 'nick,mail,link'.split(',').filter(function(item){
                return GUEST_INFO.indexOf(item) > -1;
            });

            guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
            window.valine = new Valine({
                el:'#vcomment',
                notify:notify,
                verify:verify,
                appId:'rwwVeUe3kpfbc0OkoxmgnTKM-gzGzoHsz',
                appKey:'FcDDW6bpbs5QmH3A1B2Aqmae',
                placeholder:'Just so so',
                avatar:'mm',
                guest_info:guest_info,
                pageSize:'10'
            });
        </script>
    



    </body>
</html>
