
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Jelech的博客">
    <title>一种高性能的消息传递机制 - Jelech的博客</title>
    <meta name="author" content="Jelech">
    
        <meta name="keywords" content="博客,算法,HTML/CSS/JS,游戏服务器,游戏,">
    
    
        <link rel="icon" href="https://jelech.top/assets/images/favicon.ico">
        <link rel="Shortcut Icon" type="image/x-icon" href="assets/images/favicon.ico">
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Jelech","sameAs":["https://github.com/jelech","mailto"],"image":"avatar.jpg"},"articleBody":"\n\n消息协议与传输【msg_id篇】消息流程图解\n消息定义与数据类型消息定义\n消息定义+消息结构定义，能让底层传输的数据仅仅只有数据，而没有数据类型、名字、分类。两边通过消息id来区分该消息的结构，一边压缩，一边解析。极大的减少了传输的数据量。\n\n\nconst常量表\n  定义一些在之后的消息定义中会使用到的常量。比如GS的最大数量、密码的长度、角色名的长度。\n\n角色事件\n  定义玩家的一些操作事件，这里的操作包括了在服务器中流转的消息和在客户端内玩家操作需要服务器进一步处理的消息。\n\n角色使用物品事件\n\n确认取消框\n  服务器通过传送这类消息来让客户端显示某种类型的按钮显示框，客户端接收到这类消息后会自动将用户的选择结果返回给服务器。\n\n服务器与服务器之间的公共消息\n  这类的消息是最多的，一般会用是哪两种服务器之间的通信进行定义消息分类名。\n\n通用消息\n  一些事件可能是临时加的、或者是非常特殊的消息，或者是所有服务器都能使用的公用消息。这类的消息分类不明显，可以放到通用消息结构内。但是这类消息应注意不要和其他类型的消息值冲突在判定消息时可能会引起错误。\n\n各类消息结构定义\n  消息结构定义了某种消息的传递结构，比如“id=i,count=i”。其中等号左侧为类型名，用于将消息进行压缩和解压时候的分类，右侧为值的类型。比如(u)short、(u)int、(u)char、string以\\0结尾\n\n\nlua到c++传输数据转换\n\n\nlua层适用\nc++层对应\n类型定义\n\n\n\n\ni\nint\n\n\n\nI(upper i)\nunsigned int, DWORD\n\n\n\nw\nshort\n\n\n\nW\nunsigned short, WORD\n\n\n\nb\nchar\n\n\n\nB\nunsigned char, BYTE\n\n\n\nf\nfloat\n\n\n\nd\ndouble\n\n\n\ns\n*char\n不定长字符串，单个消息内只能出现一次，且必须放在末尾\n\n\nl(lower L)\nboll\n\n\n\nN\n字节流数据，在手机端使用\n\n\n\nS(upper s)\n*char with \\0\n字符串数据，末尾带有\\0, 定长\n\n\nM\n\n特殊类型， 转发消息时，使用前一个消息id的定义\n\n\n$\n复合类型\n比如table\n\n\n[len]\n数组类型\n该type类型的消息重复长度len次\n\n\n\n消息的转换过程消息注册lua层定义的消息有一个格式，列表中{msgid, base, defstring} 对应了某个msgid应该对应的解析字符串是什么。当然每个进程的c++会将对应的服务器之间的消息保存到对相应的数据内存中。python伪代码如下\n12345678910# c++存储对应表的变量 vector&lt;vector&lt;pair&lt;string, FieldValue*&gt;&gt;&gt;def register_all_common_for_process():   \tfor r_def in all_def:       \tmain_server.register_type(r_def.id, r_def.def)      # c++层进行注册class main_server():\tdef register_type(self, id, defstr):\t\tif not check_exist(id):\t\t\tadd_new_msg(id, defstr) # 对defstr字符串进行解析，保存到对应的解析字段类中\n消息转换每一个lua消息需要发送的时候，msgid是关键，每个msgid对应的数据串的结构。假设有个服务器需要发送某个msgid值的msg_table到另一个服务器。\n\n消息判断。首先判断一下当前的msgid是否存在。\n\n获取用msgid来解析msg_table，将其转换为单纯的c++数据字符串，用递归重复的判断数据。python伪代码如下：\n  1234567891011def get_msg_buffer(msgid: int, index: int, retbuffer) -&gt; int:    retlen = 0    for name, c in typedef[msgid]:        if c == 'i':            lua_get_field(L, index, name) # 通过名字获取table中的一个字段值            retbuffer += lua_toint(L,1) # 加到返回buffer中（c++中是分开为两次做）            retlen += len(int) # 更新长度        elif c == '$':            retlen += get_msg_buffer(msgid, get_new_index(index), retbuffer)        # ...\treturn retlen\n\n\n通过这样一层一层每一种数据，读取固定的数据，将其转化为固定长度。整个消息结构遍历完毕后，就能得到整个retbuffer字符串，这个字符串中存的全部是数据，没有多余的名字等字段。\n\n在上一步完成后，现在有的数据就是需要传输的数据的msg实体与这个msg的长度\n\n然后，在写到输出缓冲区时，还需要包装上msgid和连接id，一条完整的消息结构如下：\n  | 连接id(最外层) | 消息长度 | 消息id | 消息字符串(最内层) |  | ————– | ——– | —— | —————— |  | conn_id        | msg_len  | msg_id | msg                |\n\n然后就可以发送了。但是不同的地方是这里的数据没有压缩，也没有加密。那么如果有很长的数据，会进行压缩。而有的数据也需要进行加密。以下我们继续介绍这两部分。\n\n\n消息压缩数据过长也就是字符串过长，压缩的方法有很多种，压缩的效率和压缩的效果成反比，常用的有 LZ77 和 LZ4 压缩算法。现在的服务器使用的是LZ4算法中的快速版本。总而言之，这两个算法就是是字典查重复字符串，在用滑动窗口的情况下，记录位置长度。\nLZ77 压缩算法是当今最常用的无损压缩算法，是基于字典的带滑动窗口的。\nLZ77 压缩算法的原理 微软LZ77文档\n\n假设有一串字符串AABCBBABC，当前这个字符串的长度为9。假设我们读到了第二个字符A，此时程序会记录 (1,1) 代表了距离上一个字符串距离为1，字符的长度为1。而如果读到了第二个B，那么值就会是(2,1) 。\n这样做的话有个问题，对于刚刚的列子来说，串中只有3个字符，存的字典中可能就只有3个。而如果字符数很多，匹配的字符串长度不一定为1的话，这个字典就会非常大。那么匹配一个字符串是否是字典中出现的时候复杂的会异常的高。\nLZ77引入了搜索缓冲区和待检查区。搜索缓冲区代表的是字典字符串，负责的是被检查串的匹配对象。待检查缓冲区代表的是检查窗口，这个窗口当然是滑动的。这也保证了每次LZ77匹配的时候不会匹配过多的字符串导致复杂度急剧上升。\n\nLZ77 压缩算法模拟\n  假设还是刚刚举例子的字符串“AABCBBABC”，现在我们来对其进行编码。\n  一开始，窗口滑入如图位置:\n  \n  由图可见，待编码缓冲区有“AAB”三个字符，此时搜索缓冲区还是空的。所以在编码第一个字符时，由于搜索区为空，因此找不到匹配串，输出(0,0, A),。  窗口右移一个单位，如下图\n\n\n\n此时待编码区有“ABC”。开始编码。最先编码”A”，在搜索区找到”A”。由于没有超过待编码区，故开始编码”AB”，但在搜索区没有找到匹配字符串，故无法编码。因此只能编码”A”。\n输出(1, 1)。即为相对于待编码区，偏移一个单位，匹配长度为1。窗口右滑动匹配长度，即移动1个单位。如下图\n  \n  一样，没找到，输出(0, 0, B),右移1个单号，如下图\n  \n  输出（0， 0， C）,右移1个单位，如下图\n  \n  输出(2, 1),右移1个单位，如下图\n  \n  输出(3, 1)， 右移1个单位，如下图\n  \n  开始编码”A”，在搜索缓冲区查找到匹配字符串。由于待编码缓冲区没有超过，继续编码。开始编码”AB”,也搜索到。不要停止，继续编码“ABC”，找到匹配字符串。由于继续编码，则超过了窗口，故只编码“ABC”，输出(5, 3),偏移5，长度3。右移3个单位，如下图\n  \n  此时待编码缓冲区为空，停止编码。\n\n字符串的匹配算法 - KMP\n  kmp算法是字符串算法的入门算法。它能在O(n+m)时间里获得一个P模式串在S原串中出现的位置。这里大概讲一下它的原理。\n  假设有字符串BBCABCDABCDABD, 匹配串为ABCDABD。那么一开始匹配会是如下图\n  \n  如果是旧方法，那么一定会有对于每一个S串的字符，P串都一个一个的区匹配，这样的复杂度是O(n*m)的。我们从例子中引出算法。假设匹配到了如下的情况，如下图：\n  \n  此时P串的前面ABCDAB都匹配成功了，但是最后一个D匹配失败了，如果是老方法，那么整个字符串就只会向后移动一位，从P串的头开始重新匹配。\n  但是，如果我们能做到让他每次移动的距离不是1，而是更多，那么就能降低非常多的复杂度。  观察一下模式串P，其中的AB与后面的AB是相等的那么我们移动的位置同样可以是这样的：\n  \n  比较一下上面的两个图，由第一个图一直移动需要有AB存在的时候才能继续匹配，这样的情况只能在第二个图里出现，而这个AB在模式串P里是已经能判断了的，并且可以重复利用。那我们就能先处理好模式串P中的自匹配，在利用这个数组，来辅助匹配字符串S。\n  Next数组求的方式就是字符串的前缀和后缀的匹配，这里不详细讲了。可以继续在网上了解一下\n  字符串匹配算法里我们常用的还有字典树，AC自动机，后缀自动机… 等等。\n\n\nLZ4是基于LZ77的基础上修改了一些实现方法和存储表使用空间，简化了，但是变得非常的快。\nLZ4 压缩算法原理\n  LZ77算法中使用的是搜索缓冲区，实际上并没有额外开其他的空间，这个搜索缓冲区来源于源字符串的位置，被当做了字典使用。\n  而LZ4算法中的字典是用的hash表进行查询，现在的快速版本是：每4个字节进行hash表查询，每种hash值只对应一个槽。这个hash字典中key对应的是一个4字节的字符串，而value则对应的这个字符串的位置。\n\nLZ4 压缩算法图解\n  一开始字典中是空的，我们假设现在的待检查区，也就是滑动区块的大小是6。xxhash这段的结果，由于是4字节4字节进行哈希，xxhash会得到一个key值，lz4会在字典中设置这个值的value为当前的字符串的位置：\n  \n  假设CABD的hash值为1234，那么表中就会记录下当前的这个位置。\n  下一步会继续读取4个字节，同样是CABD，hash值同样是1234，此时会更新位置5，由于两个的值对应上了。此时会输出这次匹配和上次匹配之间的字符串，再输出值5，比如CABD5\n  \n\n\n消息加密Client到BCS的数据有些数据类型是需要加密传输的，比如最简单的例子：密码。但是密码加密可以用不可逆算法MD5处理，而有的数据类型需要通过解密得到其中的数据。\n密钥和公钥\n消息传输io模型unix下有以下5中io模型。\n[1] blocking IO - 阻塞IO[2] nonblocking IO - 非阻塞IO[3] IO multiplexing - IO多路复用[4] signal driven IO - 信号驱动IO[5] asynchronous IO - 异步IO“真正”的异步IO需要操作系统更强的支持。在IO多路复用模型中，事件循环将文件句柄的状态事件通知给用户线程，由用户线程自行读取数据、处理数据。而在异步IO模型中，当用户线程收到通知时，数据已经被内核读取完毕，并放在了用户线程指定的缓冲区内，内核在IO完成后通知用户线程直接使用即可。\n\n相比于IO多路复用模型，异步IO并不十分常用，不少高性能并发服务程序使用IO多路复用模型+多线程任务处理的架构基本可以满足需求。况且目前操作系统对异步IO的支持并非特别完善，更多的是采用IO多路复用模型模拟异步IO的方式（IO事件触发时不直接通知用户线程，而是将数据读写完毕后放到用户指定的缓冲区中）。Java7之后已经支持了异步IO，感兴趣的读者可以尝试使用。\n其中前面4种IO都可以归类为同步IO，而select、poll、epoll本质上也都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。\nepoll与IOCPepoll和IOCP都是作为IO复用的代表，在单线程下能进行多个IO的同时监听，相较于select/poll来说，他们复杂度更加优秀。epoll是linux独有的，而IOCP则是用在windows下的。这里我介绍以下epoll。\nepoll原理说起epoll就需要简单说一下io问题。我们在socket读取数据的时候，socket.accept()函数会一直阻塞，直到有新的数据到来，底层cpu会同时用户可以进行接收数据了。很明显，如果让进程一直等在这里阻塞，就浪费了大量的事件，况且有的服务器会连接多个服务器，那处理完一遍所有服务器的请求，时间就是服务器个数*处理时间 + 阻塞时间。这里我们假设的是在处理一个数据的时候，其他数据都到来了。\nselect解决的是在同一时间监听多个io，并且能自己设置等待时间。这样我们现在的逻辑就能变成：如果等待一定的时间后都没有数据到来，就跳出来处理其他的东西，而此时，select实际上仍然是在监听是否有数据到来。如果有数据到来，select会将这个socket，或者说是文件描述符标记为可读状态，当然一个io可读同时也可写。\n但是select有缺点第一点是他监听的io数量有上限，这个上限是1024。poll解决了这个问题。第二点poll没能解决，每次用户态需要将内核态的数据复制过来，一个一个检查当前这个io是否可以读或者写。这大大降低了select在监听大量io时候的效率。以下是select/poll/epoll在监听io数量上的性能变化：\n\nepoll的快速第一点是epoll在被内核初始化时，同时会开辟出epoll自己的内核高速cache区，用于安置每一个我们想监控的socket，这些socket会以红黑树的形式保存在内核cache里，以支持快速的查找、插入、删除。第二点是我们在调用epoll_create时，内核除了帮我们在epoll文件系统里建了个file结点，在内核cache里建了个红黑树用于存储以后epoll_ctl传来的socket外，还会再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。\nlist链表list链表中的数据是通过内核的中断来写入的。当我们执行epoll_ctl时，除了把socket放到epoll文件系统里file对象对应的红黑树上之外，还会给内核中断处理程序注册一个回调函数，告诉内核，如果这个句柄的中断到了，就把它放到准备就绪list链表里。所以，当一个socket上有数据到了，内核在把网卡上的数据copy到内核中后就来把socket插入到准备就绪链表里了。\n红黑树红黑树是一棵平衡树，但相较于AVL平衡树的完全平衡来说，红黑树的左右两端的平衡差并不一定是一。\n\n总结一下，epoll的高效是建立在一棵红黑树、一个句柄链表、以及少量内核cache上的。\n\n服务器的监听架构\n创建监听在底层，每一个进程都会创建一个epoll监听，再创建一个线程，让线程阻塞地运行epoll进行io的读取。\n\nCreate() 创建一个新的epoll。\n\n基本socket创建初始化。\n\nepoll创建初始化。\n\n端口重用，让TIME_WAIT的时间设置为立刻重用。\n\nlinger字段设置，让socket套接字在关闭时等待套接字内的数据发送完毕再关闭。\n\nso_linger字段\n  iOptValue.l_onoff\n  iOptValue.l_linger\n  setsockopt(mysock, SOL_SOCKET, SO_LINGER, (char*)&amp;iOptValue, iOptLen)\n\n设置 l_onoff为0，则该选项关闭，l_linger的值被忽略，等于内核缺省情况，close调用会立即返回给调用者，如果可能将会传输任何未发送的数据；\n\n设置 l_onoff为非0，l_linger为0，则套接口关闭时TCP夭折连接，TCP将丢弃保留在套接口发送缓冲区中的任何数据并发送一个RST给对方，而不是通常的四分组终止序列，这避免了TIME_WAIT状态；\n\n设置 l_onoff 为非0，l_linger为非0，当套接口关闭时内核将拖延一段时间（由l_linger决定）。如果套接口缓冲区中仍残留数据，进程将处于睡眠状态，直 到（a）所有数据发送完且被对方确认，之后进行正常的终止序列（描述字访问计数为0）或（b）延迟时间到。此种情况下，应用程序检查close的返回值是非常重要的，如果在数据发送完并被确认前时间到，close将返回EWOULDBLOCK错误且套接口发送缓冲区中的任何数据都丢失。close的成功返回仅告诉我们发送的数据（和FIN）已由对方TCP确认，它并不能告诉我们对方应用进程是否已读了数据。如果套接口设为非阻塞的，它将不等待close完成。\n\n\n\n不使用Nagle算法，不会将小包拼接成大包，直接将小包发送出去。\n\n\n\n\n线程运行\n创建线程来开始epoll的阻塞等操作，linux下线程创建后会立即运行。线程调用的函数中\n有epoll_wate的调用，每次获取信息判断为：\n新监听类型：初始化新的sockaddr_in等，进行accept。创建一个新的pConn客户端类，add到服务器的pEpoll监听队列中。\n读类型：调用读函数，写入缓冲区。\n实现了一个缓冲区类，进行对数据的存储。在其上进行读写操作。\n读之前会声明一个char*，并同时初始化可以存储的缓冲区大小。判断有空间存储，再开始读取。\n指针的位置来自于缓冲区类得到的空闲空间的首地址。\n\n\n如果读取的大小大于零。需要更新缓冲区类的属性。\n如果小于等于零。需要判断是否有错误信息。\n\n\n写类型：调用写函数，从缓冲区中读数据发送出去，和读类中缓冲区操作类似。\n错误类型：错误打印。退出客户端\n\n\nRelease() 判断是否已经退出。等待线程退出，关闭各种套接字、epoll。\n\n读写流\n服务器实体和EPOLL层都能作为读者和写者，缓冲区分类为读入、写出两种。m_RBuffer负责接收的数据，m_SRbuffer负责写的数据\n相当于每个服务器一般对应两类线程，一类专门处理epoll阻塞的io请求， 另一类只有一个，专注处理逻辑处理与分发\n\n读写指针图解一般情况下，程序运行的时候，在buffer中有读和写两种指针，以下是读缓冲区（也就是从外部程序到本程序的数据）：\n\n在有新的数据来的时候，epoll会在写指针的后面写东西，但此时并不会动写指针，只有当写的数据写完毕了才原子性地修改写指针的位置。这样能保证读指针读取的数据一定是写好了的。epoll读取数据的时候，会让buffer申请一个数据块进行写，如果这个数据块正在被读，那么就会重新申请一个。\n此时的写端为epoll线程，读端为逻辑处理区，要注意的是不同的服务器连接用的是不同的epoll连接对象，每个对象都会有自己的buffer区，这样保证了不同的buffer区存储的一定都是固定的两个服务器的某个方向的数据。\n以下是写缓冲区（也就是从本程序到外部程序的数据）：\n\n最开始，写出数据中有两个队列。一个buffer队列。其中写的有要发送出去的数据，另一个为请求队列，放的是要发送的客户实例指针。在发送数据的时候，就会在两个队列中取出数据，将buffer中的数据使用对应的客户端实例的epoll来发送这个数据。\n","dateCreated":"2019-09-15T19:44:47+08:00","dateModified":"2019-10-28T21:40:08+08:00","datePublished":"2019-09-15T19:44:47+08:00","description":"","headline":"一种高性能的消息传递机制","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://jelech.top/posts/2954/"},"publisher":{"@type":"Organization","name":"Jelech","sameAs":["https://github.com/jelech","mailto"],"image":"avatar.jpg","logo":{"@type":"ImageObject","url":"avatar.jpg"}},"url":"https://jelech.top/posts/2954/","keywords":"服务器, 消息传递"}</script>
    <meta name="keywords" content="服务器,消息传递">
<meta property="og:type" content="blog">
<meta property="og:title" content="一种高性能的消息传递机制">
<meta property="og:url" content="https://jelech.top/posts/2954/index.html">
<meta property="og:site_name" content="Jelech的博客">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="https://jelech.top/assets/1568866908982.png">
<meta property="og:image" content="https://jelech.top/assets/1568774174234.png">
<meta property="og:image" content="https://jelech.top/assets/1568774230675.png">
<meta property="og:image" content="https://jelech.top/assets/1568774716228-1572269822311.png">
<meta property="og:image" content="https://jelech.top/assets/1568774736504.png">
<meta property="og:image" content="https://jelech.top/assets/1568774763919.png">
<meta property="og:image" content="https://jelech.top/assets/1568774781103.png">
<meta property="og:image" content="https://jelech.top/assets/1568774829212.png">
<meta property="og:image" content="https://jelech.top/assets/1568774868492.png">
<meta property="og:image" content="https://jelech.top/assets/1568776738553.png">
<meta property="og:image" content="https://jelech.top/assets/1568776659022.png">
<meta property="og:image" content="https://jelech.top/assets/1568777386708.png">
<meta property="og:image" content="https://jelech.top/assets/1568791808150.png">
<meta property="og:image" content="https://jelech.top/assets/1568792003724.png">
<meta property="og:image" content="https://jelech.top/assets/142333511475767-1572269892400.png">
<meta property="og:image" content="https://jelech.top/assets/ioMulti4.png">
<meta property="og:image" content="https://jelech.top/assets/1568863813336.png">
<meta property="og:image" content="https://jelech.top/assets/1568859006435.png">
<meta property="og:image" content="https://jelech.top/assets/1568858972162.png">
<meta property="og:updated_time" content="2019-10-28T13:40:08.816Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一种高性能的消息传递机制">
<meta name="twitter:image" content="https://jelech.top/assets/1568866908982.png">
<meta name="twitter:creator" content="@twitter">
    
    
        
    
    
        <meta property="og:image" content="https://jelech.top/assets/images/avatar.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-du2xmrqdqrl2ollgeiw050kpl6l4nbyz7bumjuurjgsxyopifvukebxc9lqe.min.css">
    <!--STYLES END-->
    

    
    <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?fc576447bb0c014aee82fbe7d96b4401";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">Jelech的博客</a>
    </div>
    
        
            <a class="header-right-picture " href="#about">
        
        
            <img class="header-picture" src="/assets/images/avatar.jpg" alt="作者的图片">
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.jpg" alt="作者的图片">
                </a>
                <h4 class="sidebar-profile-name">Jelech</h4>
                
                    <h5 class="sidebar-profile-bio"><p>putty本无树,MinGW亦非台</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/ " title="首页">
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-categories" title="分类">
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-tags" title="标签">
                    
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-archives" title="归档">
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/game" title="游戏">
                    
                        <i class="sidebar-button-icon fas fa-gamepad" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">游戏</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="#about" title="关于">
                    
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="https://github.com/jelech" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/mailto" title="邮箱">
                    
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">邮箱</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            一种高性能的消息传递机制
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2019-09-15T19:44:47+08:00">
	
		    9月 15, 2019
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/技术探析/">技术探析</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            
            <h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#消息协议与传输【msg-id篇】"><span class="toc-text">消息协议与传输【msg_id篇】</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#消息流程图解"><span class="toc-text">消息流程图解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#消息定义与数据类型"><span class="toc-text">消息定义与数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#消息定义"><span class="toc-text">消息定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lua到c-传输数据转换"><span class="toc-text">lua到c++传输数据转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#消息的转换过程"><span class="toc-text">消息的转换过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#消息注册"><span class="toc-text">消息注册</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#消息转换"><span class="toc-text">消息转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#消息压缩"><span class="toc-text">消息压缩</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#LZ77-压缩算法是当今最常用的无损压缩算法，是基于字典的带滑动窗口的。"><span class="toc-text">LZ77 压缩算法是当今最常用的无损压缩算法，是基于字典的带滑动窗口的。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LZ4是基于LZ77的基础上修改了一些实现方法和存储表使用空间，简化了，但是变得非常的快。"><span class="toc-text">LZ4是基于LZ77的基础上修改了一些实现方法和存储表使用空间，简化了，但是变得非常的快。</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#消息加密"><span class="toc-text">消息加密</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#消息传输"><span class="toc-text">消息传输</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#io模型"><span class="toc-text">io模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-blocking-IO-阻塞IO"><span class="toc-text">[1] blocking IO - 阻塞IO</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-nonblocking-IO-非阻塞IO"><span class="toc-text">[2] nonblocking IO - 非阻塞IO</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-IO-multiplexing-IO多路复用"><span class="toc-text">[3] IO multiplexing - IO多路复用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-signal-driven-IO-信号驱动IO"><span class="toc-text">[4] signal driven IO - 信号驱动IO</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-asynchronous-IO-异步IO"><span class="toc-text">[5] asynchronous IO - 异步IO</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll与IOCP"><span class="toc-text">epoll与IOCP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll原理"><span class="toc-text">epoll原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#epoll的快速"><span class="toc-text">epoll的快速</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#list链表"><span class="toc-text">list链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#红黑树"><span class="toc-text">红黑树</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#服务器的监听架构"><span class="toc-text">服务器的监听架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建监听"><span class="toc-text">创建监听</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程运行"><span class="toc-text">线程运行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#读写流"><span class="toc-text">读写流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#读写指针图解"><span class="toc-text">读写指针图解</span></a></li></ol></li></ol></li></ol>
<a id="more"></a>
<h1 id="消息协议与传输【msg-id篇】"><a href="#消息协议与传输【msg-id篇】" class="headerlink" title="消息协议与传输【msg_id篇】"></a>消息协议与传输【msg_id篇】</h1><h2 id="消息流程图解"><a href="#消息流程图解" class="headerlink" title="消息流程图解"></a>消息流程图解</h2><p><img src="../../assets/1568866908982.png" alt="1568866908982"></p>
<h2 id="消息定义与数据类型"><a href="#消息定义与数据类型" class="headerlink" title="消息定义与数据类型"></a>消息定义与数据类型</h2><h3 id="消息定义"><a href="#消息定义" class="headerlink" title="消息定义"></a>消息定义</h3><blockquote>
<p><strong>消息</strong>定义+<strong>消息结构</strong>定义，能让底层传输的数据仅仅只有数据，而没有数据类型、名字、分类。两边通过消息id来区分该消息的结构，一边压缩，一边解析。极大的减少了传输的数据量。</p>
</blockquote>
<ul>
<li><p>const常量表</p>
<p>  定义一些在之后的消息定义中会使用到的常量。比如GS的最大数量、密码的长度、角色名的长度。</p>
</li>
<li><p>角色事件</p>
<p>  定义玩家的一些操作事件，这里的操作包括了在服务器中流转的消息和在客户端内玩家操作需要服务器进一步处理的消息。</p>
</li>
<li><p>角色使用物品事件</p>
</li>
<li><p>确认取消框</p>
<p>  服务器通过传送这类消息来让客户端显示某种类型的按钮显示框，客户端接收到这类消息后会自动将用户的选择结果返回给服务器。</p>
</li>
<li><p>服务器与服务器之间的公共消息</p>
<p>  这类的消息是最多的，一般会用是哪两种服务器之间的通信进行定义消息分类名。</p>
</li>
<li><p>通用消息</p>
<p>  一些事件可能是临时加的、或者是非常特殊的消息，或者是所有服务器都能使用的公用消息。这类的消息分类不明显，可以放到通用消息结构内。但是这类消息应注意不要和其他类型的消息<strong>值冲突</strong>在判定消息时可能会引起错误。</p>
</li>
<li><p>各类消息结构定义</p>
<p>  消息结构定义了某种消息的传递结构，比如“id=i,count=i”。其中等号左侧为类型名，用于将消息进行压缩和解压时候的分类，右侧为值的类型。比如(u)short、(u)int、(u)char、string以\0结尾</p>
</li>
</ul>
<h3 id="lua到c-传输数据转换"><a href="#lua到c-传输数据转换" class="headerlink" title="lua到c++传输数据转换"></a>lua到c++传输数据转换</h3><table>
<thead>
<tr>
<th>lua层适用</th>
<th>c++层对应</th>
<th>类型定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td>int</td>
<td></td>
</tr>
<tr>
<td>I(upper i)</td>
<td>unsigned int, DWORD</td>
<td></td>
</tr>
<tr>
<td>w</td>
<td>short</td>
<td></td>
</tr>
<tr>
<td>W</td>
<td>unsigned short, WORD</td>
<td></td>
</tr>
<tr>
<td>b</td>
<td>char</td>
<td></td>
</tr>
<tr>
<td>B</td>
<td>unsigned char, BYTE</td>
<td></td>
</tr>
<tr>
<td>f</td>
<td>float</td>
<td></td>
</tr>
<tr>
<td>d</td>
<td>double</td>
<td></td>
</tr>
<tr>
<td>s</td>
<td>*char</td>
<td>不定长字符串，单个消息内只能出现一次，且必须放在末尾</td>
</tr>
<tr>
<td>l(lower L)</td>
<td>boll</td>
<td></td>
</tr>
<tr>
<td>N</td>
<td>字节流数据，在手机端使用</td>
<td></td>
</tr>
<tr>
<td>S(upper s)</td>
<td>*char with \0</td>
<td>字符串数据，末尾带有\0, 定长</td>
</tr>
<tr>
<td>M</td>
<td></td>
<td>特殊类型， 转发消息时，使用前一个消息id的定义</td>
</tr>
<tr>
<td>$<typeid></typeid></td>
<td>复合类型</td>
<td>比如table</td>
</tr>
<tr>
<td><type>[len]</type></td>
<td>数组类型</td>
<td>该type类型的消息重复长度len次</td>
</tr>
</tbody>
</table>
<h3 id="消息的转换过程"><a href="#消息的转换过程" class="headerlink" title="消息的转换过程"></a>消息的转换过程</h3><h4 id="消息注册"><a href="#消息注册" class="headerlink" title="消息注册"></a>消息注册</h4><p>lua层定义的消息有一个格式，列表中{msgid, base, defstring} 对应了某个msgid应该对应的解析字符串是什么。当然每个进程的c++会将对应的服务器之间的消息保存到对相应的数据内存中。python伪代码如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># c++存储对应表的变量 vector&lt;vector&lt;pair&lt;string, FieldValue*&gt;&gt;&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register_all_common_for_process</span><span class="params">()</span>:</span></span><br><span class="line">   	<span class="keyword">for</span> r_def <span class="keyword">in</span> all_def:</span><br><span class="line">       	main_server.register_type(r_def.id, r_def.<span class="keyword">def</span>)</span><br><span class="line">   </span><br><span class="line">   <span class="comment"># c++层进行注册</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">main_server</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">register_type</span><span class="params">(self, id, defstr)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> check_exist(id):</span><br><span class="line">			add_new_msg(id, defstr) <span class="comment"># 对defstr字符串进行解析，保存到对应的解析字段类中</span></span><br></pre></td></tr></table></figure>
<h4 id="消息转换"><a href="#消息转换" class="headerlink" title="消息转换"></a>消息转换</h4><p>每一个lua消息需要发送的时候，msgid是关键，每个msgid对应的数据串的结构。假设有个服务器需要发送某个msgid值的msg_table到另一个服务器。</p>
<ul>
<li><p>消息判断。首先判断一下当前的msgid是否存在。</p>
</li>
<li><p>获取用msgid来解析msg_table，将其转换为单纯的c++数据字符串，用递归重复的判断数据。python伪代码如下：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_msg_buffer</span><span class="params">(msgid: int, index: int, retbuffer)</span> -&gt; int:</span></span><br><span class="line">    retlen = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> name, c <span class="keyword">in</span> typedef[msgid]:</span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">'i'</span>:</span><br><span class="line">            lua_get_field(L, index, name) <span class="comment"># 通过名字获取table中的一个字段值</span></span><br><span class="line">            retbuffer += lua_toint(L,<span class="number">1</span>) <span class="comment"># 加到返回buffer中（c++中是分开为两次做）</span></span><br><span class="line">            retlen += len(int) <span class="comment"># 更新长度</span></span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">'$'</span>:</span><br><span class="line">            retlen += get_msg_buffer(msgid, get_new_index(index), retbuffer)</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">	<span class="keyword">return</span> retlen</span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>通过这样一层一层每一种数据，读取固定的数据，将其转化为固定长度。整个消息结构遍历完毕后，就能得到整个retbuffer字符串，这个字符串中存的全部是数据，没有多余的名字等字段。
</code></pre><ul>
<li><p>在上一步完成后，现在有的数据就是需要传输的数据的msg实体与这个msg的长度</p>
</li>
<li><p>然后，在写到输出缓冲区时，还需要包装上msgid和连接id，一条完整的消息结构如下：</p>
<p>  | 连接id(最外层) | 消息长度 | 消息id | 消息字符串(最内层) |<br>  | ————– | ——– | —— | —————— |<br>  | conn_id        | msg_len  | msg_id | msg                |</p>
</li>
<li><p>然后就可以发送了。但是不同的地方是这里的数据没有压缩，也没有加密。那么如果有很长的数据，会进行压缩。而有的数据也需要进行加密。以下我们继续介绍这两部分。</p>
</li>
</ul>
<h4 id="消息压缩"><a href="#消息压缩" class="headerlink" title="消息压缩"></a>消息压缩</h4><p>数据过长也就是字符串过长，压缩的方法有很多种，压缩的效率和压缩的效果成反比，常用的有 <a href="http://en.wikipedia.org/wiki/LZ77_and_LZ78" target="_blank" rel="noopener">LZ77</a> 和 <a href="https://github.com/lz4/lz4" target="_blank" rel="noopener">LZ4</a> 压缩算法。现在的服务器使用的是LZ4算法中的快速版本。总而言之，这两个算法就是是字典查重复字符串，在用滑动窗口的情况下，记录位置长度。</p>
<h5 id="LZ77-压缩算法是当今最常用的无损压缩算法，是基于字典的带滑动窗口的。"><a href="#LZ77-压缩算法是当今最常用的无损压缩算法，是基于字典的带滑动窗口的。" class="headerlink" title="LZ77 压缩算法是当今最常用的无损压缩算法，是基于字典的带滑动窗口的。"></a>LZ77 压缩算法是当今最常用的无损压缩算法，是基于字典的带滑动窗口的。</h5><ul>
<li>LZ77 压缩算法的原理 <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-wusp/fb98aa28-5cd7-407f-8869-a6cef1ff1ccb?redirectedfrom=MSDN" target="_blank" rel="noopener">微软LZ77文档</a></li>
</ul>
<p>假设有一串字符串AABCBBABC，当前这个字符串的长度为9。假设我们读到了第二个字符A，此时程序会记录 <code>(1,1)</code> 代表了距离上一个字符串距离为1，字符的长度为1。而如果读到了第二个B，那么值就会是<code>(2,1)</code> 。</p>
<p>这样做的话有个问题，对于刚刚的列子来说，串中只有3个字符，存的字典中可能就只有3个。而如果字符数很多，匹配的字符串长度不一定为1的话，这个字典就会非常大。那么匹配一个字符串是否是字典中出现的时候复杂的会异常的高。</p>
<p>LZ77引入了搜索缓冲区和待检查区。搜索缓冲区代表的是字典字符串，负责的是被检查串的匹配对象。待检查缓冲区代表的是检查窗口，这个窗口当然是滑动的。这也保证了每次LZ77匹配的时候不会匹配过多的字符串导致复杂度急剧上升。</p>
<ul>
<li><p>LZ77 压缩算法模拟</p>
<p>  假设还是刚刚举例子的字符串“AABCBBABC”，现在我们来对其进行编码。</p>
<p>  一开始，窗口滑入如图位置:</p>
<p>  <img src="../../assets/1568774174234.png" alt="1568774174234"></p>
<p>  由图可见，待编码缓冲区有“AAB”三个字符，此时搜索缓冲区还是空的。所以在编码第一个字符时，由于搜索区为空，因此找不到匹配串，输出(0,0, A),。<br>  窗口右移一个单位，如下图</p>
</li>
</ul>
<p><img src="../../assets/1568774230675.png" alt="1568774230675"></p>
<p>此时待编码区有“ABC”。开始编码。最先编码”A”，在搜索区找到”A”。由于没有超过待编码区，故开始编码”AB”，但在搜索区没有找到匹配字符串，故无法编码。因此只能编码”A”。</p>
<p>输出(1, 1)。即为相对于待编码区，偏移一个单位，匹配长度为1。窗口右滑动匹配长度，即移动1个单位。如下图</p>
<p>  <img src="../../assets/1568774716228-1572269822311.png" alt="1568774716228"></p>
<p>  一样，没找到，输出(0, 0, B),右移1个单号，如下图</p>
<p>  <img src="../../assets/1568774736504.png" alt="1568774736504"></p>
<p>  输出（0， 0， C）,右移1个单位，如下图</p>
<p>  <img src="../../assets/1568774763919.png" alt="1568774763919"></p>
<p>  输出(2, 1),右移1个单位，如下图</p>
<p>  <img src="../../assets/1568774781103.png" alt="1568774781103"></p>
<p>  输出(3, 1)， 右移1个单位，如下图</p>
<p>  <img src="../../assets/1568774829212.png" alt="1568774829212"></p>
<p>  开始编码”A”，在搜索缓冲区查找到匹配字符串。由于待编码缓冲区没有超过，继续编码。开始编码”AB”,也搜索到。不要停止，继续编码“ABC”，找到匹配字符串。由于继续编码，则超过了窗口，故只编码“ABC”，输出(5, 3),偏移5，长度3。右移3个单位，如下图</p>
<p>  <img src="../../assets/1568774868492.png" alt="1568774868492"></p>
<p>  此时待编码缓冲区为空，停止编码。</p>
<ul>
<li><p>字符串的匹配算法 - KMP</p>
<p>  kmp算法是字符串算法的入门算法。它能在O(n+m)时间里获得一个P模式串在S原串中出现的位置。这里大概讲一下它的原理。</p>
<p>  假设有字符串BBCABCDABCDABD, 匹配串为ABCDABD。那么一开始匹配会是如下图</p>
<p>  <img src="../../assets/1568776738553.png" alt="1568776738553"></p>
<p>  如果是旧方法，那么一定会有对于每一个S串的字符，P串都一个一个的区匹配，这样的复杂度是O(n*m)的。我们从例子中引出算法。假设匹配到了如下的情况，如下图：</p>
<p>  <img src="../../assets/1568776659022.png" alt="1568776659022"></p>
<p>  此时P串的前面ABCDAB都匹配成功了，但是最后一个D匹配失败了，如果是老方法，那么整个字符串就只会向后移动一位，从P串的头开始重新匹配。</p>
<p>  <strong>但是</strong>，如果我们能做到让他每次移动的距离不是1，而是更多，那么就能降低非常多的复杂度。<br>  观察一下模式串P，其中的AB与后面的AB是相等的那么我们移动的位置同样可以是这样的：</p>
<p>  <img src="../../assets/1568777386708.png" alt="1568777386708"></p>
<p>  比较一下上面的两个图，由第一个图一直移动需要有AB存在的时候才能继续匹配，这样的情况只能在第二个图里出现，而这个AB在模式串P里是已经能判断了的，并且可以重复利用。那我们就能先处理好模式串P中的自匹配，在利用这个数组，来辅助匹配字符串S。</p>
<p>  Next数组求的方式就是字符串的前缀和后缀的匹配，这里不详细讲了。<a href="https://blog.csdn.net/starstar1992/article/details/54913261" target="_blank" rel="noopener">可以继续在网上了解一下</a></p>
<p>  字符串匹配算法里我们常用的还有<strong>字典树，AC自动机，后缀自动机…</strong> 等等。</p>
</li>
</ul>
<h5 id="LZ4是基于LZ77的基础上修改了一些实现方法和存储表使用空间，简化了，但是变得非常的快。"><a href="#LZ4是基于LZ77的基础上修改了一些实现方法和存储表使用空间，简化了，但是变得非常的快。" class="headerlink" title="LZ4是基于LZ77的基础上修改了一些实现方法和存储表使用空间，简化了，但是变得非常的快。"></a>LZ4是基于LZ77的基础上修改了一些实现方法和存储表使用空间，简化了，但是变得非常的快。</h5><ul>
<li><p>LZ4 压缩算法原理</p>
<p>  LZ77算法中使用的是搜索缓冲区，实际上并没有额外开其他的空间，这个搜索缓冲区来源于源字符串的位置，被当做了字典使用。</p>
<p>  而LZ4算法中的字典是用的hash表进行查询，现在的快速版本是：每4个字节进行hash表查询，每种hash值只对应一个槽。这个hash字典中key对应的是一个4字节的字符串，而value则对应的这个字符串的位置。</p>
</li>
<li><p>LZ4 压缩算法图解</p>
<p>  一开始字典中是空的，我们假设现在的待检查区，也就是滑动区块的大小是6。xxhash这段的结果，由于是4字节4字节进行哈希，xxhash会得到一个key值，lz4会在字典中设置这个值的value为当前的字符串的位置：</p>
<p>  <img src="../../assets/1568791808150.png" alt="1568791808150"></p>
<p>  假设CABD的hash值为1234，那么表中就会记录下当前的这个位置。</p>
<p>  下一步会继续读取4个字节，同样是CABD，hash值同样是1234，此时会更新位置5，由于两个的值对应上了。此时会输出这次匹配和上次匹配之间的字符串，再输出值5，比如CABD5</p>
<p>  <img src="../../assets/1568792003724.png" alt="1568792003724"></p>
</li>
</ul>
<h4 id="消息加密"><a href="#消息加密" class="headerlink" title="消息加密"></a>消息加密</h4><p>Client到BCS的数据有些数据类型是需要加密传输的，比如最简单的例子：密码。但是密码加密可以用不可逆算法MD5处理，而有的数据类型需要通过解密得到其中的数据。</p>
<p>密钥和公钥</p>
<h2 id="消息传输"><a href="#消息传输" class="headerlink" title="消息传输"></a>消息传输</h2><h3 id="io模型"><a href="#io模型" class="headerlink" title="io模型"></a>io模型</h3><p>unix下有以下5中io模型。</p>
<h5 id="1-blocking-IO-阻塞IO"><a href="#1-blocking-IO-阻塞IO" class="headerlink" title="[1] blocking IO - 阻塞IO"></a>[1] blocking IO - 阻塞IO</h5><h5 id="2-nonblocking-IO-非阻塞IO"><a href="#2-nonblocking-IO-非阻塞IO" class="headerlink" title="[2] nonblocking IO - 非阻塞IO"></a>[2] nonblocking IO - 非阻塞IO</h5><h5 id="3-IO-multiplexing-IO多路复用"><a href="#3-IO-multiplexing-IO多路复用" class="headerlink" title="[3] IO multiplexing - IO多路复用"></a>[3] IO multiplexing - IO多路复用</h5><h5 id="4-signal-driven-IO-信号驱动IO"><a href="#4-signal-driven-IO-信号驱动IO" class="headerlink" title="[4] signal driven IO - 信号驱动IO"></a>[4] signal driven IO - 信号驱动IO</h5><h5 id="5-asynchronous-IO-异步IO"><a href="#5-asynchronous-IO-异步IO" class="headerlink" title="[5] asynchronous IO - 异步IO"></a>[5] asynchronous IO - 异步IO</h5><p>“真正”的异步IO需要操作系统更强的支持。在IO多路复用模型中，事件循环将文件句柄的状态事件通知给用户线程，由用户线程自行读取数据、处理数据。而在异步IO模型中，当用户线程收到通知时，数据已经被内核读取完毕，并放在了用户线程指定的缓冲区内，内核在IO完成后通知用户线程直接使用即可。</p>
<p><img src="../../assets/142333511475767-1572269892400.png" alt="142333511475767"></p>
<p>相比于IO多路复用模型，异步IO并不十分常用，不少高性能并发服务程序使用IO多路复用模型+多线程任务处理的架构基本可以满足需求。况且目前操作系统对异步IO的支持并非特别完善，更多的是采用IO多路复用模型模拟异步IO的方式（IO事件触发时不直接通知用户线程，而是将数据读写完毕后放到用户指定的缓冲区中）。Java7之后已经支持了异步IO，感兴趣的读者可以尝试使用。</p>
<p>其中前面4种IO都可以归类为同步IO，而select、poll、epoll本质上也都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。</p>
<h3 id="epoll与IOCP"><a href="#epoll与IOCP" class="headerlink" title="epoll与IOCP"></a>epoll与IOCP</h3><p>epoll和IOCP都是作为IO复用的代表，在单线程下能进行多个IO的同时监听，相较于select/poll来说，他们复杂度更加优秀。epoll是linux独有的，而IOCP则是用在windows下的。这里我介绍以下epoll。</p>
<h4 id="epoll原理"><a href="#epoll原理" class="headerlink" title="epoll原理"></a>epoll原理</h4><p>说起epoll就需要简单说一下io问题。我们在socket读取数据的时候，<code>socket.accept()</code>函数会一直阻塞，直到有新的数据到来，底层cpu会同时用户可以进行接收数据了。很明显，如果让进程一直等在这里阻塞，就浪费了大量的事件，况且有的服务器会连接多个服务器，那处理完一遍所有服务器的请求，时间就是<code>服务器个数*处理时间 + 阻塞时间</code>。这里我们假设的是在处理一个数据的时候，其他数据都到来了。</p>
<p>select解决的是在同一时间监听多个io，并且能自己设置等待时间。这样我们现在的逻辑就能变成：如果等待一定的时间后都没有数据到来，就跳出来处理其他的东西，而此时，select实际上仍然是在监听是否有数据到来。如果有数据到来，select会将这个socket，或者说是文件描述符标记为可读状态，当然一个io可读同时也可写。</p>
<p><strong>但是select有缺点</strong><br>第一点是他监听的io数量有上限，这个上限是1024。poll解决了这个问题。<br>第二点poll没能解决，每次用户态需要将内核态的数据复制过来，一个一个检查当前这个io是否可以读或者写。这大大降低了select在监听大量io时候的效率。以下是select/poll/epoll在监听io数量上的性能变化：</p>
<p><img src="../../assets/ioMulti4.png" alt="ioMulti4"></p>
<h5 id="epoll的快速"><a href="#epoll的快速" class="headerlink" title="epoll的快速"></a>epoll的快速</h5><p>第一点是epoll在被内核初始化时，同时会开辟出epoll自己的内核高速cache区，用于安置每一个我们想监控的socket，这些socket会以红黑树的形式保存在内核cache里，以支持快速的查找、插入、删除。<br>第二点是我们在调用epoll_create时，内核除了帮我们在epoll文件系统里建了个file结点，在内核cache里建了个红黑树用于存储以后epoll_ctl传来的socket外，还会再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。</p>
<h5 id="list链表"><a href="#list链表" class="headerlink" title="list链表"></a>list链表</h5><p>list链表中的数据是通过内核的中断来写入的。当我们执行epoll_ctl时，除了把socket放到epoll文件系统里file对象对应的红黑树上之外，还会给内核中断处理程序注册一个回调函数，告诉内核，如果这个句柄的中断到了，就把它放到准备就绪list链表里。所以，当一个socket上有数据到了，内核在把网卡上的数据copy到内核中后就来把socket插入到准备就绪链表里了。</p>
<h5 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h5><p>红黑树是一棵平衡树，但相较于AVL平衡树的完全平衡来说，红黑树的左右两端的平衡差并不一定是一。</p>
<blockquote>
<p>总结一下，epoll的高效是建立在一棵红黑树、一个句柄链表、以及少量内核cache上的。</p>
</blockquote>
<h4 id="服务器的监听架构"><a href="#服务器的监听架构" class="headerlink" title="服务器的监听架构"></a>服务器的监听架构</h4><p><img src="../../assets/1568863813336.png" alt="1568863813336"></p>
<h4 id="创建监听"><a href="#创建监听" class="headerlink" title="创建监听"></a>创建监听</h4><p>在底层，每一个进程都会创建一个epoll监听，再创建一个线程，让线程阻塞地运行epoll进行io的读取。</p>
<ul>
<li><p><code>Create()</code> 创建一个新的epoll。</p>
<ul>
<li><p>基本socket创建初始化。</p>
</li>
<li><p>epoll创建初始化。</p>
</li>
<li><p>端口重用，让TIME_WAIT的时间设置为立刻重用。</p>
</li>
<li><p>linger字段设置，让socket套接字在关闭时等待套接字内的数据发送完毕再关闭。</p>
<ul>
<li><p>so_linger字段</p>
<p>  <code>iOptValue.l_onoff</code></p>
<p>  <code>iOptValue.l_linger</code></p>
<p>  <code>setsockopt(mysock, SOL_SOCKET, SO_LINGER, (char*)&amp;iOptValue, iOptLen)</code></p>
</li>
<li><p>设置 l_onoff为0，则该选项关闭，l_linger的值被忽略，等于内核缺省情况，close调用会立即返回给调用者，如果可能将会传输任何未发送的数据；</p>
</li>
<li><p>设置 l_onoff为非0，l_linger为0，则套接口关闭时TCP夭折连接，TCP将丢弃保留在套接口发送缓冲区中的任何数据并发送一个RST给对方，而不是通常的四分组终止序列，这避免了TIME_WAIT状态；</p>
</li>
<li><p>设置 l_onoff 为非0，l_linger为非0，当套接口关闭时内核将拖延一段时间（由l_linger决定）。如果套接口缓冲区中仍残留数据，进程将处于睡眠状态，直 到（a）所有数据发送完且被对方确认，之后进行正常的终止序列（描述字访问计数为0）或（b）延迟时间到。此种情况下，应用程序检查close的返回值是非常重要的，如果在数据发送完并被确认前时间到，close将返回EWOULDBLOCK错误且套接口发送缓冲区中的任何数据都丢失。close的成功返回仅告诉我们发送的数据（和FIN）已由对方TCP确认，它并不能告诉我们对方应用进程是否已读了数据。如果套接口设为非阻塞的，它将不等待close完成。</p>
</li>
</ul>
</li>
<li><p>不使用Nagle算法，不会将小包拼接成大包，直接将小包发送出去。</p>
</li>
</ul>
</li>
</ul>
<h4 id="线程运行"><a href="#线程运行" class="headerlink" title="线程运行"></a>线程运行</h4><ul>
<li>创建线程来开始epoll的阻塞等操作，linux下线程创建后会立即运行。线程调用的函数中<ul>
<li>有epoll_wate的调用，每次获取信息判断为：</li>
<li>新监听类型：初始化新的sockaddr_in等，进行accept。创建一个新的pConn客户端类，add到服务器的pEpoll监听队列中。</li>
<li>读类型：调用读函数，写入缓冲区。<ul>
<li>实现了一个缓冲区类，进行对数据的存储。在其上进行读写操作。<ul>
<li>读之前会声明一个char*，并同时初始化可以存储的缓冲区大小。判断有空间存储，再开始读取。</li>
<li>指针的位置来自于缓冲区类得到的空闲空间的首地址。</li>
</ul>
</li>
<li>如果读取的大小大于零。需要更新缓冲区类的属性。</li>
<li>如果小于等于零。需要判断是否有错误信息。</li>
</ul>
</li>
<li>写类型：调用写函数，从缓冲区中读数据发送出去，和读类中缓冲区操作类似。</li>
<li>错误类型：错误打印。退出客户端</li>
</ul>
</li>
<li><code>Release()</code> 判断是否已经退出。等待线程退出，关闭各种套接字、epoll。</li>
</ul>
<h3 id="读写流"><a href="#读写流" class="headerlink" title="读写流"></a>读写流</h3><blockquote>
<p>服务器实体和EPOLL层都能作为读者和写者，缓冲区分类为读入、写出两种。m_RBuffer负责接收的数据，m_SRbuffer负责写的数据</p>
<p><strong>相当于每个服务器一般对应两类线程，一类专门处理epoll阻塞的io请求， 另一类只有一个，专注处理逻辑处理与分发</strong></p>
</blockquote>
<h4 id="读写指针图解"><a href="#读写指针图解" class="headerlink" title="读写指针图解"></a>读写指针图解</h4><p>一般情况下，程序运行的时候，在buffer中有读和写两种指针，以下是<strong>读缓冲区</strong>（也就是从外部程序到本程序的数据）：</p>
<p><img src="../../assets/1568859006435.png" alt="1568859006435"></p>
<p>在有新的数据来的时候，epoll会在写指针的后面写东西，但此时并不会动写指针，只有当写的数据写完毕了才原子性地修改写指针的位置。这样能保证读指针读取的数据一定是写好了的。<br>epoll读取数据的时候，会让buffer申请一个数据块进行写，如果这个数据块正在被读，那么就会重新申请一个。</p>
<p>此时的写端为epoll线程，读端为逻辑处理区，要注意的是不同的服务器连接用的是不同的epoll连接对象，每个对象都会有自己的buffer区，这样保证了不同的buffer区存储的一定都是固定的两个服务器的某个方向的数据。</p>
<p>以下是<strong>写缓冲区</strong>（也就是从本程序到外部程序的数据）：</p>
<p><img src="../../assets/1568858972162.png" alt="1568858972162"></p>
<p>最开始，写出数据中有两个队列。一个buffer队列。其中写的有要发送出去的数据，另一个为请求队列，放的是要发送的客户实例指针。在发送数据的时候，就会在两个队列中取出数据，将buffer中的数据使用对应的客户端实例的epoll来发送这个数据。</p>

            

        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">标签</span><br>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/服务器/">服务器</a> <a class="tag tag--primary tag--small t-link" href="/tags/消息传递/">消息传递</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/posts/41312/" data-tooltip="一起学GO(一)" aria-label="上一篇: 一起学GO(一)">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/posts/34317/" data-tooltip="linux基础篇【转】" aria-label="下一篇: linux基础篇【转】">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="分享">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://jelech.top/posts/2954/" title="分享到 Facebook">
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=https://jelech.top/posts/2954/" title="分享到 Twitter">
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=https://jelech.top/posts/2954/" title="分享到 Google+">
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
                <style media="screen">.v .vwrap{overflow: inherit;}</style>
                <div id="vcomment"></div>
                <a href="posts/2954/#vcomment" class="disqus-comment-count"></a>
                <span class="valine-comment-count" data-xid="posts/2954/"></span>
                <span> Comment</span>
            
        
    </div>
</article>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 Jelech. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/posts/41312/" data-tooltip="一起学GO(一)" aria-label="上一篇: 一起学GO(一)">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/posts/34317/" data-tooltip="linux基础篇【转】" aria-label="下一篇: linux基础篇【转】">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="分享">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://jelech.top/posts/2954/" title="分享到 Facebook">
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=https://jelech.top/posts/2954/" title="分享到 Twitter">
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=https://jelech.top/posts/2954/" title="分享到 Google+">
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                <div id="share-options-bar" class="share-options-bar" data-behavior="4">
    <i id="btn-close-shareoptions" class="fa fa-times"></i>
    <ul class="share-options">
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://jelech.top/posts/2954/">
                    <i class="fab fa-facebook" aria-hidden="true"></i><span>分享到 Facebook</span>
                </a>
            </li>
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=https://jelech.top/posts/2954/">
                    <i class="fab fa-twitter" aria-hidden="true"></i><span>分享到 Twitter</span>
                </a>
            </li>
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="https://plus.google.com/share?url=https://jelech.top/posts/2954/">
                    <i class="fab fa-google-plus" aria-hidden="true"></i><span>分享到 Google+</span>
                </a>
            </li>
        
    </ul>
</div>

            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.jpg" alt="作者的图片">
        
            <h4 id="about-card-name">Jelech</h4>
        
            <div id="about-card-bio"><p>putty本无树,MinGW亦非台</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br>
                <p>在校大学生一枚</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br>
                CHINA.HRB.STU
            </div>
        

        
            <div id="about-card-job">
                <i class="fa fa-envelope"></i>
                <br>
                jelech@hotmail.com
            </div>
        

        
            <div id="about-card-job">
                <i class="fa fa-phone-square"></i>
                <br>
                18.......6
            </div>
        


    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-vufjrm3fmbuttogo1hxuu0w9w0sesk5iyysjuguc2hdhufot9szxg8twijry.min.js"></script>
<!--SCRIPTS END-->

    
        
        <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js" charset="utf-8"></script>
        <script src="//unpkg.com/valine@latest/dist/Valine.min.js" charset="utf-8"></script>
        <script>
            var notify = 'false' == true ? true : false;
            var verify = 'false' == true ? true : false;
            var GUEST_INFO = ['nick','mail','link'];
            var guest_info = 'nick,mail,link'.split(',').filter(function(item){
                return GUEST_INFO.indexOf(item) > -1;
            });

            guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
            window.valine = new Valine({
                el:'#vcomment',
                notify:notify,
                verify:verify,
                appId:'rwwVeUe3kpfbc0OkoxmgnTKM-gzGzoHsz',
                appKey:'FcDDW6bpbs5QmH3A1B2Aqmae',
                placeholder:'Just so so',
                avatar:'mm',
                guest_info:guest_info,
                pageSize:'10'
            });
        </script>
    



    </body>
</html>
