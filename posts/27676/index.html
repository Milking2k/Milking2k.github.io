
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Jelech的博客">
    <title>操作系统中的算法 - Jelech的博客</title>
    <meta name="author" content="Jelech">
    
        <meta name="keywords" content="博客,算法,javascript,游戏,">
    
    
        <link rel="icon" href="http://www.jelech.cn/assets/images/favicon.ico">
        <link rel="Shortcut Icon" type="image/x-icon" href="assets/images/favicon.ico">
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Jelech","sameAs":["https://github.com/jelech","mailto"],"image":"avatar.jpg"},"articleBody":"\n文章还在更新中…\n\n\n\n算法一：RR时间片轮转\n百度百科：时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。如果在时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。调度程序所要做的就是维护一张就绪进程列表，当进程用完它的时间片后，它被移到队列的末尾。\n\n时间片轮转，从字面上理解就是会有个时间片定义，让每个进程都轮转，直到进程结束。当新程序向OS提出要运行的时候，OS会给他分配适合的PCB头，成为进程的程序会先进入就绪队列，也就是排在队列的队尾。新的一轮开始的时候，OS会给队首一个时间片长度，表示这个进程可以最多运行这么长的时间。\n\n若当时间片用完，进程会进入就绪队列的队尾，如此循环，直到进程清空就绪队列。\n\n\n若进程结束，进程会进入伪退出状态，数据会写入虚拟内存(外存)。而此时会剩余一些时间片的时间，OS可以选择将它继续分配给下一个进程，减少不必要的等待。\n若进程应一些I/O请求等因素，OS也会中断进程，让其进入阻塞队列。只有请求结束后，才会让他重新进入就绪队列。\n\n后来，又更新了一些方法对它进行改良。\n带有优先级的时间片轮转法因为在操作系统中，一些进程是比其他进程更需要提前完成的，因此在不同的进程里有不同的优先级。这里的优先级是静态的，意思是在进程进来前，OS以及对他进行了分析，得出了它相对于其他的进程的优先级高低。在新进程进入的时候，有可能是更高的优先级，让这个进程更有限的享用CPU，这里又分为了 &lt;基时钟中断：等待当前进程时间片结束&gt; &lt;立即抢占：等待当前进程出了临界区后立即中断进程&gt; 两种方式对现有的进程进行替换。\n反馈调度法这个算法是进程在调度时候的算法，普通的RR最初来自于页面置换算法中。反馈调度中提倡的是对进程已运行一部分和从未运行进行区分比较，也就是说，对于已经在队列中运行，较多次时间片的进程，优先级低于较少次时间片的进程。因此在实现的时候，反馈调度算法使用了n个队列，而一般在设置的时候不同的队列的时间片也是不一样的。实现方面和RR类似，但是当有两个进程的时候，一个进程在这个队列运行完毕，会因为下一个进程的抢占，导致其进入了优先级更低的队列中。其他部分和RR算法类似，直到所有进程运行完毕。其中，当有新的进程进入的时候，是插入到优先级最高的队列后面，按同样的方式，向下传播。\n\nRR算法源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195/*=================================================================OS algorithm of Time slice rotation2018.5.15   jelech      start writing2018.5.20   jelech      modify the algorithm2018.5.31   jelech      modify the PCB2018.6.5    jelech      modify the format=================================================================*/#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;/*=================================================================    时间片的结构体定义=================================================================*/struct PCB&#123;    char name[10];      // 进程名称    int arrivelTime;    // 到达时间    int runTime;        // 服务时间    int timeLeft;       // 剩余时间    char *state;        // 所处状态    struct PCB *next;   // 链表队列&#125;;/*=================================================================    输入函数：输入PCB相关数据    返回：就绪队列=================================================================*/PCB *input()&#123;    int N, i;    struct PCB *head, *rear;// 定义队首、队尾    struct PCB *p, *q, *t;// p是队尾指针，q是队首指针，t是执行时间    head = rear = NULL;    printf(\"请输入进程数目：\");    scanf(\"%d\", &amp;N);    for(i = 0; i &lt; N; i++)    &#123;        p = (struct PCB *)malloc(sizeof(struct PCB));        printf(\"请输入第%d个进程的名字、到达时间、服务时间：\\n\", i+1);        scanf(\"%s%d%d\", p-&gt;name, &amp;p-&gt;arrivelTime, &amp;p-&gt;runTime);        p-&gt;timeLeft = p-&gt;runTime;        p-&gt;state = \"就绪\";        p-&gt;next = NULL;        // 当输入结束时，把p的数据放到队首，以便下一步执行        // 否则执行时间为空，队首变成q        if(rear == NULL)        &#123;            head = p;            p-&gt;next = NULL;            rear = p;        &#125;        else        &#123;            t = NULL;            q = head;            // 若q和q的到达时间小于p的到达时间时，把执行时间给q            while(q &amp;&amp; q-&gt;arrivelTime &lt; p-&gt;arrivelTime)            &#123;                t = q;                q = q-&gt;next;            &#125;            // 当q是队首时，则下一个队首变成p,以便每个进程都能够得到时间片            // 或执行时间片到达队尾时（执行完成），返回给队首p            // 否则给队首p占用执行时间，p执行完后到q            if(q == head)            &#123;                p-&gt;next = head;                head = p;            &#125;            else if(t == rear)            &#123;                rear-&gt;next = p;                p-&gt;next = NULL;                rear = p;            &#125;            else            &#123;                t-&gt;next = p;                p-&gt;next = q;            &#125;        &#125;    &#125;    return head;&#125;/*=================================================================   运行函数=================================================================*/void run(struct PCB *head)&#123;    struct PCB *p, *t, *r;    int num,nowTime=0;    int cnt=0;    vector&lt;string&gt; vec_out;    printf(\"请输入时间片：\");    scanf(\"%d\", &amp;num);    // 当队首不为空时，把p给队首    while(head != NULL)    &#123;        r = p = head;        // 把执行时间给队首        while(p != NULL)        &#123;            t = head;            if(cnt!=0)            &#123;                p-&gt;timeLeft = p-&gt;timeLeft - cnt;                nowTime += cnt;                cnt = 0;            &#125;            else            &#123;                p-&gt;timeLeft = p-&gt;timeLeft - num;                nowTime += num;            &#125;            p-&gt;state = \"运行\";            string s = p-&gt;name;            vec_out.push_back(s);            // 当p运行完，即剩余时间小于0时，仍然把它当做0处理            if(p-&gt;timeLeft &lt; 0)            &#123;                cnt = -1*p-&gt;timeLeft;                p-&gt;timeLeft = 0;            &#125;            printf(\"\\n\\n----------%d时刻各进程运行状态----------\\n\", nowTime);            printf(\"进程  到达时间 服务时间  剩余时间  当前状态\\n\");            while(t != NULL)            &#123;                printf(\"%2s %8d %8d %8d %10s\\n\", t-&gt;name, t-&gt;arrivelTime, t-&gt;runTime, t-&gt;timeLeft, t-&gt;state);                t = t-&gt;next;            &#125;            if(p-&gt;timeLeft == 0)            &#123;                if(p == head)                &#123;                    head = p-&gt;next;                    free(p);                    p = head;                &#125;                else                &#123;                    r-&gt;next = p-&gt;next;                    p = r-&gt;next;                    r = p;                &#125;            &#125;            else            &#123;                r = p;                p-&gt;state = \"就绪\";                p = p-&gt;next;            &#125;        &#125;    &#125;    printf(\"执行顺序为：\\n\");    printf(\"%s\", vec_out[0].c_str());    for(int i = 1; i &lt; vec_out.size(); i++)    &#123;        printf(\"--&gt;%s\", vec_out[i].c_str());    &#125;&#125;/*=================================================================    时间片轮转算法入口=================================================================*/void RR_MAIN()&#123;    struct PCB *head;    head = input();    run(head);&#125;/*=================================================================    主函数=================================================================*/int main()&#123;    RR_MAIN();    return 0;&#125;\n\n算法二：银行家算法\n百度百科：银行家算法是一种最有代表性的避免死锁的算法。在避免死锁方法中允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次分配资源的安全性，若分配不会导致系统进入不安全状态，则分配，否则等待。为实现银行家算法，系统必须设置若干数据结构。\n\n银行家算法是为了解决在进程抢占临界区资源时候，OS能让所有进程顺利运行结束。算法主体思想是深搜，直到能找到可以把所有进程都运行完毕的，一个安全序列。模拟一下大概的过程\n\n找到进程进一步需要的资源数，能满足小于现在所有剩余可用的资源数，的进程。这代表着这个进程可以正常运行结束。\n然后模拟释放进程，将它之前占用的资源附加给剩余可用资源数。\n循环下去，直到所有的进程都运行完毕。\n\n银行家算法源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348/*=================================================================OS algorithm of The Banker's Algorithm2018.6.6    jelech      start writing2018.6.7\tjelech\t\tmodify algorithm2018.6.10\tjelech\t\tmodify output2018.6.12\tjelech\t\tmodify the file2018.6.12\tjelech\t\tending the file=================================================================*/#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;/*=================================================================    资源数定义    进程数定义=================================================================*/#define MAX_PROCESS 10 //进程数上限#define MAX_RESOURCE_KIND 10 //资源种类上限#define MAX_RESOURCE_NUM 20\t//每种资源可用数上限int resource;\t//实际资源种类数int process;\t//实际进程数int safe_list[MAX_PROCESS];\t//安全序列/*=================================================================    可用资源向量=================================================================*/struct AVAILABLE&#123;\tint resource_number; //资源数目\tint work;\t//工作向量&#125;Resource[MAX_RESOURCE_KIND], R_backup[MAX_RESOURCE_KIND];/*=================================================================    进程数据向量表=================================================================*/struct PROC&#123;\tint max[MAX_RESOURCE_KIND];\t//最大需求矩阵\tint allocation[MAX_RESOURCE_KIND];\t//分配矩阵\tint need[MAX_RESOURCE_KIND];\t//需求矩阵\tbool finish;\t//满足标记&#125;Process[MAX_PROCESS], P_backup[MAX_PROCESS];void zero();void show_me();void init();void init_allocation();void update();void backup();void re_backup();bool allocation();bool one_allocation(int a, int b, int c);int is_safe();void _isSafe();int banker();/*=================================================================    清零函数:对所有矩阵进行初始化=================================================================*/void zero() &#123;//清零\tfor (int i = 0; i&lt;MAX_RESOURCE_KIND; i++) &#123;\t\tResource[i].resource_number = 0;\t&#125;\tfor (int i = 0; i&lt;MAX_RESOURCE_KIND; i++) &#123;\t\tfor (int j = 0; j&lt; MAX_RESOURCE_KIND; j++) &#123;\t\t\tProcess[i].max[j] = 0;\t\t\tProcess[i].allocation[j] = 0;\t\t\tProcess[i].need[j] = 0;\t\t&#125;\t&#125;&#125;/*=================================================================    绘制中间矩阵:绘制可用矩阵、最大资源矩阵、已用矩阵、需要资源矩阵=================================================================*/void show_me() &#123;\tprintf(\"\\n---------------------------------\\n\"\t\t\t\"可用资源矩阵\");\tfor (int i = 0; i &lt; resource; i++) &#123;\t\tprintf(\"%d \", Resource[i].resource_number);\t&#125;\t// 格式\tprintf(\"\\n\");\tprintf(\"\\n最大资源矩阵\");\tfor (int i = 0; i &lt; MAX_RESOURCE_KIND *2-14; i++) printf(\" \");\tprintf(\"已用资源矩阵\");\tfor (int i = 0; i &lt; MAX_RESOURCE_KIND * 2 -14; i++) printf(\" \");\tprintf(\"需要资源矩阵\");\tfor (int i = 0; i &lt; MAX_RESOURCE_KIND * 2 - 8; i++) printf(\" \");\tfor (int i = 0; i&lt;process; i++) &#123;\t\tprintf(\"\\n  \");\t\tfor (int j = 0; j&lt;resource; j++) printf(\"%d \", Process[i].max[j]);\t\tfor (int i = 0; i &lt; MAX_RESOURCE_KIND * 2 - resource*2; i++) printf(\" \");\t\tfor (int j = 0; j&lt;resource; j++)\tprintf(\"%d \", Process[i].allocation[j]);\t\tfor (int i = 0; i &lt; MAX_RESOURCE_KIND * 2 - resource * 2; i++) printf(\" \");\t\tfor (int j = 0; j&lt;resource; j++) printf(\"%d \", Process[i].need[j]);\t&#125;\tprintf(\"\\n\");&#125;/*=================================================================    初始化:输入进程个数、资源个数、进程最大需求，当前分配状态=================================================================*/void init() &#123;//初始化\tint n;\tprintf(\"\\n请输入资源数  \");\tscanf(\"%d\", &amp;n);\tresource = n;\tprintf(\"\\n请输入资源数量序列, 空格隔开  \");\tfor (int i = 0; i&lt;resource; i++) &#123;\t\tscanf(\"%d\", &amp;n);\t\tResource[i].resource_number = n;\t&#125;\tprintf(\"\\n\\n----------------------------------\");\tprintf(\"\\n请输入进程数  \");\tscanf(\"%d\", &amp;n);\tprocess = n;\tfor (int i = 0; i&lt;process; i++) &#123;\t\tint a, flag;\t\tflag = 0;\t\tprintf(\"\\n输入进程%d对资源最大需求,空格隔开  \", i + 1);\t\tfor (int j = 0; j&lt;resource; j++) &#123;\t\t\tscanf(\"%d\", &amp;a);\t\t\tProcess[i].max[j] = a;\t\t\tif (a&gt;Resource[j].resource_number) flag = 1;\t\t&#125;\t\tif (flag == 1) &#123;\t\t\ti--;\t\t\tprintf(\"\\n需求超过资源上限,驳回请求,请重新输入\\n\");\t\t&#125;\t\tgetchar();\t&#125;&#125;/*=================================================================    初始化分配状态:输入进程当前资源分配状态=================================================================*/void init_allocation() &#123;//初始分配状态\tfor (int i = 0; i&lt;process; i++) &#123;\t\tint a, flag;\t\tflag = 0;\t\tprintf(\"\\n输入进程%d当前资源分配状态, 空格隔开  \", i + 1);\t\tfor (int j = 0; j&lt;resource; j++) &#123;\t\t\tscanf(\"%d\", &amp;a);\t\t\tProcess[i].allocation[j] = a;\t\t\tif (a&gt;Resource[j].resource_number || a&gt;Process[i].max[j]) flag = 1;\t\t&#125;\t\tif (flag == 1) &#123;\t\t\ti--;\t\t\tprintf(\"\\n当前资源占用超过资源上限请重新输入\\n\");\t\t&#125;\t&#125;\tupdate();&#125;/*=================================================================    更新需求矩阵和资源数目向量=================================================================*/void update() &#123;\tfor (int i = 0; i&lt;process; i++) &#123;\t\tfor (int j = 0; j&lt;resource; j++) &#123;\t\t\tProcess[i].need[j] = Process[i].max[j] - Process[i].allocation[j];\t\t\tResource[j].resource_number -= Process[i].allocation[j];\t\t&#125;\t&#125;&#125;/*=================================================================    新资源状态分配:进程请求新的要求=================================================================*/bool allocation() &#123;\tbackup();\tprintf(\"\\n请输入进程号以及对应资源所分配的数目用空格隔开\\n\");\tint pro_num;\tscanf(\"%d\", &amp;pro_num);\tint aff[MAX_RESOURCE_KIND];\tfor (int i = 0; i &lt; resource; i++) &#123;\t\tscanf(\"%d\", &amp;aff[i]);\t&#125;\tfor (int i = 0; i &lt; resource; i++) &#123;\t\tif (one_allocation(pro_num-1, i, aff[i]) == false) &#123;//调用单次分配函数尝试分配\t\t\tre_backup();\t\t\treturn false;\t\t&#125;\t&#125;\treturn true;&#125;/*=================================================================    附属：新资源状态分配    单次分配=================================================================*/bool one_allocation(int a, int b, int c) &#123;\tif (c&gt;Process[a].need[b]) &#123;\t\tprintf(\"要求超过所需上限，请求失败\\n\");\t\treturn false;\t&#125;\telse if (c&gt;Resource[b].resource_number) &#123;\t\tprintf(\"无足够资源，请求失败\\n\");\t\treturn false;\t&#125;\tResource[b].resource_number -= c;\tProcess[a].need[b] -= c;\tProcess[a].allocation[b] += c;\treturn true;&#125;/*=================================================================    数据备份：方便在检查后安全性后更新是否合格=================================================================*/void backup() &#123;\tfor (int i = 0; i &lt; process; i++) &#123;\t\tP_backup[i] = Process[i];\t&#125;\tfor (int i = 0; i &lt; resource; i++) &#123;\t\tR_backup[i] = Resource[i];\t&#125;&#125;/*=================================================================    初始化分配状态:输入进程当前资源分配状态=================================================================*/void re_backup() &#123;\t//数据还原\tfor (int i = 0; i &lt; process; i++) &#123;\t\tProcess[i] = P_backup[i];\t&#125;\tfor (int i = 0; i &lt; resource; i++) &#123;\t\tResource[i] = R_backup[i];\t&#125;&#125;/*=================================================================    安全性检测算法=================================================================*/int is_safe() &#123;\tfor (int i = 0; i &lt; resource; i++) &#123;\t\tResource[i].work = Resource[i].resource_number;\t&#125;\tfor (int i = 0; i &lt; process; i++) &#123;\t\tProcess[i].finish = false;\t\tsafe_list[i] = 0;\t&#125;  \t_isSafe();\tbool flag = true;\tfor (int i = 0; i &lt; process; i++) &#123;\t\tif (Process[i].finish == false) &#123;\t\t\tflag = false;\t\t\tbreak;\t\t&#125;\t&#125;\tif (flag == true) &#123;\t\tprintf(\"\\n系统状态安全，安全序列为  \");\t\tfor (int i = 0; i &lt; process; i++) &#123;\t\t\tprintf(\"%d \",safe_list[i]);\t\t&#125;\t\treturn 1;\t&#125;\telse &#123;\t\tprintf(\"\\n系统状态不安全, 无法完成任务\");\t\treturn 0;\t&#125;&#125;/*=================================================================    //安全性算法的递归分支=================================================================*/void _isSafe()&#123;\tfor (int i = 0; i &lt; process; i++)\t&#123;\t\tbool flag=true;\t\tif (Process[i].finish == false) //该进程分配未结束\t\t&#123;\t\t\tfor (int j = 0; j &lt; resource; j++)//查找是否可用资源够这个进程使用\t\t\t&#123;\t\t\t\tif (Process[i].need[j] &gt; Resource[j].work)\t\t\t\t&#123;\t\t\t\t\tflag = false;\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t&#125;\t\t\tif (flag == true)//够分配\t\t\t&#123;\t\t\t\tfor (int j = 0; j &lt; resource; j++)\t\t\t\t&#123;\t\t\t\t\tResource[j].work += Process[i].allocation[j];\t\t\t\t\tProcess[i].finish = true;\t\t\t\t&#125;\t\t\t\tfor (int k = 0; k &lt; process; k++)\t\t\t\t&#123;\t\t\t\t\tif (safe_list[k] == 0) &#123;\t\t\t\t\t\tsafe_list[k] = i + 1;\t\t\t\t\t\tbreak;\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\t// update();\t\t\t\tfor (int j = 0; j&lt;resource; j++)// i进程 更新所有资源\t\t\t\t&#123;\t\t\t\t\tResource[j].resource_number += Process[i].allocation[j];\t\t\t\t\tProcess[i].allocation[j] = 0;\t\t\t\t\tProcess[i].need[j] = Process[i].max[j];\t\t\t\t&#125;\t\t\t\tshow_me();\t\t\t\t_isSafe();\t//递归处理\t\t\t&#125;\t\t&#125;\t&#125;&#125;/*=================================================================    银行家算法入口=================================================================*/int banker() &#123;\tbackup();\tif (allocation() == false) return -1;\tif (is_safe()) &#123;        printf(\"\\n分配成功！\"        \t\t\"\\n----------------------------------\");        show_me();\t\treturn 1;\t&#125;\telse\t&#123;\t\tre_backup();\t\treturn -1;\t&#125;&#125;/*=================================================================    主程序入口=================================================================*/int main()&#123;\tzero();\tinit();\tinit_allocation();\tshow_me();\tbackup();\tis_safe();\tre_backup();\tbanker();\twhile(printf(\"\\n若需继续分配\"))        banker();\tgetchar();\treturn 0;&#125;\n算法三：LRU页面置换算法\n百度百科：它的实质是，当需要置换一页时，选择在之前一段时间里最久没有使用过的页面予以置换。这种算法就称为最久未使用算法\n\n页面置换是什么页面置换是指进程一部分在内存中，一部分在外存中，在cup需要调用外存中的一些内容时候，需要进行页面置换操作，而LRU置换算法根据的是在之前的调换序列中总结出的规律，并加以预测。最近最久未使用比较的是当前页框中的所有进程，在这次调用之前最后一个第一次被用到的是谁，换句话说在一段时间内没有使用过的进程会被换走，这样的操作的优点是系统观察到最近使用到的进程很可能会再次被使用到，因此会换掉很久没有使用到的页面。\n它的缺点是需要大量硬件的支持，并且很有可以在调换后刚好久使用到了这个页面，容易造成循环多次替换优点是简单有效，寻找的速度相对较快，节省了查找的时间。\nLRU源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/*=================================================================OS algorithm of Least Recently Used2018.6.13   jelech      start writing2018.6.14   jelech      add the OP algorithm2018.6.19   jelech      modify the algorithm=================================================================*/#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;using namespace std;/*=================================================================    数据定义=================================================================*/const int MAX_PROC_NUM = 25;//定义最大进程数const int MAX_PHYB_NUM = 5;//定义最大物理块数struct PhysicalBlockList// 输入的进程序列&#123;\tint num;\tint runArray[MAX_PROC_NUM];&#125;PBL;int phyBlockNum;// 物理块数int L[MAX_PHYB_NUM];//物理块几何void intput();void show();/*=================================================================    输入函数：对物理块数、进程序列、进程数的输入函数=================================================================*/int input()&#123;\tprintf(\"请输入物理块数：\");\tscanf(\"%d\", &amp;phyBlockNum);\tprintf(\"请输入序列总数：\");\tscanf(\"%d\", &amp;PBL.num);\tprintf(\"\\n请输入访问序列:\");\tfor (int i = 1; i &lt;= PBL.num; i++)\t\tscanf(\"%d\", &amp;PBL.runArray[i]);\treturn 1;&#125;/*=================================================================    打印当前页框序列=================================================================*/void show()&#123;\tfor (int i = 1; i &lt;= phyBlockNum; ++i)\t// 遍历当前页框中的所有进程代码\t&#123;\t\tprintf(\" %d\", L[i]);\t&#125;\tprintf(\"\\n\");&#125;/*=================================================================    最近最久未使用算法=================================================================*/void solvebylru()&#123;\tint replacePos = 1; // 替代位置\tint zeroPos = 1;//是否满了的位置\tprintf(\"LRU算法序列:\\n\");\tfor (int i = 1; i &lt;= PBL.num; i++)\t&#123;\t\tbool flag = true;\t// 标志为是否找到了进程的位置\t\tfor(int j = 1; j &lt;= phyBlockNum; ++j)// 找到这个进程的位置\t\t&#123;\t\t\tif(PBL.runArray[i] == L[j])\t\t\t&#123;\t\t\t\tflag = false;\t\t\t\treplacePos++;\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t\tif(flag)//没有找到\t\t&#123;\t\t\tif(zeroPos &lt;= phyBlockNum)\t// 如果首次加入页框还没有满，直接加入\t\t\t&#123;\t\t\t\tL[zeroPos] = PBL.runArray[i];\t\t\t\tzeroPos++;\t\t\t&#125;\t\t\telse\t\t\t&#123;//遍历所有的页框中的进程，找到也框中应该被替换掉的位置\t\t\t\tfor (int j = 1; j &lt;= phyBlockNum; ++j)\t\t\t\t\t&#123;\t\t\t\t\tif(L[j] == PBL.runArray[replacePos])\t\t\t\t\t&#123;\t\t\t\t\t\tL[j] = PBL.runArray[i];\t\t\t\t\t\treplacePos++;\t\t\t\t\t\tbreak;\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\tshow();\t&#125;&#125;\n算法四：磁盘调度算法\n百度百科：磁盘调度在多道程序设计的计算机系统中，各个进程可能会不断提出不同的对磁盘进行读/写操作的请求。由于有时候这些进程的发送请求的速度比磁盘响应的还要快，因此我们有必要为每个磁盘设备建立一个等待队列\n\n什么是磁盘调度现在的机械硬盘大部分可以形容为许多片结合而成，在进程访问的时候，硬盘的磁盘指针就会寻找到指定的位置进行读取数据。我们这里简单的把它理解为一个光盘的读取，因此，每次访问的时候，会传送给它一个序列，每个值都代表着要访问的指定的位置。然而，如果按照这个普通序列进行访问的话，就会造成指针反复的划过，时间大部分流失在了这里。因此构造一个良好的算法来保证他能快速的调用。\n电梯扫描算法(Scan)正如他的名字一样，它会像电梯一样上升和下降。在算法的第一步会将这个序列进行排序，与当前指针进行比较，选择上升还是下降，在按照这个方向，一直走到头，在反向进行访问。这就是Scan算法。\nScan算法源代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/*=================================================================OS algorithm of Disk scheduling algorithm2018.6.20   jelech      start writing=================================================================*/#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;/*=================================================================    数据定义=================================================================*/const int MAX_PROC_NUM = 50;// 最大进程数int mgnum;//磁盘访问数int PBL[MAX_PROC_NUM];//磁盘访问序列:存放位置信息int PBL_bk[MAX_PROC_NUM];//磁盘访问序列:存放位置信息(备份)int mgpos=0;// 初始磁头位置int putArray[MAX_PROC_NUM];// 输出序列int mvsum=0;// 总移动数/*=================================================================    数据输入=================================================================*/void input()&#123;    printf(\"请输入磁盘访问数:\");    scanf(\"%d\", &amp;mgnum);    printf(\"请输入访问序列:\");    for(int i=1; i &lt;= mgnum; i++)    &#123;        scanf(\"%d\", &amp;PBL[i]);        PBL_bk[i] = PBL[i]; // 输入时，进行备份    &#125;    printf(\"请输入磁头位置:\");    scanf(\"%d\", &amp;mgpos);&#125;/*=================================================================    数据输出=================================================================*/void print()&#123;    printf(\"\\n总寻道长度：%d\\t平均寻道长度：%.2f\\n寻道序列：\", mvsum, mvsum*1.0/mgnum);\tfor (int i = 0; i &lt; mgnum; ++i)    // 遍历所有序列进行输出\t&#123;\t\tprintf(i != mgnum-1 ? \"%d \":\"%d\\n\", putArray[i]);\t&#125;&#125;/*=================================================================    主函数入口=================================================================*/void solvebyScan()&#123;\tfor (int i = 1; i &lt;= mgnum; ++i)\t&#123;\t\tPBL[i] = PBL_bk[i];\t&#125;\tsort(PBL+1, PBL+1+mgnum);\tint rpl = 1, rpr = mgnum;\t// 下一次要替换的位置：左、右  while(PBL[rpl] &lt; mgpos) rpl++;  rpr = rpl;\t//找到的是比初始指针大的第一个  rpl = rpr-1;  mvsum = 0;  int mlen = mgpos;  int pos = 0;  while(rpr &lt;= mgnum)&#123;\t// 默认先向上    putArray[pos] = PBL[rpr];    rpr++,pos++;  &#125;  mvsum += (PBL[rpr-1] - mgpos);  while(rpl &gt; 0)&#123;    putArray[pos] = PBL[rpl];    rpl--,pos++;  &#125;  mvsum += (mgpos + PBL[rpl+1]);  printf(\"\\nSCAN算法：\");  print();&#125;\n专用术语系统吞吐量(system throughput)    并行(paralled)    并发(concurrence)    同步 (Synchronization)临界资源(critical resource)    临界区(critical section)    进程互斥(process mutualexclusion)    地址映射(address mapping)\n碎片(fragmentation)    多程序设计(Multiprogramming)    分段(Segmentation)    批处理技术(batch processing technic)\n异步(asynchronism)    模块化(modularization)    内聚性(cohesion)    耦合度(coupling)\n分层结构(layered architecture)    命令接口(command  interface)    顺序文件(sequential file)    异步操作(asynchronous operation)\n直接存储器存取(Direct Memory Address)    动态(Dynamic)    抖动(thrashing)    时间片(time slicing)(Quantum)\n文件扩展名 (File Extension)    文件属性 (Attribute)    互斥(Mutexes)    引导程序 (Bootstrap)\n位示图 (Bitmaps)    引导参数 Boot Parameter    规范模式 Canonical Mode    请调 Demand Paging\n","dateCreated":"2018-06-13T21:39:01+08:00","dateModified":"2018-12-01T21:39:05+08:00","datePublished":"2018-06-13T21:39:01+08:00","description":"\n文章还在更新中…\n\n","headline":"操作系统中的算法","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"http://www.jelech.cn/posts/27676/"},"publisher":{"@type":"Organization","name":"Jelech","sameAs":["https://github.com/jelech","mailto"],"image":"avatar.jpg","logo":{"@type":"ImageObject","url":"avatar.jpg"}},"url":"http://www.jelech.cn/posts/27676/","keywords":"笔记, 算法"}</script>
    <meta name="description" content="文章还在更新中…">
<meta name="keywords" content="笔记,算法">
<meta property="og:type" content="blog">
<meta property="og:title" content="操作系统中的算法">
<meta property="og:url" content="http://www.jelech.cn/posts/27676/index.html">
<meta property="og:site_name" content="Jelech的博客">
<meta property="og:description" content="文章还在更新中…">
<meta property="og:locale" content="zh-cn">
<meta property="og:updated_time" content="2018-12-01T13:39:05.711Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="操作系统中的算法">
<meta name="twitter:description" content="文章还在更新中…">
<meta name="twitter:creator" content="@twitter">
    
    
        
    
    
        <meta property="og:image" content="http://www.jelech.cn/assets/images/avatar.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-du2xmrqdqrl2ollgeiw050kpl6l4nbyz7bumjuurjgsxyopifvukebxc9lqe.min.css">
    <!--STYLES END-->
    

    
    <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?c3b0944d9211544bb9fe9d25ce47bac7";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">Jelech的博客</a>
    </div>
    
        
            <a class="header-right-picture " href="#about">
        
        
            <img class="header-picture" src="/assets/images/avatar.jpg" alt="作者的图片">
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.jpg" alt="作者的图片">
                </a>
                <h4 class="sidebar-profile-name">Jelech</h4>
                
                    <h5 class="sidebar-profile-bio"><p>putty本无树,MinGW亦非台</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/ " title="首页">
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-categories" title="分类">
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-tags" title="标签">
                    
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-archives" title="归档">
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/game" title="游戏">
                    
                        <i class="sidebar-button-icon fas fa-gamepad" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">游戏</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="#about" title="关于">
                    
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="https://github.com/jelech" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/mailto" title="邮箱">
                    
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">邮箱</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            操作系统中的算法
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2018-06-13T21:39:01+08:00">
	
		    6月 13, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/学习笔记/">学习笔记</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            
            <blockquote>
<p>文章还在更新中…</p>
</blockquote>
<h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#算法一：RR时间片轮转"><span class="toc-text">算法一：RR时间片轮转</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#后来，又更新了一些方法对它进行改良。"><span class="toc-text">后来，又更新了一些方法对它进行改良。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RR算法源代码"><span class="toc-text">RR算法源代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法二：银行家算法"><span class="toc-text">算法二：银行家算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#银行家算法源代码"><span class="toc-text">银行家算法源代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法三：LRU页面置换算法"><span class="toc-text">算法三：LRU页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#页面置换是什么"><span class="toc-text">页面置换是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LRU源代码"><span class="toc-text">LRU源代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法四：磁盘调度算法"><span class="toc-text">算法四：磁盘调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是磁盘调度"><span class="toc-text">什么是磁盘调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Scan算法源代码"><span class="toc-text">Scan算法源代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#专用术语"><span class="toc-text">专用术语</span></a></li></ol>
<a id="more"></a>
<h2 id="算法一：RR时间片轮转"><a href="#算法一：RR时间片轮转" class="headerlink" title="算法一：RR时间片轮转"></a>算法一：RR时间片轮转</h2><blockquote>
<p>百度百科：<br>时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。如果在时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。调度程序所要做的就是维护一张就绪进程列表，当进程用完它的时间片后，它被移到队列的末尾。</p>
</blockquote>
<p>时间片轮转，从字面上理解就是会有个时间片定义，让每个进程都轮转，直到进程结束。<br>当新程序向OS提出要运行的时候，OS会给他分配适合的PCB头，成为进程的程序会先进入就绪队列，也就是排在队列的队尾。<br>新的一轮开始的时候，OS会给队首一个<strong>时间片长度</strong>，表示这个进程可以<strong>最多</strong>运行这么长的<strong>时间</strong>。</p>
<ul>
<li><strong>若</strong>当时间片用完，进程会进入就绪队列的队尾，如此循环，直到进程清空就绪队列。</li>
</ul>
<ul>
<li><strong>若</strong>进程结束，进程会进入伪退出状态，数据会写入虚拟内存(外存)。而此时会剩余一些时间片的时间，OS可以选择将它继续分配给下一个进程，减少不必要的等待。</li>
<li><strong>若</strong>进程应一些I/O请求等因素，OS也会中断进程，让其进入阻塞队列。只有请求结束后，才会让他重新进入就绪队列。</li>
</ul>
<h4 id="后来，又更新了一些方法对它进行改良。"><a href="#后来，又更新了一些方法对它进行改良。" class="headerlink" title="后来，又更新了一些方法对它进行改良。"></a>后来，又更新了一些方法对它进行改良。</h4><ol>
<li>带有优先级的时间片轮转法<br>因为在操作系统中，一些进程是比其他进程更需要提前完成的，因此在不同的进程里有不同的优先级。这里的优先级是静态的，意思是在进程进来前，OS以及对他进行了分析，得出了它相对于其他的进程的优先级高低。在新进程进入的时候，有可能是更高的优先级，让这个进程更有限的享用CPU，这里又分为了 &lt;基时钟中断：等待当前进程时间片结束&gt; &lt;立即抢占：等待当前进程出了临界区后立即中断进程&gt; 两种方式对现有的进程进行替换。</li>
<li>反馈调度法<br>这个算法是进程在调度时候的算法，普通的RR最初来自于页面置换算法中。反馈调度中提倡的是对进程已运行一部分和从未运行进行区分比较，也就是说，对于已经在队列中运行，较多次时间片的进程，优先级低于较少次时间片的进程。<br>因此在实现的时候，反馈调度算法使用了n个队列，而一般在设置的时候不同的队列的时间片也是不一样的。实现方面和RR类似，但是当有两个进程的时候，一个进程在这个队列运行完毕，会因为下一个进程的抢占，导致其进入了优先级更低的队列中。其他部分和RR算法类似，直到所有进程运行完毕。<br>其中，当有新的进程进入的时候，是插入到优先级最高的队列后面，按同样的方式，向下传播。</li>
</ol>
<h4 id="RR算法源代码"><a href="#RR算法源代码" class="headerlink" title="RR算法源代码"></a>RR算法源代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*=================================================================</span></span><br><span class="line"><span class="comment">OS algorithm of Time slice rotation</span></span><br><span class="line"><span class="comment">2018.5.15   jelech      start writing</span></span><br><span class="line"><span class="comment">2018.5.20   jelech      modify the algorithm</span></span><br><span class="line"><span class="comment">2018.5.31   jelech      modify the PCB</span></span><br><span class="line"><span class="comment">2018.6.5    jelech      modify the format</span></span><br><span class="line"><span class="comment">=================================================================*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=================================================================</span></span><br><span class="line"><span class="comment">    时间片的结构体定义</span></span><br><span class="line"><span class="comment">=================================================================*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PCB</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];      <span class="comment">// 进程名称</span></span><br><span class="line">    <span class="keyword">int</span> arrivelTime;    <span class="comment">// 到达时间</span></span><br><span class="line">    <span class="keyword">int</span> runTime;        <span class="comment">// 服务时间</span></span><br><span class="line">    <span class="keyword">int</span> timeLeft;       <span class="comment">// 剩余时间</span></span><br><span class="line">    <span class="keyword">char</span> *state;        <span class="comment">// 所处状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PCB</span> *<span class="title">next</span>;</span>   <span class="comment">// 链表队列</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=================================================================</span></span><br><span class="line"><span class="comment">    输入函数：输入PCB相关数据</span></span><br><span class="line"><span class="comment">    返回：就绪队列</span></span><br><span class="line"><span class="comment">=================================================================*/</span></span><br><span class="line"><span class="function">PCB *<span class="title">input</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PCB</span> *<span class="title">head</span>, *<span class="title">rear</span>;</span><span class="comment">// 定义队首、队尾</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PCB</span> *<span class="title">p</span>, *<span class="title">q</span>, *<span class="title">t</span>;</span><span class="comment">// p是队尾指针，q是队首指针，t是执行时间</span></span><br><span class="line">    head = rear = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入进程数目："</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (struct PCB *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct PCB));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入第%d个进程的名字、到达时间、服务时间：\n"</span>, i+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>, p-&gt;name, &amp;p-&gt;arrivelTime, &amp;p-&gt;runTime);</span><br><span class="line">        p-&gt;timeLeft = p-&gt;runTime;</span><br><span class="line">        p-&gt;state = <span class="string">"就绪"</span>;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当输入结束时，把p的数据放到队首，以便下一步执行</span></span><br><span class="line">        <span class="comment">// 否则执行时间为空，队首变成q</span></span><br><span class="line">        <span class="keyword">if</span>(rear == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            head = p;</span><br><span class="line">            p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            rear = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            t = <span class="literal">NULL</span>;</span><br><span class="line">            q = head;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若q和q的到达时间小于p的到达时间时，把执行时间给q</span></span><br><span class="line">            <span class="keyword">while</span>(q &amp;&amp; q-&gt;arrivelTime &lt; p-&gt;arrivelTime)</span><br><span class="line">            &#123;</span><br><span class="line">                t = q;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当q是队首时，则下一个队首变成p,以便每个进程都能够得到时间片</span></span><br><span class="line">            <span class="comment">// 或执行时间片到达队尾时（执行完成），返回给队首p</span></span><br><span class="line">            <span class="comment">// 否则给队首p占用执行时间，p执行完后到q</span></span><br><span class="line">            <span class="keyword">if</span>(q == head)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next = head;</span><br><span class="line">                head = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(t == rear)</span><br><span class="line">            &#123;</span><br><span class="line">                rear-&gt;next = p;</span><br><span class="line">                p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                rear = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                t-&gt;next = p;</span><br><span class="line">                p-&gt;next = q;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=================================================================</span></span><br><span class="line"><span class="comment">   运行函数</span></span><br><span class="line"><span class="comment">=================================================================*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(struct PCB *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PCB</span> *<span class="title">p</span>, *<span class="title">t</span>, *<span class="title">r</span>;</span></span><br><span class="line">    <span class="keyword">int</span> num,nowTime=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec_out;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入时间片："</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当队首不为空时，把p给队首</span></span><br><span class="line">    <span class="keyword">while</span>(head != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r = p = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把执行时间给队首</span></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t = head;</span><br><span class="line">            <span class="keyword">if</span>(cnt!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;timeLeft = p-&gt;timeLeft - cnt;</span><br><span class="line">                nowTime += cnt;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;timeLeft = p-&gt;timeLeft - num;</span><br><span class="line">                nowTime += num;</span><br><span class="line">            &#125;</span><br><span class="line">            p-&gt;state = <span class="string">"运行"</span>;</span><br><span class="line">            <span class="built_in">string</span> s = p-&gt;name;</span><br><span class="line">            vec_out.push_back(s);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当p运行完，即剩余时间小于0时，仍然把它当做0处理</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;timeLeft &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cnt = <span class="number">-1</span>*p-&gt;timeLeft;</span><br><span class="line">                p-&gt;timeLeft = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n\n----------%d时刻各进程运行状态----------\n"</span>, nowTime);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"进程  到达时间 服务时间  剩余时间  当前状态\n"</span>);</span><br><span class="line">            <span class="keyword">while</span>(t != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%2s %8d %8d %8d %10s\n"</span>, t-&gt;name, t-&gt;arrivelTime, t-&gt;runTime, t-&gt;timeLeft, t-&gt;state);</span><br><span class="line">                t = t-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;timeLeft == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(p == head)</span><br><span class="line">                &#123;</span><br><span class="line">                    head = p-&gt;next;</span><br><span class="line">                    <span class="built_in">free</span>(p);</span><br><span class="line">                    p = head;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    r-&gt;next = p-&gt;next;</span><br><span class="line">                    p = r-&gt;next;</span><br><span class="line">                    r = p;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                r = p;</span><br><span class="line">                p-&gt;state = <span class="string">"就绪"</span>;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"执行顺序为：\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, vec_out[<span class="number">0</span>].c_str());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; vec_out.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"--&gt;%s"</span>, vec_out[i].c_str());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=================================================================</span></span><br><span class="line"><span class="comment">    时间片轮转算法入口</span></span><br><span class="line"><span class="comment">=================================================================*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RR_MAIN</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PCB</span> *<span class="title">head</span>;</span></span><br><span class="line">    head = input();</span><br><span class="line">    run(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=================================================================</span></span><br><span class="line"><span class="comment">    主函数</span></span><br><span class="line"><span class="comment">=================================================================*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RR_MAIN();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="算法二：银行家算法"><a href="#算法二：银行家算法" class="headerlink" title="算法二：银行家算法"></a>算法二：银行家算法</h3><blockquote>
<p>百度百科：银行家算法是一种最有代表性的避免死锁的算法。在避免死锁方法中允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次分配资源的安全性，若分配不会导致系统进入不安全状态，则分配，否则等待。为实现银行家算法，系统必须设置若干数据结构。</p>
</blockquote>
<p>银行家算法是为了解决在进程抢占临界区资源时候，OS能让所有进程顺利运行结束。算法主体思想是深搜，直到能找到可以把所有进程都运行完毕的，一个安全序列。<br>模拟一下大概的过程</p>
<ul>
<li>找到进程进一步需要的资源数，能满足小于现在所有剩余可用的资源数，的进程。这代表着这个进程可以正常运行结束。</li>
<li>然后模拟释放进程，将它之前占用的资源附加给剩余可用资源数。</li>
<li>循环下去，直到所有的进程都运行完毕。</li>
</ul>
<h4 id="银行家算法源代码"><a href="#银行家算法源代码" class="headerlink" title="银行家算法源代码"></a>银行家算法源代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*=================================================================</span></span><br><span class="line"><span class="comment">OS algorithm of The Banker's Algorithm</span></span><br><span class="line"><span class="comment">2018.6.6    jelech      start writing</span></span><br><span class="line"><span class="comment">2018.6.7	jelech		modify algorithm</span></span><br><span class="line"><span class="comment">2018.6.10	jelech		modify output</span></span><br><span class="line"><span class="comment">2018.6.12	jelech		modify the file</span></span><br><span class="line"><span class="comment">2018.6.12	jelech		ending the file</span></span><br><span class="line"><span class="comment">=================================================================*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="comment">/*=================================================================</span></span><br><span class="line"><span class="comment">    资源数定义</span></span><br><span class="line"><span class="comment">    进程数定义</span></span><br><span class="line"><span class="comment">=================================================================*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_PROCESS 10 <span class="comment">//进程数上限</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_RESOURCE_KIND 10 <span class="comment">//资源种类上限</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_RESOURCE_NUM 20	<span class="comment">//每种资源可用数上限</span></span></span><br><span class="line"><span class="keyword">int</span> resource;	<span class="comment">//实际资源种类数</span></span><br><span class="line"><span class="keyword">int</span> process;	<span class="comment">//实际进程数</span></span><br><span class="line"><span class="keyword">int</span> safe_list[MAX_PROCESS];	<span class="comment">//安全序列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*=================================================================</span></span><br><span class="line"><span class="comment">    可用资源向量</span></span><br><span class="line"><span class="comment">=================================================================*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AVAILABLE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> resource_number; <span class="comment">//资源数目</span></span><br><span class="line">	<span class="keyword">int</span> work;	<span class="comment">//工作向量</span></span><br><span class="line">&#125;Resource[MAX_RESOURCE_KIND], R_backup[MAX_RESOURCE_KIND];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=================================================================</span></span><br><span class="line"><span class="comment">    进程数据向量表</span></span><br><span class="line"><span class="comment">=================================================================*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PROC</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> max[MAX_RESOURCE_KIND];	<span class="comment">//最大需求矩阵</span></span><br><span class="line">	<span class="keyword">int</span> allocation[MAX_RESOURCE_KIND];	<span class="comment">//分配矩阵</span></span><br><span class="line">	<span class="keyword">int</span> need[MAX_RESOURCE_KIND];	<span class="comment">//需求矩阵</span></span><br><span class="line">	<span class="keyword">bool</span> finish;	<span class="comment">//满足标记</span></span><br><span class="line">&#125;Process[MAX_PROCESS], P_backup[MAX_PROCESS];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zero</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_me</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_allocation</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backup</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">re_backup</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">allocation</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">one_allocation</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_safe</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">void</span> _isSafe();</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">banker</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=================================================================</span></span><br><span class="line"><span class="comment">    清零函数:对所有矩阵进行初始化</span></span><br><span class="line"><span class="comment">=================================================================*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zero</span><span class="params">()</span> </span>&#123;<span class="comment">//清零</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;MAX_RESOURCE_KIND; i++) &#123;</span><br><span class="line">		Resource[i].resource_number = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;MAX_RESOURCE_KIND; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt; MAX_RESOURCE_KIND; j++) &#123;</span><br><span class="line">			Process[i].max[j] = <span class="number">0</span>;</span><br><span class="line">			Process[i].allocation[j] = <span class="number">0</span>;</span><br><span class="line">			Process[i].need[j] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=================================================================</span></span><br><span class="line"><span class="comment">    绘制中间矩阵:绘制可用矩阵、最大资源矩阵、已用矩阵、需要资源矩阵</span></span><br><span class="line"><span class="comment">=================================================================*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_me</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n---------------------------------\n"</span></span><br><span class="line">			<span class="string">"可用资源矩阵"</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; resource; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, Resource[i].resource_number);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 格式</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n最大资源矩阵"</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_RESOURCE_KIND *<span class="number">2</span><span class="number">-14</span>; i++) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"已用资源矩阵"</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_RESOURCE_KIND * <span class="number">2</span> <span class="number">-14</span>; i++) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"需要资源矩阵"</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_RESOURCE_KIND * <span class="number">2</span> - <span class="number">8</span>; i++) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;process; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n  "</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;resource; j++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, Process[i].max[j]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_RESOURCE_KIND * <span class="number">2</span> - resource*<span class="number">2</span>; i++) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;resource; j++)	<span class="built_in">printf</span>(<span class="string">"%d "</span>, Process[i].allocation[j]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_RESOURCE_KIND * <span class="number">2</span> - resource * <span class="number">2</span>; i++) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;resource; j++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, Process[i].need[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*=================================================================</span></span><br><span class="line"><span class="comment">    初始化:输入进程个数、资源个数、进程最大需求，当前分配状态</span></span><br><span class="line"><span class="comment">=================================================================*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;<span class="comment">//初始化</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n请输入资源数  "</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	resource = n;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n请输入资源数量序列, 空格隔开  "</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;resource; i++) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">		Resource[i].resource_number = n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n\n----------------------------------"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n请输入进程数  "</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	process = n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;process; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> a, flag;</span><br><span class="line">		flag = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n输入进程%d对资源最大需求,空格隔开  "</span>, i + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;resource; j++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">			Process[i].max[j] = a;</span><br><span class="line">			<span class="keyword">if</span> (a&gt;Resource[j].resource_number) flag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">			i--;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n需求超过资源上限,驳回请求,请重新输入\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		getchar();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=================================================================</span></span><br><span class="line"><span class="comment">    初始化分配状态:输入进程当前资源分配状态</span></span><br><span class="line"><span class="comment">=================================================================*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_allocation</span><span class="params">()</span> </span>&#123;<span class="comment">//初始分配状态</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;process; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> a, flag;</span><br><span class="line">		flag = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n输入进程%d当前资源分配状态, 空格隔开  "</span>, i + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;resource; j++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">			Process[i].allocation[j] = a;</span><br><span class="line">			<span class="keyword">if</span> (a&gt;Resource[j].resource_number || a&gt;Process[i].max[j]) flag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">			i--;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n当前资源占用超过资源上限请重新输入\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=================================================================</span></span><br><span class="line"><span class="comment">    更新需求矩阵和资源数目向量</span></span><br><span class="line"><span class="comment">=================================================================*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;process; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;resource; j++) &#123;</span><br><span class="line">			Process[i].need[j] = Process[i].max[j] - Process[i].allocation[j];</span><br><span class="line">			Resource[j].resource_number -= Process[i].allocation[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=================================================================</span></span><br><span class="line"><span class="comment">    新资源状态分配:进程请求新的要求</span></span><br><span class="line"><span class="comment">=================================================================*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">allocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	backup();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n请输入进程号以及对应资源所分配的数目用空格隔开\n"</span>);</span><br><span class="line">	<span class="keyword">int</span> pro_num;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;pro_num);</span><br><span class="line">	<span class="keyword">int</span> aff[MAX_RESOURCE_KIND];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; resource; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;aff[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; resource; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (one_allocation(pro_num<span class="number">-1</span>, i, aff[i]) == <span class="literal">false</span>) &#123;<span class="comment">//调用单次分配函数尝试分配</span></span><br><span class="line">			re_backup();</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=================================================================</span></span><br><span class="line"><span class="comment">    附属：新资源状态分配</span></span><br><span class="line"><span class="comment">    单次分配</span></span><br><span class="line"><span class="comment">=================================================================*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">one_allocation</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (c&gt;Process[a].need[b]) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"要求超过所需上限，请求失败\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (c&gt;Resource[b].resource_number) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"无足够资源，请求失败\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Resource[b].resource_number -= c;</span><br><span class="line">	Process[a].need[b] -= c;</span><br><span class="line">	Process[a].allocation[b] += c;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=================================================================</span></span><br><span class="line"><span class="comment">    数据备份：方便在检查后安全性后更新是否合格</span></span><br><span class="line"><span class="comment">=================================================================*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; process; i++) &#123;</span><br><span class="line">		P_backup[i] = Process[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; resource; i++) &#123;</span><br><span class="line">		R_backup[i] = Resource[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=================================================================</span></span><br><span class="line"><span class="comment">    初始化分配状态:输入进程当前资源分配状态</span></span><br><span class="line"><span class="comment">=================================================================*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">re_backup</span><span class="params">()</span> </span>&#123;	<span class="comment">//数据还原</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; process; i++) &#123;</span><br><span class="line">		Process[i] = P_backup[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; resource; i++) &#123;</span><br><span class="line">		Resource[i] = R_backup[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=================================================================</span></span><br><span class="line"><span class="comment">    安全性检测算法</span></span><br><span class="line"><span class="comment">=================================================================*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_safe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; resource; i++) &#123;</span><br><span class="line">		Resource[i].work = Resource[i].resource_number;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; process; i++) &#123;</span><br><span class="line">		Process[i].finish = <span class="literal">false</span>;</span><br><span class="line">		safe_list[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	_isSafe();</span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; process; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (Process[i].finish == <span class="literal">false</span>) &#123;</span><br><span class="line">			flag = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag == <span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n系统状态安全，安全序列为  "</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; process; i++) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>,safe_list[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n系统状态不安全, 无法完成任务"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=================================================================</span></span><br><span class="line"><span class="comment">    //安全性算法的递归分支</span></span><br><span class="line"><span class="comment">=================================================================*/</span></span><br><span class="line"><span class="keyword">void</span> _isSafe()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; process; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (Process[i].finish == <span class="literal">false</span>) <span class="comment">//该进程分配未结束</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; resource; j++)<span class="comment">//查找是否可用资源够这个进程使用</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (Process[i].need[j] &gt; Resource[j].work)</span><br><span class="line">				&#123;</span><br><span class="line">					flag = <span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (flag == <span class="literal">true</span>)<span class="comment">//够分配</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; resource; j++)</span><br><span class="line">				&#123;</span><br><span class="line">					Resource[j].work += Process[i].allocation[j];</span><br><span class="line">					Process[i].finish = <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; process; k++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (safe_list[k] == <span class="number">0</span>) &#123;</span><br><span class="line">						safe_list[k] = i + <span class="number">1</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// update();</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;resource; j++)<span class="comment">// i进程 更新所有资源</span></span><br><span class="line">				&#123;</span><br><span class="line">					Resource[j].resource_number += Process[i].allocation[j];</span><br><span class="line">					Process[i].allocation[j] = <span class="number">0</span>;</span><br><span class="line">					Process[i].need[j] = Process[i].max[j];</span><br><span class="line">				&#125;</span><br><span class="line">				show_me();</span><br><span class="line">				_isSafe();	<span class="comment">//递归处理</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=================================================================</span></span><br><span class="line"><span class="comment">    银行家算法入口</span></span><br><span class="line"><span class="comment">=================================================================*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">banker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	backup();</span><br><span class="line">	<span class="keyword">if</span> (allocation() == <span class="literal">false</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span> (is_safe()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n分配成功！"</span></span><br><span class="line">        		<span class="string">"\n----------------------------------"</span>);</span><br><span class="line">        show_me();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		re_backup();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=================================================================</span></span><br><span class="line"><span class="comment">    主程序入口</span></span><br><span class="line"><span class="comment">=================================================================*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	zero();</span><br><span class="line">	init();</span><br><span class="line">	init_allocation();</span><br><span class="line">	show_me();</span><br><span class="line">	backup();</span><br><span class="line">	is_safe();</span><br><span class="line">	re_backup();</span><br><span class="line">	banker();</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">printf</span>(<span class="string">"\n若需继续分配"</span>))</span><br><span class="line">        banker();</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法三：LRU页面置换算法"><a href="#算法三：LRU页面置换算法" class="headerlink" title="算法三：LRU页面置换算法"></a>算法三：LRU页面置换算法</h3><blockquote>
<p>百度百科：它的实质是，当需要置换一页时，选择在之前一段时间里最久没有使用过的页面予以置换。这种算法就称为最久未使用算法</p>
</blockquote>
<h4 id="页面置换是什么"><a href="#页面置换是什么" class="headerlink" title="页面置换是什么"></a>页面置换是什么</h4><p>页面置换是指进程一部分在内存中，一部分在外存中，在cup需要调用外存中的一些内容时候，需要进行页面置换操作，而LRU置换算法根据的是在之前的调换序列中总结出的规律，并加以预测。<br>最近最久未使用比较的是<strong>当前页框中</strong>的所有进程，在这次调用之前最后一个第一次被用到的是谁，换句话说<strong>在一段时间内没有使用过的进程会被换走</strong>，这样的操作的优点是系统观察到最近使用到的进程很可能会再次被使用到，因此会换掉很久没有使用到的页面。</p>
<p>它的<strong>缺点</strong>是需要大量硬件的支持，并且很有可以在调换后刚好久使用到了这个页面，容易造成循环多次替换<br><strong>优点</strong>是简单有效，寻找的速度相对较快，节省了查找的时间。</p>
<h4 id="LRU源代码"><a href="#LRU源代码" class="headerlink" title="LRU源代码"></a>LRU源代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*=================================================================</span></span><br><span class="line"><span class="comment">OS algorithm of Least Recently Used</span></span><br><span class="line"><span class="comment">2018.6.13   jelech      start writing</span></span><br><span class="line"><span class="comment">2018.6.14   jelech      add the OP algorithm</span></span><br><span class="line"><span class="comment">2018.6.19   jelech      modify the algorithm</span></span><br><span class="line"><span class="comment">=================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=================================================================</span></span><br><span class="line"><span class="comment">    数据定义</span></span><br><span class="line"><span class="comment">=================================================================*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_PROC_NUM = <span class="number">25</span>;<span class="comment">//定义最大进程数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_PHYB_NUM = <span class="number">5</span>;<span class="comment">//定义最大物理块数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PhysicalBlockList</span>// 输入的进程序列</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	<span class="keyword">int</span> runArray[MAX_PROC_NUM];</span><br><span class="line">&#125;PBL;</span><br><span class="line"><span class="keyword">int</span> phyBlockNum;<span class="comment">// 物理块数</span></span><br><span class="line"><span class="keyword">int</span> L[MAX_PHYB_NUM];<span class="comment">//物理块几何</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">intput</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=================================================================</span></span><br><span class="line"><span class="comment">    输入函数：对物理块数、进程序列、进程数的输入函数</span></span><br><span class="line"><span class="comment">=================================================================*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"请输入物理块数："</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;phyBlockNum);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"请输入序列总数："</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;PBL.num);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n请输入访问序列:"</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= PBL.num; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;PBL.runArray[i]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=================================================================</span></span><br><span class="line"><span class="comment">    打印当前页框序列</span></span><br><span class="line"><span class="comment">=================================================================*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= phyBlockNum; ++i)	<span class="comment">// 遍历当前页框中的所有进程代码</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">" %d"</span>, L[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=================================================================</span></span><br><span class="line"><span class="comment">    最近最久未使用算法</span></span><br><span class="line"><span class="comment">=================================================================*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solvebylru</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> replacePos = <span class="number">1</span>; <span class="comment">// 替代位置</span></span><br><span class="line">	<span class="keyword">int</span> zeroPos = <span class="number">1</span>;<span class="comment">//是否满了的位置</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"LRU算法序列:\n"</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= PBL.num; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">bool</span> flag = <span class="literal">true</span>;	<span class="comment">// 标志为是否找到了进程的位置</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= phyBlockNum; ++j)<span class="comment">// 找到这个进程的位置</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(PBL.runArray[i] == L[j])</span><br><span class="line">			&#123;</span><br><span class="line">				flag = <span class="literal">false</span>;</span><br><span class="line">				replacePos++;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(flag)<span class="comment">//没有找到</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(zeroPos &lt;= phyBlockNum)	<span class="comment">// 如果首次加入页框还没有满，直接加入</span></span><br><span class="line">			&#123;</span><br><span class="line">				L[zeroPos] = PBL.runArray[i];</span><br><span class="line">				zeroPos++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;<span class="comment">//遍历所有的页框中的进程，找到也框中应该被替换掉的位置</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= phyBlockNum; ++j)	</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(L[j] == PBL.runArray[replacePos])</span><br><span class="line">					&#123;</span><br><span class="line">						L[j] = PBL.runArray[i];</span><br><span class="line">						replacePos++;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法四：磁盘调度算法"><a href="#算法四：磁盘调度算法" class="headerlink" title="算法四：磁盘调度算法"></a>算法四：磁盘调度算法</h3><blockquote>
<p>百度百科：磁盘调度在多道程序设计的计算机系统中，各个进程可能会不断提出不同的对磁盘进行读/写操作的请求。由于有时候这些进程的发送请求的速度比磁盘响应的还要快，因此我们有必要为每个磁盘设备建立一个等待队列</p>
</blockquote>
<h4 id="什么是磁盘调度"><a href="#什么是磁盘调度" class="headerlink" title="什么是磁盘调度"></a>什么是磁盘调度</h4><p>现在的机械硬盘大部分可以形容为许多片结合而成，在进程访问的时候，硬盘的磁盘指针就会寻找到指定的位置进行读取数据。我们这里简单的把它理解为一个光盘的读取，因此，每次访问的时候，会传送给它一个序列，每个值都代表着要访问的指定的位置。<br>然而，如果按照这个普通序列进行访问的话，就会造成指针反复的划过，时间大部分流失在了这里。因此构造一个良好的算法来保证他能快速的调用。</p>
<p><strong>电梯扫描算法(Scan)</strong>正如他的名字一样，它会像电梯一样上升和下降。在算法的第一步会将这个序列进行排序，与当前指针进行比较，选择上升还是下降，在按照这个方向，一直走到头，在反向进行访问。这就是Scan算法。</p>
<h4 id="Scan算法源代码"><a href="#Scan算法源代码" class="headerlink" title="Scan算法源代码"></a>Scan算法源代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*=================================================================</span></span><br><span class="line"><span class="comment">OS algorithm of Disk scheduling algorithm</span></span><br><span class="line"><span class="comment">2018.6.20   jelech      start writing</span></span><br><span class="line"><span class="comment">=================================================================*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=================================================================</span></span><br><span class="line"><span class="comment">    数据定义</span></span><br><span class="line"><span class="comment">=================================================================*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_PROC_NUM = <span class="number">50</span>;<span class="comment">// 最大进程数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mgnum;<span class="comment">//磁盘访问数</span></span><br><span class="line"><span class="keyword">int</span> PBL[MAX_PROC_NUM];<span class="comment">//磁盘访问序列:存放位置信息</span></span><br><span class="line"><span class="keyword">int</span> PBL_bk[MAX_PROC_NUM];<span class="comment">//磁盘访问序列:存放位置信息(备份)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mgpos=<span class="number">0</span>;<span class="comment">// 初始磁头位置</span></span><br><span class="line"><span class="keyword">int</span> putArray[MAX_PROC_NUM];<span class="comment">// 输出序列</span></span><br><span class="line"><span class="keyword">int</span> mvsum=<span class="number">0</span>;<span class="comment">// 总移动数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*=================================================================</span></span><br><span class="line"><span class="comment">    数据输入</span></span><br><span class="line"><span class="comment">=================================================================*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入磁盘访问数:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;mgnum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入访问序列:"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= mgnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;PBL[i]);</span><br><span class="line">        PBL_bk[i] = PBL[i]; <span class="comment">// 输入时，进行备份</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入磁头位置:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;mgpos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=================================================================</span></span><br><span class="line"><span class="comment">    数据输出</span></span><br><span class="line"><span class="comment">=================================================================*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n总寻道长度：%d\t平均寻道长度：%.2f\n寻道序列："</span>, mvsum, mvsum*<span class="number">1.0</span>/mgnum);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mgnum; ++i)    <span class="comment">// 遍历所有序列进行输出</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(i != mgnum<span class="number">-1</span> ? <span class="string">"%d "</span>:<span class="string">"%d\n"</span>, putArray[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=================================================================</span></span><br><span class="line"><span class="comment">    主函数入口</span></span><br><span class="line"><span class="comment">=================================================================*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solvebyScan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= mgnum; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		PBL[i] = PBL_bk[i];</span><br><span class="line">	&#125;</span><br><span class="line">	sort(PBL+<span class="number">1</span>, PBL+<span class="number">1</span>+mgnum);</span><br><span class="line">	<span class="keyword">int</span> rpl = <span class="number">1</span>, rpr = mgnum;	<span class="comment">// 下一次要替换的位置：左、右</span></span><br><span class="line">  <span class="keyword">while</span>(PBL[rpl] &lt; mgpos) rpl++;</span><br><span class="line">  rpr = rpl;	<span class="comment">//找到的是比初始指针大的第一个</span></span><br><span class="line">  rpl = rpr<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  mvsum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> mlen = mgpos;</span><br><span class="line">  <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(rpr &lt;= mgnum)&#123;	<span class="comment">// 默认先向上</span></span><br><span class="line">    putArray[pos] = PBL[rpr];</span><br><span class="line">    rpr++,pos++;</span><br><span class="line">  &#125;</span><br><span class="line">  mvsum += (PBL[rpr<span class="number">-1</span>] - mgpos);</span><br><span class="line">  <span class="keyword">while</span>(rpl &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    putArray[pos] = PBL[rpl];</span><br><span class="line">    rpl--,pos++;</span><br><span class="line">  &#125;</span><br><span class="line">  mvsum += (mgpos + PBL[rpl+<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\nSCAN算法："</span>);</span><br><span class="line">  print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="专用术语"><a href="#专用术语" class="headerlink" title="专用术语"></a>专用术语</h3><p>系统吞吐量(system throughput)    并行(paralled)    并发(concurrence)    同步 (Synchronization)<br>临界资源(critical resource)    临界区(critical section)    进程互斥(process mutualexclusion)    地址映射(address mapping)</p>
<p>碎片(fragmentation)    多程序设计(Multiprogramming)    分段(Segmentation)    批处理技术(batch processing technic)</p>
<p>异步(asynchronism)    模块化(modularization)    内聚性(cohesion)    耦合度(coupling)</p>
<p>分层结构(layered architecture)    命令接口(command  interface)    顺序文件(sequential file)    异步操作(asynchronous operation)</p>
<p>直接存储器存取(Direct Memory Address)    动态(Dynamic)    抖动(thrashing)    时间片(time slicing)(Quantum)</p>
<p>文件扩展名 (File Extension)    文件属性 (Attribute)    互斥(Mutexes)    引导程序 (Bootstrap)</p>
<p>位示图 (Bitmaps)    引导参数 Boot Parameter    规范模式 Canonical Mode    请调 Demand Paging</p>

            

        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">标签</span><br>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/笔记/">笔记</a> <a class="tag tag--primary tag--small t-link" href="/tags/算法/">算法</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/posts/40608/" data-tooltip="用Hexo + GitPage建立博客遇到的bug和解决办法" aria-label="上一篇: 用Hexo + GitPage建立博客遇到的bug和解决办法">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/posts/43282/" data-tooltip="最近的一篇随笔" aria-label="下一篇: 最近的一篇随笔">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="分享">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://www.jelech.cn/posts/27676/" title="分享到 Facebook">
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http://www.jelech.cn/posts/27676/" title="分享到 Twitter">
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=http://www.jelech.cn/posts/27676/" title="分享到 Google+">
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
                <style media="screen">.v .vwrap{overflow: inherit;}</style>
                <div id="vcomment"></div>
                <a href="posts/27676/#vcomment" class="disqus-comment-count"></a>
                <span class="valine-comment-count" data-xid="posts/27676/"></span>
                <span> Comment</span>
            
        
    </div>
</article>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2018 Jelech. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/posts/40608/" data-tooltip="用Hexo + GitPage建立博客遇到的bug和解决办法" aria-label="上一篇: 用Hexo + GitPage建立博客遇到的bug和解决办法">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/posts/43282/" data-tooltip="最近的一篇随笔" aria-label="下一篇: 最近的一篇随笔">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="分享">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://www.jelech.cn/posts/27676/" title="分享到 Facebook">
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http://www.jelech.cn/posts/27676/" title="分享到 Twitter">
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=http://www.jelech.cn/posts/27676/" title="分享到 Google+">
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                <div id="share-options-bar" class="share-options-bar" data-behavior="4">
    <i id="btn-close-shareoptions" class="fa fa-times"></i>
    <ul class="share-options">
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://www.jelech.cn/posts/27676/">
                    <i class="fab fa-facebook" aria-hidden="true"></i><span>分享到 Facebook</span>
                </a>
            </li>
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=http://www.jelech.cn/posts/27676/">
                    <i class="fab fa-twitter" aria-hidden="true"></i><span>分享到 Twitter</span>
                </a>
            </li>
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="https://plus.google.com/share?url=http://www.jelech.cn/posts/27676/">
                    <i class="fab fa-google-plus" aria-hidden="true"></i><span>分享到 Google+</span>
                </a>
            </li>
        
    </ul>
</div>

            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.jpg" alt="作者的图片">
        
            <h4 id="about-card-name">Jelech</h4>
        
            <div id="about-card-bio"><p>putty本无树,MinGW亦非台</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br>
                <p>在校大学生一枚</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br>
                CHINA.HRB.STU
            </div>
        

        
            <div id="about-card-job">
                <i class="fa fa-envelope"></i>
                <br>
                jelech@hotmail.com
            </div>
        

        
            <div id="about-card-job">
                <i class="fa fa-phone-square"></i>
                <br>
                18.......6
            </div>
        


    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-vufjrm3fmbuttogo1hxuu0w9w0sesk5iyysjuguc2hdhufot9szxg8twijry.min.js"></script>
<!--SCRIPTS END-->

    
        
        <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js" charset="utf-8"></script>
        <script src="//unpkg.com/valine@latest/dist/Valine.min.js" charset="utf-8"></script>
        <script>
            var notify = 'false' == true ? true : false;
            var verify = 'false' == true ? true : false;
            var GUEST_INFO = ['nick','mail','link'];
            var guest_info = 'nick,mail,link'.split(',').filter(function(item){
                return GUEST_INFO.indexOf(item) > -1;
            });

            guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
            window.valine = new Valine({
                el:'#vcomment',
                notify:notify,
                verify:verify,
                appId:'rwwVeUe3kpfbc0OkoxmgnTKM-gzGzoHsz',
                appKey:'FcDDW6bpbs5QmH3A1B2Aqmae',
                placeholder:'Just so so',
                avatar:'mm',
                guest_info:guest_info,
                pageSize:'10'
            });
        </script>
    



    </body>
</html>
