<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jelech的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.jelech.cn/"/>
  <updated>2019-05-26T02:38:51.738Z</updated>
  <id>http://www.jelech.cn/</id>
  
  <author>
    <name>Jelech</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>短到超乎想象！！！</title>
    <link href="http://www.jelech.cn/posts/30301/"/>
    <id>http://www.jelech.cn/posts/30301/</id>
    <published>2019-05-25T13:09:57.000Z</published>
    <updated>2019-05-26T02:38:51.738Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><a id="more"></a><h1 id="快排短到了15行"><a href="#快排短到了15行" class="headerlink" title="快排短到了15行"></a>快排短到了15行</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> curPos = l, tempVal = nums[l]; <span class="comment">// curPos代表前面的数都是小于nums[l]的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; tempVal)</span><br><span class="line">            swap(nums[i], nums[++curPos]);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums[l], nums[curPos]);</span><br><span class="line">    quickSort(nums, l, curPos - <span class="number">1</span>);</span><br><span class="line">    quickSort(nums, curPos + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="大数乘法短到了22行"><a href="#大数乘法短到了22行" class="headerlink" title="大数乘法短到了22行"></a>大数乘法短到了22行</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">ans</span><span class="params">(<span class="string">""</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiBigIntegerDFS</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> num, <span class="keyword">const</span> <span class="built_in">string</span> &amp;a, <span class="keyword">const</span> <span class="built_in">string</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>, k = i, tempa, tempb;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = i, j = <span class="number">0</span>; k &gt; <span class="number">0</span>; k--, j++) &#123; <span class="comment">// 把所有个数位长度相等的加一起，得到这一位的答案</span></span><br><span class="line">        tempa = tempb = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(k &lt;= b.size()) tempb = b[k - <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; a.size()) tempa = a[j] - <span class="string">'0'</span>;</span><br><span class="line">        num += tempa * tempb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i) multiBigIntegerDFS(i - <span class="number">1</span>, num / <span class="number">10</span>, a, b);</span><br><span class="line">    ans += num % <span class="number">10</span> + <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiBigInteger</span><span class="params">(<span class="built_in">string</span> &amp;a, <span class="built_in">string</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">short</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(*a.begin() == <span class="string">'-'</span>) flag *= <span class="number">-1</span>, a.erase(a.begin());<span class="comment">// 处理正负号</span></span><br><span class="line">    <span class="keyword">if</span>(*b.begin() == <span class="string">'-'</span>) flag *= <span class="number">-1</span>, b.erase(b.begin());</span><br><span class="line">    multiBigIntegerDFS(a.size() + b.size() - <span class="number">1</span>, <span class="number">0</span>, a, b);</span><br><span class="line">    <span class="keyword">while</span>(*ans.begin() == <span class="string">'0'</span>) ans.erase(ans.begin()); <span class="comment">// 处理前导0</span></span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">-1</span>) ans.insert(ans.begin(), <span class="string">'-'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.jelech.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="笔记" scheme="http://www.jelech.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="算法" scheme="http://www.jelech.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>今日信息</title>
    <link href="http://www.jelech.cn/posts/58264/"/>
    <id>http://www.jelech.cn/posts/58264/</id>
    <published>2019-05-17T12:31:17.000Z</published>
    <updated>2019-05-17T08:22:30.403Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="欢迎参观我的博客，这篇文章需要密码才能阅读哦 O(∩_∩)O(点我一下)" />    <label for="pass">欢迎参观我的博客，这篇文章需要密码才能阅读哦 O(∩_∩)O(点我一下)</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      欢迎参观我的博客，O(∩_∩)O但是这篇文章是私有的哦&lt;/br&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://www.jelech.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://www.jelech.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Redis学习（一）</title>
    <link href="http://www.jelech.cn/posts/4539/"/>
    <id>http://www.jelech.cn/posts/4539/</id>
    <published>2019-05-08T03:15:09.000Z</published>
    <updated>2019-05-08T04:26:55.961Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><a id="more"></a><h1 id="Redis-key-value数据库（一）"><a href="#Redis-key-value数据库（一）" class="headerlink" title="Redis key-value数据库（一）"></a>Redis key-value数据库（一）</h1><blockquote><p>基础使用移植到单独的一篇文章中：《速查Redis》</p></blockquote><h2 id="数据结构与对象"><a href="#数据结构与对象" class="headerlink" title="数据结构与对象"></a>数据结构与对象</h2><blockquote><p>redis中实现了一些redis自用的、快速的数据结构。他们组成了redis内部的运行结构，也展现了redis是如何存储key-value值的。他们分别为：</p></blockquote><ul><li>简单动态字符串 | 对c语言字符串的封装，优化了许多特性</li><li>链表 | 双向链表</li><li>字典 | 哈希字典，可以进行扩展收缩操作</li><li>跳跃表 | 快查节点，有序集合的底层与内部数据结构中使用</li><li>整数集合 | 集合键的底层实现，只支持升级操作</li><li>压缩列表 | 列表键与哈希键的底层实现</li><li>对象 | 对以上结构进行包装，每个两种以上的编码方式，自带内存回收机制</li></ul><blockquote><p>之后再详细更新数据结构的内容</p></blockquote><h2 id="单机数据库操作"><a href="#单机数据库操作" class="headerlink" title="单机数据库操作"></a>单机数据库操作</h2><blockquote><p>基础使用移植到单独的一篇文章中：《速查Redis》</p></blockquote><ol><li>数据库由dict和expires两个字典构成，dict负责保存键值对，expires负责键的过期时间</li><li>主服务器发现过期键后会给所有的从服务器发送DEL命令，显式地删除键。而从服务器发现过期键后并不会删除，而是等待主节点发来DEL命令</li></ol><h4 id="过期键的删除策略"><a href="#过期键的删除策略" class="headerlink" title="过期键的删除策略"></a>过期键的删除策略</h4><ul><li><p>定时删除：（主动）创建一个定时器，让键在<strong>过期时间来临</strong>时，立即对键进行删除操作</p></li><li><p>惰性删除：（被动）放任过期的键不管，只有在对键进行访问前，进行检查。如果过期，则删除并返回null</p></li><li><p>定期删除：（主动）<strong>每隔一段时间</strong>对数据库进行全盘检查，删除过期的键</p><p>  而我们常使用的是第二个与第三个的结合</p></li></ul><h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><blockquote><p>Redis是保存在内存上的数据库，如果断电，则数据会被完全清除。为了持久化数据，出现了RDB持久化技术。他的工作方法是对内存上的键值对数据进行二进制压缩后，写入到磁盘中。</p></blockquote><p><code>SAVE</code>停止redis现在的工作，进行RDB保存，数据量大的时候会让数据库怠机</p><p><code>BGSAVE</code>创建一个子进程进行RDB保存，父进程继续进行数据接收返回操作，但操作的数据会暂时保存在RDB缓存空间</p><p><strong>自动保存</strong>则需要在配置文件中设置save选线项<br>比如<br>save 900 1代表如果900秒之内有进行1次操作，就进行保存。当然，他是可以设置多个的。</p><p>如果不设置，redis会有默认的<br><code>save 900 1</code><br><code>save 300 10</code><br><code>save 60 10000</code></p><p>​    </p><p>dirty计数器记录了距离上一次save/bgsave操作经历了多少次操作，lastsave保存的是时间</p><h4 id="RDB文件的结构"><a href="#RDB文件的结构" class="headerlink" title="RDB文件的结构"></a>RDB文件的结构</h4><table><thead><tr><th style="text-align:left">REDIS</th><th>db_version</th><th>databases</th><th>EOF</th><th>check_sum</th></tr></thead><tbody><tr><td style="text-align:left">5字节</td><td>4字节</td><td>数据库大小字节</td><td>1字节</td><td>8字节</td></tr><tr><td style="text-align:left">字符’REDIS’</td><td>0006版本号</td><td>数据库号与保存的键值对</td><td>结束符</td><td>校验和</td></tr><tr><td style="text-align:left"></td><td></td><td>SELECTDB 表示接下来要读一个数据库号</td><td></td><td></td></tr><tr><td style="text-align:left"></td><td></td><td>db_number 数据库号</td><td></td><td></td></tr><tr><td style="text-align:left"></td><td></td><td>key_value_pairs键值对<br><code>[EXPIRESTIME_MS/]TYPE/key/values</code></td><td></td></tr></tbody></table><h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><blockquote><p>翻书更新累了。。休一下</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.jelech.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://www.jelech.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="redis" scheme="http://www.jelech.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>关于高并发和秒杀系统的讨论</title>
    <link href="http://www.jelech.cn/posts/10156/"/>
    <id>http://www.jelech.cn/posts/10156/</id>
    <published>2019-05-01T11:44:47.000Z</published>
    <updated>2019-05-01T13:35:26.528Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><a id="more"></a><p>此次高并发的讨论先局限于对于设计一个大量请求的秒杀系统。</p><h4 id="何为高并发"><a href="#何为高并发" class="headerlink" title="何为高并发"></a>何为高并发</h4><ul><li>在用户访问请求时，对于一个单机单核的服务器的接受的线性的。那么如果有大量的用户同时访问，那么此时的服务器就需要短时间内接受和处理大量请求。而解决这样的问题，我们可以通过启用多个线/进程，并发地解决问题。</li><li>但是对于这个问题来说，一个电脑的CPU是有限的，那么再多一点的进程，最终也同样会造成服务器的压力。</li></ul><blockquote><p>像12306、各种电商平台的秒杀活动那样。对于一个有限的资源，也需要考虑资源的增减。</p></blockquote><h4 id="讨论的问题"><a href="#讨论的问题" class="headerlink" title="讨论的问题"></a>讨论的问题</h4><ol><li><p>高并发的瓶颈（一）程序设计</p><p> 服务器的优化可以分为三个方向，请求接收、请求处理、请求返回。</p><p> 请求处理中包括数据查询、数据处理。第一，对于高并发的秒杀系统来说，许多数据都是热数据，会被多个用户多次访问。那么这些数据就应该被放到缓存中，包括但不限于redis(yes，非常好用)。第二，数据处理依赖的是服务器程序的优化，这就要看算法的性能了，建议的是能尽量少传数据，少复制数据。</p></li><li><p>高并发的瓶颈（二）服务器CPU</p><p> 无论程序优化再多，一个服务器的CPU资源是有上限的。</p><p> 解决的一方面可以直接增加服务器的数量以1:1线性增加并发度，这时候就需要设计集群，但是<u>切记</u>拒绝假的分布式，比如：前端服务器是可以独立存在的，但是都依赖集中的一个数据库或者缓存系统，最后，一定是集中的那个数据库或者缓存系统受不了，同样无法做到一个好的分布式。</p><p> 第二方面，逻辑处理中，把速度快且提前中断的逻辑放在最前面，比如：验证登录，验证问答。做分布式方案的时候，尽量把资源调用放在最近的地方。</p><p> 第三方面，不要出现跨机房网络请求，不要出现跨机房网络请求，不要出现跨机房网络请求，重要的事情说三遍。</p></li><li><p>保证库存原子性</p><p> 可以用数据库操作，由于使用了锁，满足了原子性。但是性能差，访问慢。</p><p> 可以用消息队列，订单全部放到一个消息队列中，服务器一个一个进行处理。但用户等待时间太长，不同请求会因前面的请求等待很久。</p><p> <u><strong>redis递减</strong></u>性能极好。redis-&gt;incrby(‘product’, -1)操作首先是原子性的(应该说redis的操作都是)，并且内存中访问使得性能很好，再加上redis又自带集群操作。何乐而不为？</p></li><li><p>集群数据一致性</p><p> 现在一种解决办法是通过把多个资源散列到多个集群中，再在外部加一个中控服务来平衡多个集群的资源，这样就能解决出现不同集群的访问差异过大导致的数据差异过多</p></li><li><p>机器人抢怎么办</p><p> 添加IP限制判断，强制用户登录，提交订单时引入各种验证码、问答。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="技术探析" scheme="http://www.jelech.cn/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E6%9E%90/"/>
    
    
      <category term="redis" scheme="http://www.jelech.cn/tags/redis/"/>
    
      <category term="高并发" scheme="http://www.jelech.cn/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>sscanf中的正则表达式</title>
    <link href="http://www.jelech.cn/posts/20161/"/>
    <id>http://www.jelech.cn/posts/20161/</id>
    <published>2019-03-10T13:09:33.000Z</published>
    <updated>2019-03-11T02:09:40.446Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><a id="more"></a><h3 id="1-简易用法"><a href="#1-简易用法" class="headerlink" title="1.简易用法"></a>1.简易用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;china beijing 123&quot;;</span><br><span class="line">ret = sscanf(string, &quot;%s %s %d&quot;, buf1, buf2, &amp;digit);</span><br><span class="line">printf(&quot;1.string=%s\n&quot;, string);</span><br><span class="line">printf(&quot;1.ret=%d, buf1=%s, buf2=%s, digit=%d\n\n&quot;, ret, buf1, buf2, digit);</span><br></pre></td></tr></table></figure><ul><li>执行结果:</li><li>1.ret=3, buf1=china, buf2=beijing, digit=123</li><li>可以看出,sscanf的返回值是读取的参数个数</li></ul><h3 id="2-取指定长度的字符串"><a href="#2-取指定长度的字符串" class="headerlink" title="2.取指定长度的字符串"></a>2.取指定长度的字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;123456789&quot;;</span><br><span class="line">sscanf(string, &quot;%5s&quot;, buf1);</span><br><span class="line">printf(&quot;2.string=%s\n&quot;, string);</span><br><span class="line">printf(&quot;2.buf1=%s\n\n&quot;, buf1);</span><br></pre></td></tr></table></figure><ul><li>执行结果:</li><li>2.buf1=12345</li></ul><h3 id="3-取到指定字符为止的字符串"><a href="#3-取到指定字符为止的字符串" class="headerlink" title="3.取到指定字符为止的字符串"></a>3.取到指定字符为止的字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;123/456&quot;;</span><br><span class="line">sscanf(string, &quot;%[^/]&quot;, buf1);</span><br><span class="line">printf(&quot;3.string=%s\n&quot;, string);</span><br><span class="line">printf(&quot;3.buf1=%s\n\n&quot;, buf1);</span><br></pre></td></tr></table></figure><ul><li>执行结果:</li><li>3.buf1=123</li></ul><h3 id="4-取到指定字符集为止的字符串"><a href="#4-取到指定字符集为止的字符串" class="headerlink" title="4.取到指定字符集为止的字符串"></a>4.取到指定字符集为止的字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;123abcABC&quot;;</span><br><span class="line">sscanf(string, &quot;%[^A-Z]&quot;, buf1);</span><br><span class="line">printf(&quot;4.string=%s\n&quot;, string);</span><br><span class="line">printf(&quot;4.buf1=%s\n\n&quot;, buf1);</span><br></pre></td></tr></table></figure><ul><li>执行结果:</li><li>4.buf1=123abc</li></ul><h3 id="5-取仅包含指定字符集的字符串"><a href="#5-取仅包含指定字符集的字符串" class="headerlink" title="5.取仅包含指定字符集的字符串"></a>5.取仅包含指定字符集的字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;0123abcABC&quot;;</span><br><span class="line">sscanf(string, &quot;%[0-9]%[a-z]%[A-Z]&quot;, buf1, buf2, buf3);</span><br><span class="line">printf(&quot;5.string=%s\n&quot;, string);</span><br><span class="line">printf(&quot;5.buf1=%s, buf2=%s, buf3=%s\n\n&quot;, buf1, buf2, buf3);</span><br></pre></td></tr></table></figure><ul><li>执行结果:</li><li>5.buf1=123, buf2=abc, buf3=ABC</li></ul><h3 id="6-获取指定字符中间的字符串"><a href="#6-获取指定字符中间的字符串" class="headerlink" title="6.获取指定字符中间的字符串"></a>6.获取指定字符中间的字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;ios&lt;android&gt;wp7&quot;;</span><br><span class="line">sscanf(string, &quot;%*[^&lt;]&lt;%[^&gt;]&quot;, buf1);</span><br><span class="line">printf(&quot;6.string=%s\n&quot;, string);</span><br><span class="line">printf(&quot;6.buf1=%s\n\n&quot;, buf1);</span><br></pre></td></tr></table></figure><ul><li>执行结果:</li><li>6.buf1=android</li></ul><h3 id="7-指定要跳过的字符串"><a href="#7-指定要跳过的字符串" class="headerlink" title="7.指定要跳过的字符串"></a>7.指定要跳过的字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;iosVSandroid&quot;;</span><br><span class="line">sscanf(string, &quot;%[a-z]VS%[a-z]&quot;, buf1, buf2);</span><br><span class="line">printf(&quot;7.string=%s\n&quot;, string);</span><br><span class="line">printf(&quot;7.buf1=%s, buf2=%s\n\n&quot;, buf1, buf2);</span><br></pre></td></tr></table></figure><ul><li>执行结果:</li><li>7.buf1=ios, buf2=android</li></ul><h3 id="8-分割以某字符隔开的字符串"><a href="#8-分割以某字符隔开的字符串" class="headerlink" title="8.分割以某字符隔开的字符串"></a>8.分割以某字符隔开的字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">字符串取道&apos;-&apos;为止,后面还需要跟着分隔符&apos;-&apos;,</span><br><span class="line">起到过滤作用,有点类似于第7点</span><br><span class="line">string = &quot;android-iphone-wp7&quot;;</span><br><span class="line">sscanf(string, &quot;%[^-]-%[^-]-%[^-]&quot;, buf1, buf2, buf3);</span><br><span class="line">printf(&quot;8.string=%s\n&quot;, string);</span><br><span class="line">printf(&quot;8.buf1=%s, buf2=%s, buf3=%s\n\n&quot;, buf1, buf2, buf3);</span><br></pre></td></tr></table></figure><ul><li>执行结果:</li><li>8.buf1=android, buf2=iphone, buf3=wp7</li></ul><h3 id="9-提取邮箱地址"><a href="#9-提取邮箱地址" class="headerlink" title="9.提取邮箱地址"></a>9.提取邮箱地址</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;Email:beijing@sina.com.cn&quot;;</span><br><span class="line">sscanf(string, &quot;%[^:]:%[^@]@%[^.].%s&quot;, buf1, buf2, buf3, buf4);</span><br><span class="line">printf(&quot;9.string=%s\n&quot;, string);</span><br><span class="line">printf(&quot;9.buf1=%s, buf2=%s, buf3=%s, buf4=%s\n\n&quot;, buf1, buf2, buf3, buf4);</span><br></pre></td></tr></table></figure><ul><li>执行结果:</li><li>9.buf1=Email, buf2=beijing, buf3=sina, buf4=com.cn</li></ul><h3 id="10-过滤掉不想截取或不需要的字符串"><a href="#10-过滤掉不想截取或不需要的字符串" class="headerlink" title="10.过滤掉不想截取或不需要的字符串"></a>10.过滤掉不想截取或不需要的字符串</h3><p>补充在%号后面加一*号,代表过滤这个字符串,不读取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;android iphone wp7&quot;;</span><br><span class="line">sscanf(string, &quot;%s %*s %s&quot;, buf1, buf2);</span><br><span class="line">printf(&quot;10.string=%s\n&quot;, string);</span><br><span class="line">printf(&quot;10.buf1=%s, buf2=%s\n\n&quot;, buf1, buf2);</span><br></pre></td></tr></table></figure><ul><li>执行结果:</li><li>10.android wp7</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.jelech.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="后台开发" scheme="http://www.jelech.cn/tags/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"/>
    
      <category term="c" scheme="http://www.jelech.cn/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>如何自己编写MakeFile</title>
    <link href="http://www.jelech.cn/posts/15789/"/>
    <id>http://www.jelech.cn/posts/15789/</id>
    <published>2019-03-10T09:09:33.000Z</published>
    <updated>2019-03-11T02:11:48.165Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><a id="more"></a><p><a href="https://blog.csdn.net/haoel/article/details/2886" target="_blank" rel="noopener">《跟我一起写 Makefile》- haoel</a></p><h2 id="关于程序的编译和链接"><a href="#关于程序的编译和链接" class="headerlink" title="　　关于程序的编译和链接"></a>　　<strong>关于程序的编译和链接</strong></h2><p>编译时，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（O文件或是OBJ文件）。</p><p>链接时，主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（O文件或是OBJ文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”（Library File)，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。</p><p>总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error），在VC下，这种错误一般是：Link 2001错误，意思说是说，链接器未能找到函数的实现。你需要指定函数的Object File。</p><p>　　下面我们开始看看如何自己写出makefile。</p><h2 id="Makefile的规则"><a href="#Makefile的规则" class="headerlink" title="　　Makefile的规则"></a>　　<strong>Makefile的规则</strong></h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目标 ： 需要的条件 （注意冒号两边有空格）</span><br><span class="line">    命令　　（注意前面用tab键开头）</span><br></pre></td></tr></table></figure><p>　　解释一下：</p><p>　　1 目标可以是一个或多个，可以是Object File，也可以是执行文件，甚至可以是一个标签。</p><p>　　2 需要的条件就是生成目标所需要的文件或目标</p><p>　　3 命令就是生成目标所需要执行的脚本</p><p>　　总结一下，就是说一条makefile规则规定了编译的依赖关系，也就是目标文件依赖于条件，生成规则用命令来描述。<strong>在编译时，如果需要的条件的文件比目标更新的话，就会执行生成命令来更新目标。</strong></p><p>　　下面举个简单的例子说明。如果一个工程有3个头文件，和8个C文件，我们为了完成前面所述的那三个规则，我们的Makefile应该是下面的这个样子的。<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o /</span><br><span class="line">       insert.o search.o files.o utils.o</span><br><span class="line">        cc -o edit main.o kbd.o command.o display.o /</span><br><span class="line">                   insert.o search.o files.o utils.o</span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">        cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">       cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">        cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">        cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">        cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">        cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">        cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">        cc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">        rm edit main.o kbd.o command.o display.o /</span><br><span class="line">           insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure></p><p>　　反斜杠（/）是换行符的意思。将上面的内容写入到Makefile文件中，然后执行make就可以进行编译，执行make clean就可以删除所有目标文件。解释一下，也就是说生成最终的目标文件edit，依赖于一系列的.o目标文件，而这些.o文件又是需要用源文件来编译生成的。</p><p>　　需要注意的是，clean后面没有条件，而clean本身也不是文件，它只不过是一个动作名字，其冒号后什么也没有，那么，make就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。</p><h2 id="make是如何工作的"><a href="#make是如何工作的" class="headerlink" title="　　make是如何工作的"></a>　　<strong>make是如何工作的</strong></h2><p>　　在默认的方式下，也就是我们只输入make命令。那么，</p><p>​    1、make会在当前目录下找名字叫“Makefile”或“makefile”的文件。<br>​    2、如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。<br>​    3、如果edit文件不存在，或是edit所依赖的后面的 .o 文件的文件修改时间要比edit这个文件新，那么，他就会执行后面所定义的命令来生成edit这个文件。<br>​    4、如果edit所依赖的.o文件也不存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。（这有点像一个堆栈的过程）<br>​    5、当然，你的C文件和H文件是存在的啦，于是make会生成 .o 文件，然后再用 .o 文件生命make的终极任务，也就是执行文件edit了。</p><h2 id="makefile中使用变量"><a href="#makefile中使用变量" class="headerlink" title="　　makefile中使用变量"></a>　　<strong>makefile中使用变量</strong></h2><p>　　前面的知识已经足以让你自己完成一个简单的makefile了，不过makefile的精妙之处远不止如此，下面来看看如何在makefile中使用变量吧。</p><p>　　在上面的例子中，先让我们看看edit的规则：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o /</span><br><span class="line">            insert.o search.o files.o utils.o</span><br><span class="line">      cc -o edit main.o kbd.o command.o display.o /</span><br><span class="line">                 insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure><p>　　我们可以看到[.o]文件的字符串被重复了两次，如果我们的工程需要加入一个新的[.o]文 件，那么我们需要在两个地方加（应该是三个地方，还有一个地方在clean中）。当然，我们的makefile并不复杂，所以在两个地方加也不累，但如果 makefile变得复杂，那么我们就有可能会忘掉一个需要加入的地方，而导致编译失败。所以，为了makefile的易维护，在makefile中我们 可以使用变量。makefile的变量也就是一个字符串，理解成C语言中的宏可能会更好。</p><p>　　于是，我们使用变量objects<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o /</span><br><span class="line">            insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure></p><p>　　这样一来，原来的makefile变成如下的样子：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o /</span><br><span class="line">          insert.o search.o files.o utils.o</span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">        cc -o edit <span class="variable">$(objects)</span></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">        cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">        cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">        cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">        cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">        cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">        cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">        cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">        cc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">        rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure></p><p>　　这样看起来方便多了吧，也更加省事了。如果有新的.o文件怎么办？当然是在objects里面添加了，这样只需要一处改变，很方便吧。</p><h2 id="让make自动推导"><a href="#让make自动推导" class="headerlink" title="　　让make自动推导"></a>　　<strong>让make自动推导</strong></h2><p>　　GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。</p><p>　　只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一 个whatever.o，那么whatever.c，就会是whatever.o的依赖文件。并且 cc -c whatever.c 也会被推导出来，于是，我们的makefile再也不用写得这么复杂。我们的是新的makefile又出炉了。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o /</span><br><span class="line">          insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">        cc -o edit <span class="variable">$(objects)</span></span><br><span class="line">main.o : defs.h</span><br><span class="line">kbd.o : defs.h command.h</span><br><span class="line">command.o : defs.h command.h</span><br><span class="line">display.o : defs.h buffer.h</span><br><span class="line">insert.o : defs.h buffer.h</span><br><span class="line">search.o : defs.h buffer.h</span><br><span class="line">files.o : defs.h buffer.h command.h</span><br><span class="line">utils.o : defs.h</span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">        rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure><p>　　当然，如果你觉得那么多[.o]和[.h]的依赖有点不爽的话，好吧，没有问题，这个对于make来说很容易，谁叫它提供了自动推导命令和文件的功能呢？来看看最新风格的makefile吧。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o /</span><br><span class="line">          insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">        cc -o edit <span class="variable">$(objects)</span></span><br><span class="line">        </span><br><span class="line"><span class="variable">$(objects)</span> : defs.h</span><br><span class="line">kbd.o command.o files.o : command.h</span><br><span class="line">display.o insert.o search.o files.o : buffer.h</span><br><span class="line">clean :</span><br><span class="line">        rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure><p>　　不过话说回来，本人并不推荐这种方法。<strong>虽然简单，但是这种方法破坏了文件本身的依赖关系</strong>。如果文件过多的话，可能你自己都不清楚了。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.jelech.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://www.jelech.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="c编程" scheme="http://www.jelech.cn/tags/c%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>头条实习面&#39;筋&#39;</title>
    <link href="http://www.jelech.cn/posts/35606/"/>
    <id>http://www.jelech.cn/posts/35606/</id>
    <published>2019-03-05T12:31:17.000Z</published>
    <updated>2019-04-07T02:13:42.767Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="欢迎参观我的博客，这篇文章需要密码才能阅读哦 O(∩_∩)O(点我一下)" />    <label for="pass">欢迎参观我的博客，这篇文章需要密码才能阅读哦 O(∩_∩)O(点我一下)</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      欢迎参观我的博客，O(∩_∩)O但是这篇文章是私有的哦&lt;/br&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://www.jelech.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://www.jelech.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="感想" scheme="http://www.jelech.cn/tags/%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>I/O 多路复用</title>
    <link href="http://www.jelech.cn/posts/40254/"/>
    <id>http://www.jelech.cn/posts/40254/</id>
    <published>2019-02-03T04:09:33.000Z</published>
    <updated>2019-03-04T07:47:34.665Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><a id="more"></a><h1 id="IO-多路复用是什么意思？"><a href="#IO-多路复用是什么意思？" class="headerlink" title="IO 多路复用是什么意思？"></a>IO 多路复用是什么意思？</h1><blockquote><p>来源：罗志宇&lt;知乎&gt;：<a href="https://www.zhihu.com/question/32163005/answer/55772739" target="_blank" rel="noopener">链接</a></p><p>假设你是一个机场的空管， 你需要管理到你机场的所有的航线， 包括进港，出港， 有些航班需要放到停机坪等待，有些航班需要去登机口接乘客。 </p><p>你会怎么做? </p><p>最简单的做法，就是你去招一大批空管员，然后每人盯一架飞机， 从进港，接客，排位，出港，航线监控，直至交接给下一个空港，全程监控。 </p><p>那么问题就来了： </p><ul><li>很快你就发现空管塔里面聚集起来一大票的空管员，交通稍微繁忙一点，新的空管员就已经挤不进来了。 </li><li>空管员之间需要协调，屋子里面就1, 2个人的时候还好，几十号人以后 ，基本上就成菜市场了。</li><li>空管员经常需要更新一些公用的东西，比如起飞显示屏，比如下一个小时后的出港排期，最后你会很惊奇的发现，每个人的时间最后都花在了抢这些资源上。 </li></ul><p>现实上我们的空管同时管几十架飞机稀松平常的事情， 他们怎么做的呢？<br>他们用这个东西 </p><p><img src="../../assets/ioMulti1.jpg" alt="img"></p><p>这个东西叫flight progress strip.  每一个块代表一个航班，不同的槽代表不同的状态，然后一个空管员可以管理一组这样的块（一组航班），而他的工作，就是在航班信息有新的更新的时候，把对应的块放到不同的槽子里面。</p><p><em>这个东西现在还没有淘汰哦，只是变成电子的了而已。。</em></p><p>是不是觉得一下子效率高了很多，一个空管塔里可以调度的航线可以是前一种方法的几倍到几十倍。 </p><p>如果你把每一个航线当成一个Sock(I/O 流),  空管当成你的服务端Sock管理代码的话.</p><p><strong>第一种方法就是最传统的多进程并发模型 (每进来一个新的I/O流会分配一个新的进程管理。)</strong><br><strong>第二种方法就是I/O多路复用 (单个线程，通过记录跟踪每个I/O流(sock)的状态，来同时管理多个I/O流 。)</strong></p><p><em>其实“I/O多路复用”这个坑爹翻译可能是这个概念在中文里面如此难理解的原因。所谓的I/O多路复用在英文中其实叫 I/O multiplexing. 如果你搜索multiplexing啥意思，基本上都会出这个图：</em> </p><p><img src="../../assets/ioMulti2.jpg" alt="img"></p><p>于是大部分人都直接联想到”一根网线，多个sock复用” 这个概念，包括上面的几个回答， 其实不管你用多进程还是I/O多路复用， 网线都只有一根好伐。<strong>多个Sock复用一根网线这个功能是在内核＋驱动层实现的</strong>。 </p><p>重要的事情再说一遍： I/O multiplexing 这里面的 multiplexing 指的其实是在单个线程通过记录跟踪每一个Sock(I/O流)的状态(对应空管塔里面的Fight progress strip槽)来同时管理多个I/O流</p><p>. 发明它的原因，是尽量多的提高服务器的吞吐能力。</p><p> 是不是听起来好拗口，看个图就懂了.</p><p><img src="../../assets/ioMulti3.jpg" alt="img"></p><p>在同一个线程里面， 通过拨开关的方式，来同时传输多个I/O流， (学过EE的人现在可以站出来义正严辞说这个叫“时分复用”了）。 </p><p><em>什么，你还没有搞懂“一个请求到来了，nginx使用epoll接收请求的过程是怎样的”， 多看看这个图就了解了。提醒下，ngnix会有很多链接进来， epoll会把他们都监视起来，然后像拨开关一样，谁有数据就拨向谁，然后调用相应的代码处理。</em></p><p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－<br>了解这个基本的概念以后，其他的就很好解释了。 </p><p><strong>select, poll, epoll 都是I/O多路复用的具体的实现，之所以有这三个鬼存在，其实是他们出现是有先后顺序的。</strong> </p><p>I/O多路复用这个概念被提出来以后， select是第一个实现 (1983 左右在BSD里面实现的)。 </p><p>select 被实现以后，很快就暴露出了很多问题。 </p><ul><li>select 会修改传入的参数数组，这个对于一个需要调用很多次的函数，是非常不友好的。</li><li>select 如果任何一个sock(I/O stream)出现了数据，select 仅仅会返回，但是并不会告诉你是那个sock上有数据，于是你只能自己一个一个的找，10几个sock可能还好，要是几万的sock每次都找一遍，这个无谓的开销就颇有海天盛筵的豪气了。</li><li>select 只能监视1024个链接， 这个跟草榴没啥关系哦，linux 定义在头文件中的，参见<em>FD_SETSIZE。</em></li><li>select 不是线程安全的，如果你把一个sock加入到select, 然后突然另外一个线程发现，尼玛，这个sock不用，要收回。对不起，这个select 不支持的，如果你丧心病狂的竟然关掉这个sock, select的标准行为是。。呃。。不可预测的， 这个可是写在文档中的哦.</li></ul><p>​         “If a file descriptor being monitored by select() is closed in another thread, the result is     unspecified”<br>​    霸不霸气</p><p>于是14年以后(1997年）一帮人又实现了poll,  poll 修复了select的很多问题，比如 </p><ul><li>poll 去掉了1024个链接的限制，于是要多少链接呢， 主人你开心就好。</li><li>poll 从设计上来说，不再修改传入数组，不过这个要看你的平台了，所以行走江湖，还是小心为妙。</li></ul><p><strong>其实拖14年那么久也不是效率问题， 而是那个时代的硬件实在太弱，一台服务器处理1千多个链接简直就是神一样的存在了，select很长段时间已经满足需求。</strong> </p><p>但是poll仍然不是线程安全的， 这就意味着，不管服务器有多强悍，你也只能在一个线程里面处理一组I/O流。你当然可以那多进程来配合了，不过然后你就有了多进程的各种问题。</p><p>于是5年以后, 在2002, 大神 Davide Libenzi 实现了epoll. </p><p>epoll 可以说是I/O 多路复用最新的一个实现，epoll 修复了poll 和select绝大部分问题, 比如： </p><ul><li>epoll 现在是线程安全的。 </li><li>epoll 现在不仅告诉你sock组里面数据，还会告诉你具体哪个sock有数据，你不用自己去找了。 </li></ul><p>epoll 当年的patch，现在还在，下面链接可以看得到：<br><a href="https://link.zhihu.com/?target=http%3A//www.xmailserver.org/linux-patches/nio-improve.html" target="_blank" rel="noopener">/dev/epoll Home Page</a></p><p>贴一张霸气的图，看看当年神一样的性能（测试代码都是死链了， 如果有人可以刨坟找出来，可以研究下细节怎么测的). </p><p><img src="../../assets/ioMulti4 .jpg" alt="img"></p><p>横轴Dead connections 就是链接数的意思，叫这个名字只是它的测试工具叫deadcon. 纵轴是每秒处理请求的数量，你可以看到，epoll每秒处理请求的数量基本不会随着链接变多而下降的。poll 和/dev/poll 就很惨了。</p><p>可是epoll 有个致命的缺点。。只有linux支持。比如BSD上面对应的实现是kqueue。 </p><p><em>其实有些国内知名厂商把epoll从安卓里面裁掉这种脑残的事情我会主动告诉你嘛。什么，你说没人用安卓做服务器，尼玛你是看不起p2p软件了啦。</em> </p><p>而ngnix 的设计原则里面， 它会使用目标平台上面最高效的I/O多路复用模型咯，所以才会有这个设置。一般情况下，如果可能的话，尽量都用epoll/kqueue吧。</p><p>详细的在这里:<br><a href="https://link.zhihu.com/?target=http%3A//nginx.org/en/docs/events.html" target="_blank" rel="noopener">Connection processing methods</a></p><p>PS: 上面所有这些比较分析，都建立在大并发下面，如果你的并发数太少，用哪个，其实都没有区别。 如果像是在欧朋数据中心里面的转码服务器那种动不动就是几万几十万的并发，不用epoll我可以直接去撞墙了。</p></blockquote><h1 id="几种高性能IO模型浅析"><a href="#几种高性能IO模型浅析" class="headerlink" title="几种高性能IO模型浅析"></a>几种高性能IO模型浅析</h1><p>来源：白小狮<csdn> <a href="https://blog.csdn.net/baixiaoshi/article/details/48708347" target="_blank" rel="noopener">链接</a></csdn></p><p>服务器端编程经常需要构造高性能的IO模型，常见的IO模型有四种：</p><p>（1）同步阻塞IO（Blocking IO）：即传统的IO模型。</p><p>（2）同步非阻塞IO（Non-blocking IO）：默认创建的socket都是阻塞的，非阻塞IO要求socket被设置为NONBLOCK。注意这里所说的NIO并非Java的NIO（New IO）库。</p><p>（3）IO多路复用（IO Multiplexing）：即经典的Reactor设计模式，有时也称为异步阻塞IO，Java中的Selector和Linux中的epoll都是这种模型。</p><p>（4）异步IO（Asynchronous IO）：即经典的Proactor设计模式，也称为异步非阻塞IO。</p><p><strong>同步和异步</strong>的概念描述的是用户线程与内核的交互方式：同步是指用户线程发起IO请求后需要等待或者轮询内核IO操作完成后才能继续执行；而异步是指用户线程发起IO请求后仍继续执行，当内核IO操作完成后会通知用户线程，或者调用用户线程注册的回调函数。</p><p><strong>阻塞和非阻塞</strong>的概念描述的是用户线程调用内核IO操作的方式：阻塞是指IO操作需要彻底完成后才返回到用户空间；而非阻塞是指IO操作被调用后立即返回给用户一个状态值，无需等到IO操作彻底完成。</p><p>另外，Richard Stevens 在《Unix 网络编程》卷1中提到的基于信号驱动的IO（Signal Driven IO）模型，由于该模型并不常用，本文不作涉及。接下来，我们详细分析四种常见的IO模型的实现原理。为了方便描述，我们统一使用IO的读操作作为示例。</p><h2 id="一、同步阻塞IO"><a href="#一、同步阻塞IO" class="headerlink" title="一、同步阻塞IO"></a>一、同步阻塞IO</h2><p>同步阻塞IO模型是最简单的IO模型，用户线程在内核进行IO操作时被阻塞。</p><p><img src="../../assets/ioMulti5 .jpg" alt="img"></p><p>图1 同步阻塞IO</p><p>如图1所示，用户线程通过系统调用read发起IO读操作，由用户空间转到内核空间。内核等到数据包到达后，然后将接收的数据拷贝到用户空间，完成read操作。</p><p>用户线程使用同步阻塞IO模型的伪代码描述为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">read(socket, buffer);</span><br><span class="line">process(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即用户需要等待read将socket中的数据读取到buffer后，才继续处理接收的数据。整个IO请求的过程中，用户线程是被阻塞的，这导致用户在发起IO请求时，不能做任何事情，对CPU的资源利用率不够。</p><h2 id="二、同步非阻塞IO"><a href="#二、同步非阻塞IO" class="headerlink" title="二、同步非阻塞IO"></a><strong>二、同步非阻塞IO</strong></h2><p>同步非阻塞IO是在同步阻塞IO的基础上，将socket设置为NONBLOCK。这样做用户线程可以在发起IO请求后可以立即返回。</p><p> <img src="../../assets/ioMulti6 .jpg" alt="同步非阻塞IO"></p><p>如图2所示，由于socket是非阻塞的方式，因此用户线程发起IO请求时立即返回。但并未读取到任何数据，用户线程需要不断地发起IO请求，直到数据到达后，才真正读取到数据，继续执行。</p><p>用户线程使用同步非阻塞IO模型的伪代码描述为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">while(read(socket, buffer) != SUCCESS)</span><br><span class="line">;</span><br><span class="line">process(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即用户需要不断地调用read，尝试读取socket中的数据，直到读取成功后，才继续处理接收的数据。整个IO请求的过程中，虽然用户线程每次发起IO请求后可以立即返回，但是为了等到数据，仍需要不断地轮询、重复请求，消耗了大量的CPU的资源。一般很少直接使用这种模型，而是在其他IO模型中使用非阻塞IO这一特性。</p><h2 id="三、IO多路复用"><a href="#三、IO多路复用" class="headerlink" title="三、IO多路复用"></a><strong>三、IO多路复用</strong></h2><p>IO多路复用模型是建立在内核提供的多路分离函数select基础之上的，使用select函数可以避免同步非阻塞IO模型中轮询等待的问题。</p><p><img src="../../assets/ioMulti7 .jpg" alt="img"></p><p>图3 多路分离函数select</p><p>如图3所示，用户首先将需要进行IO操作的socket添加到select中，然后阻塞等待select系统调用返回。当数据到达时，socket被激活，select函数返回。用户线程正式发起read请求，读取数据并继续执行。</p><p>从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。但是，使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在<strong>同一个线程内同时处理多个IO请求的目的</strong>。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。</p><p>用户线程使用select函数的伪代码描述为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">select(socket);</span><br><span class="line">  while(1) &#123;</span><br><span class="line">    sockets = select();</span><br><span class="line">    </span><br><span class="line">    for(socket in sockets) &#123;</span><br><span class="line">      if(can_read(socket)) &#123;</span><br><span class="line">        read(socket, buffer);</span><br><span class="line">        process(buffer);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中while循环前将socket添加到select监视中，然后在while内一直调用select获取被激活的socket，一旦socket可读，便调用read函数将socket中的数据读取出来。</p><p>然而，使用select函数的优点并不仅限于此。虽然上述方式允许单线程内处理多个IO请求，但是每个IO请求的过程还是阻塞的（在select函数上阻塞），平均时间甚至比同步阻塞IO模型还要长。如果用户线程只注册自己感兴趣的socket或者IO请求，然后去做自己的事情，等到数据到来时再进行处理，则可以提高CPU的利用率。</p><p>IO多路复用模型使用了Reactor设计模式实现了这一机制。</p><p><img src="../../assets/ioMulti8 .jpg" alt="img"></p><p>图4 Reactor设计模式</p><p>如图4所示，EventHandler抽象类表示IO事件处理器，它拥有IO文件句柄Handle（通过get_handle获取），以及对Handle的操作handle_event（读/写等）。继承于EventHandler的子类可以对事件处理器的行为进行定制。Reactor类用于管理EventHandler（注册、删除等），并使用handle_events实现事件循环，不断调用同步事件多路分离器（一般是内核）的多路分离函数select，只要某个文件句柄被激活（可读/写等），select就返回（阻塞），handle_events就会调用与文件句柄关联的事件处理器的handle_event进行相关操作。</p><p><img src="../../assets/142333254136604.png" alt="img"></p><p>图5 IO多路复用</p><p>如图5所示，通过Reactor的方式，可以将用户线程轮询IO操作状态的工作统一交给handle_events事件循环进行处理。用户线程注册事件处理器之后可以继续执行做其他的工作（异步），而Reactor线程负责调用内核的select函数检查socket状态。当有socket被激活时，则通知相应的用户线程（或执行用户线程的回调函数），执行handle_event进行数据读取、处理的工作。由于select函数是阻塞的，因此多路IO复用模型也被称为异步阻塞IO模型。注意，这里的所说的阻塞是指select函数执行时线程被阻塞，而不是指socket。一般在使用IO多路复用模型时，socket都是设置为NONBLOCK的，不过这并不会产生影响，因为用户发起IO请求时，数据已经到达了，用户线程一定不会被阻塞。</p><p>用户线程使用IO多路复用模型的伪代码描述为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void UserEventHandler::handle_event() &#123;</span><br><span class="line">  if(can_read(socket)) &#123;</span><br><span class="line">    read(socket, buffer);</span><br><span class="line">    process(buffer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">Reactor.register(new UserEventHandler(socket));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用户需要重写EventHandler的handle_event函数进行读取数据、处理数据的工作，用户线程只需要将自己的EventHandler注册到Reactor即可。Reactor中handle_events事件循环的伪代码大致如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Reactor::handle_events() &#123;</span><br><span class="line">  while(1) &#123;</span><br><span class="line">    sockets = select();</span><br><span class="line">    for(socket in sockets) &#123;</span><br><span class="line">      get_event_handler(socket).handle_event();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>事件循环不断地调用select获取被激活的socket，然后根据获取socket对应的EventHandler，执行器handle_event函数即可。</p><p>IO多路复用是最常使用的IO模型，但是其异步程度还不够“彻底”，因为它使用了会阻塞线程的select系统调用。因此IO多路复用只能称为异步阻塞IO，而非真正的异步IO。</p><h2 id="四、异步IO"><a href="#四、异步IO" class="headerlink" title="四、异步IO"></a><strong>四、异步IO</strong></h2><p>“真正”的异步IO需要操作系统更强的支持。在IO多路复用模型中，事件循环将文件句柄的状态事件通知给用户线程，由用户线程自行读取数据、处理数据。而在异步IO模型中，当用户线程收到通知时，数据已经被内核读取完毕，并放在了用户线程指定的缓冲区内，内核在IO完成后通知用户线程直接使用即可。</p><p>异步IO模型使用了Proactor设计模式实现了这一机制。</p><p><img src="../../assets/151608309061672.jpg" alt="img"></p><p>图6 Proactor设计模式</p><p>如图6，Proactor模式和Reactor模式在结构上比较相似，不过在用户（Client）使用方式上差别较大。Reactor模式中，用户线程通过向Reactor对象注册感兴趣的事件监听，然后事件触发时调用事件处理函数。而Proactor模式中，用户线程将AsynchronousOperation（读/写等）、Proactor以及操作完成时的CompletionHandler注册到AsynchronousOperationProcessor。AsynchronousOperationProcessor使用Facade模式提供了一组异步操作API（读/写等）供用户使用，当用户线程调用异步API后，便继续执行自己的任务。AsynchronousOperationProcessor 会开启独立的内核线程执行异步操作，实现真正的异步。当异步IO操作完成时，AsynchronousOperationProcessor将用户线程与AsynchronousOperation一起注册的Proactor和CompletionHandler取出，然后将CompletionHandler与IO操作的结果数据一起转发给Proactor，Proactor负责回调每一个异步操作的事件完成处理函数handle_event。虽然Proactor模式中每个异步操作都可以绑定一个Proactor对象，但是一般在操作系统中，Proactor被实现为Singleton模式，以便于集中化分发操作完成事件。</p><p><img src="../../assets/142333511475767.png" alt="img"></p><p>图7 异步IO</p><p>如图7所示，异步IO模型中，用户线程直接使用内核提供的异步IO API发起read请求，且发起后立即返回，继续执行用户线程代码。不过此时用户线程已经将调用的AsynchronousOperation和CompletionHandler注册到内核，然后操作系统开启独立的内核线程去处理IO操作。当read请求的数据到达时，由内核负责读取socket中的数据，并写入用户指定的缓冲区中。最后内核将read的数据和用户线程注册的CompletionHandler分发给内部Proactor，Proactor将IO完成的信息通知给用户线程（一般通过调用用户线程注册的完成事件处理函数），完成异步IO。</p><p>用户线程使用异步IO模型的伪代码描述为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void UserCompletionHandler::handle_event(buffer) &#123;</span><br><span class="line">process(buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">aio_read(socket, new UserCompletionHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用户需要重写CompletionHandler的handle_event函数进行处理数据的工作，参数buffer表示Proactor已经准备好的数据，用户线程直接调用内核提供的异步IO API，并将重写的CompletionHandler注册即可。</p><p>相比于IO多路复用模型，异步IO并不十分常用，不少高性能并发服务程序使用IO多路复用模型+多线程任务处理的架构基本可以满足需求。况且目前操作系统对异步IO的支持并非特别完善，更多的是采用IO多路复用模型模拟异步IO的方式（IO事件触发时不直接通知用户线程，而是将数据读写完毕后放到用户指定的缓冲区中）。Java7之后已经支持了异步IO，感兴趣的读者可以尝试使用。</p><h1 id="IO复用函数使用"><a href="#IO复用函数使用" class="headerlink" title="IO复用函数使用"></a>IO复用函数使用</h1><p>参考：风再起时与不羁的风<csdn> <a href="https://blog.csdn.net/chewbee/article/details/78108223" target="_blank" rel="noopener">链接</a></csdn></p><h2 id="select函数"><a href="#select函数" class="headerlink" title="select函数"></a>select函数</h2><p>系统提供Select函数来实现多路复用输入/输出模型，Select系统调用是用来让我们的程序监视多个文件句柄的状态变化。程序会阻塞在select函数上，直到被监视的文件句柄中有一个或多个发生了状态变化。</p><p>函数原型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/select.h&gt;</span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line">int select(int maxfd,</span><br><span class="line"> fd_set *readset,</span><br><span class="line"> fd_set *writeset,</span><br><span class="line"> fd_set *exceptset,</span><br><span class="line"> const struct timeval *timeout)</span><br></pre></td></tr></table></figure></p><p>参数说明：</p><p>maxfd：需要监视的最大的文件描述符值+1；<br>readset：需要检测的可读文件描述符的集合；<br>writeset：需要检测的可写文件描述符的集合<br>exceptset：需要检测的异常文件描述符的集合<br>timeout：超时时间；超时时间有三种情况：<br>NULL：永远等待下去，仅在有一个描述字准备好I/O时才返回；<br>0：立即返回，仅检测描述符集合的状态，然后立即返回，并不等待外部事件的发生；<br>特定的时间值： 如果在指定的时间段里没有事件发生，select将超时返回；<br>函数返回值有三种情况：</p><p>返回0表示超时了；<br>返回-1，表示出错了；<br>返回一个大于0的数，表示文件描述符状态改变的个数；<br>fd_set是一个文件描述符集合，可以通过以下宏来操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FD_CLR(inr fd,fd_set* set)：用来清除文件描述符集合set中相关fd的位</span><br><span class="line">FD_ISSET(int fd,fd_set *set)：用来测试文件描述符集合set中相关fd的位是否为真</span><br><span class="line">FD_SET（int fd,fd_set*set）：用来设置文件描述符集合set中相关fd的位</span><br><span class="line">FD_ZERO（fd_set *set）：用来清除文件描述符集合set的全部位</span><br></pre></td></tr></table></figure><p><strong>Select – summary:</strong></p><ul><li>我们需要在每次调用之前构建每组集合；</li><li>这个函数检查任何 bit 到更高的数字 —— O(n)；</li><li>我们需要遍历文件描述符来检查它是否存在于从 select() 返回的集合中；</li><li>select 的主要优点在于它的可移植性 —— 每个类 unix 操作系统的都有。</li></ul><h2 id="Poll函数"><a href="#Poll函数" class="headerlink" title="Poll函数"></a>Poll函数</h2><p>Poll的处理机制与Select类似，只是Poll选择了pollfd结构体来处理文件描述符的相关操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct pollfd &#123;</span><br><span class="line">    int fd;         /* 文件描述符 */</span><br><span class="line">    short events;   /* 等待的事件 */</span><br><span class="line">    short revents;  /* 实际发生了的事件 */</span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure><p>每一个pollfd结构体都指定了一个文件描述符fd，events代表了需要监听该文件描述的事件掩码，可选的有：</p><p>POLLIN：有数据可读。<br>POLLRDNORM：有普通数据可读。<br>POLLRDBAND：有优先数据可读。<br>POLLPRI：有紧迫数据可读。<br>POLLOUT：写数据不会导致阻塞。<br>POLLWRNORM：写普通数据不会导致阻塞。<br>POLLWRBAND：写优先数据不会导致阻塞。<br>POLLMSGSIGPOLL：消息可用。<br>revents代表文件描述符的操作结果掩码，内核在调用返回时设置这个域。events域中请求的任何事件都可能在revents域中返回，除此之外，revents域还可以包含以下事件：</p><p>POLLER：指定的文件描述符发生错误。<br>POLLHUP：指定的文件描述符挂起事件。<br>POLLNVAL：指定的文件描述符非法。<br>poll的函数原型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># include &lt;poll.h&gt;</span><br><span class="line">int poll (  struct pollfd *fds, </span><br><span class="line"> unsigned int nfds, </span><br><span class="line"> int timeout);</span><br></pre></td></tr></table></figure></p><p>参数说明：</p><p>fds：需要被监视的文件描述符集合；<br>nfds：被监视的文件描述符数量；<br>timeout：超时时间，有三种取值：<br>负数：无限超时，一直等到一个指定事件发生；<br>0：立即返回，并列出准备好的文件描述符；<br>正数：等待指定的时间，单位为毫秒；<br>poll函数与select函数的最大不同之处在于：select函数有最大文件描述符的限制，一般1024个，而poll函数对文件描述符的数量没有限制。但select和poll函数都是通过轮询的方式来查询某个文件描述符状态是否发生了变化，并且需要将整个文件描述符集合在用户空间和内核空间之间来回拷贝，这样随着文件描述符的数量增加，相应的开销也随之增加。</p><p><strong>Poll vs Select</strong></p><ul><li>poll() 不要求用户计算编号最高的文件描述符 +1 的值；</li><li>poll() 对于大值文件描述符更有效。假设我们通过 select() 方法监视一个值为 900 的单个文件描述符 —— 内核将不得不检查传入集合的每个值的每一位，直到第 900 位；</li><li>select() 的文件描述符集合是静态大小的；</li><li>使用 select()，文件描述符集合会在返回时重建，因此每个后续调用都必须重新初始化它们。 poll() 系统调用将输入（events 字段）与输出（revents 字段）分隔开，允许在不更改的情况下重新使用该数组。</li><li>返回时，select() 的 timeout 参数未定义。 可移植性代码需要重新初始化它，这不是pselect() 的问题；</li><li>select() 更具可移植性，因为某些 Unix 系统不支持 poll()。</li></ul><h2 id="epoll函数"><a href="#epoll函数" class="headerlink" title="epoll函数"></a>epoll函数</h2><p>epoll是在Linux内核2.6引进的，是select和poll函数的增强版。与select相比，epoll没有文件描述符数量的限制。epoll使用一个文件描述符管理多个文件描述符，将用户关心的文件描述符事件存放到内核的一个事件列表中，这样在用户空间和内核空间只需拷贝一次。</p><p>epoll操作是包含有三个接口的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">int epoll_create(int size);</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</span><br><span class="line">int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</span><br></pre></td></tr></table></figure></p><p>epoll_create函数：</p><p>用创建一个epoll的句柄；<br>size用来告诉内核这个监听的数目一共有多大，占用一个fd值；<br>epoll_ctl函数：</p><p>epoll的事件注册函数；<br>参数：</p><p>epfd：epoll_create()的返回值；<br>op：动作，有三种取值：</p><p>EPOLL_CTL_ADD：注册新的fd到epfd中；<br>EPOLL_CTL_MOD：修改已经注册的fd的监听事件；<br>EPOLL_CTL_DEL：从epfd中删除一个fd；<br>fd：需要监听的fd；</p><p>event： 告诉内核需要监听什么事件，取值有：<br>EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；<br>EPOLLOUT：表示对应的文件描述符可以写；<br>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；<br>EPOLLERR：表示对应的文件描述符发生错误；<br>EPOLLHUP：表示对应的文件描述符被挂断；<br>EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。<br>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列；<br>epoll_wait函数：</p><p>等待事件的产生；<br>参数：<br>events：从内核得到事件的集合；<br>maxevents：事件集合的大小；<br>timeout：超时时间，0会立即返回，-1表示永久阻塞，正数表示一个指定的值；<br>工作模式</p><p>epoll对文件描述符的操作由两种模式：水平触发LT（level trigger）和边沿触发ET（edge trigger）。默认的情况下为LT模式。LT模式与ET模式的区别在于：</p><p>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。<br>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。<br>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p><p><strong>Epoll vs Select/Poll</strong></p><ul><li>我们可以在等待时添加或删除文件描述符；</li><li>epoll_wait 仅返回具有准备文件描述符的对象；</li><li>epoll 有更好的性能 —— O(1) 而不是O(n)；</li><li>epoll 可以表现为级别触发或边缘触发（请参见手册页）；</li><li>epoll 是 Linux 特有的，因此可移植性一般。</li></ul><h1 id="x"><a href="#x" class="headerlink" title="x"></a>x</h1>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.jelech.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://www.jelech.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机网络" scheme="http://www.jelech.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>c++后台工程师</title>
    <link href="http://www.jelech.cn/posts/40165/"/>
    <id>http://www.jelech.cn/posts/40165/</id>
    <published>2019-01-01T10:09:33.000Z</published>
    <updated>2019-01-10T14:25:50.758Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><p>一下为后台开发所用的大部分技术栈。一起加油学吧！</p><a id="more"></a><p><img src="/assets/后台开发-2.jpg" alt="后台开发-2"></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;p&gt;一下为后台开发所用的大部分技术栈。一起加油学吧！&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.jelech.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="c++" scheme="http://www.jelech.cn/tags/c/"/>
    
      <category term="后台开发" scheme="http://www.jelech.cn/tags/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>unix下c语言编程</title>
    <link href="http://www.jelech.cn/posts/36582/"/>
    <id>http://www.jelech.cn/posts/36582/</id>
    <published>2018-12-26T08:09:33.000Z</published>
    <updated>2018-12-28T02:06:37.842Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><a id="more"></a><h2 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h2><ul><li><p>编译时需加上 <strong>-g</strong> </p></li><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cc -g -o test test.c</span><br><span class="line">gdb test</span><br></pre></td></tr></table></figure></li><li><p>gdb中使用</p><ul><li><code>list</code>：显示源代码</li><li><code>break n</code>：在第n行添加断点</li><li><code>run</code>：执行被调试的程序</li><li><code>interrupt</code>：终止正在调试的程序</li><li><code>step</code>：单步执行代码，可进入函数</li><li><code>next</code>：单步执行代码，不可进入函数</li><li><code>continue</code>：继续执行，知道下一个断点</li><li><code>watch j</code>：监控 j 变量，在变化时打印</li><li><code>quit</code>：退出</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.jelech.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://www.jelech.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="unix" scheme="http://www.jelech.cn/tags/unix/"/>
    
  </entry>
  
  <entry>
    <title>python线程</title>
    <link href="http://www.jelech.cn/posts/63716/"/>
    <id>http://www.jelech.cn/posts/63716/</id>
    <published>2018-12-25T02:09:33.000Z</published>
    <updated>2018-12-26T08:53:16.553Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="欢迎参观我的博客，这篇文章需要密码才能阅读哦 O(∩_∩)O(点我一下)" />    <label for="pass">欢迎参观我的博客，这篇文章需要密码才能阅读哦 O(∩_∩)O(点我一下)</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX18xhwPGmn2M44a8/32xICnYFB/mAW8X6DMuax2FeT8vPyjgX9svBQUoiYs6NVlJNvxgUNIq/JOCwtF9q1VKZlYwOfNldVz5wTONyTotQD3cs3t0ZrM7GPQPtxlRTsIcerrTFACUjjawXw==</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      欢迎参观我的博客，O(∩_∩)O但是这篇文章是私人的哦&lt;/br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.jelech.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="python" scheme="http://www.jelech.cn/tags/python/"/>
    
      <category term="笔记" scheme="http://www.jelech.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="线程" scheme="http://www.jelech.cn/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>python爬虫基础</title>
    <link href="http://www.jelech.cn/posts/52862/"/>
    <id>http://www.jelech.cn/posts/52862/</id>
    <published>2018-12-25T02:09:33.000Z</published>
    <updated>2018-12-25T15:20:40.740Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><a id="more"></a><h1 id="python爬虫"><a href="#python爬虫" class="headerlink" title="python爬虫"></a>python爬虫</h1><h2 id="爬虫是什么"><a href="#爬虫是什么" class="headerlink" title="爬虫是什么"></a>爬虫是什么</h2><ul><li>爬虫就是一种自动浏览、获取数据的自动化程序</li><li>一般python大量的包、以及容易入手，使得python成为了爬虫的最大’淫’家</li><li>爬虫能获取网页上，作为一个正常人能获取的所有资源。</li><li>但是更方便、快速、简单了</li></ul><h2 id="所需安装包"><a href="#所需安装包" class="headerlink" title="所需安装包"></a>所需安装包</h2><p>在此之前，请先安装好python, pip.   <em>python3的朋友请使用pip3</em></p><ul><li>使用pip安装requests <code>pip install requests</code></li><li>使用pip安装beautifulsoup4 <code>pip install beautifulsoup4</code></li></ul><h2 id="通过’熬汤’"><a href="#通过’熬汤’" class="headerlink" title="通过’熬汤’"></a>通过’熬汤’</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"></span><br><span class="line">html = urlopen(<span class="string">"https://www.jelech.cn"</span>).read().decode(<span class="string">'utf-8'</span>)</span><br><span class="line">print(html)</span><br><span class="line">soup = BeautifulSoup(html, features=<span class="string">'lxml'</span>)</span><br><span class="line">soup.find(<span class="string">'h1'</span>).get_text()</span><br></pre></td></tr></table></figure><ul><li>urlopen( URL ).read().decode(‘utf-8’)<ul><li>通过此函数链获取服务器返回的html, 读取后，编码为utf-8形式</li></ul></li><li>BeatutifulSoup(html, features=’ ‘)<ul><li>将获取到的html文档进行进一步格式化编码。函数返回的对象可以直接find某个标签</li></ul></li><li>soup.find(‘tag’, { key:value })   <em>(find_all(‘tag’))</em><ul><li>获取指定tag名的标签，其中的属性key值为value。相当于筛选，若有多种结果，使用find_all函数可以返回为一个数组</li></ul></li></ul><p>实例：百度百科的多次连接爬取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- utf8 -*-</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">base_url = <span class="string">"https://baike.baidu.com"</span></span><br><span class="line">his = [<span class="string">r"/item/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB"</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    url = base_url + his[<span class="number">-1</span>]  <span class="comment">#最后一个</span></span><br><span class="line">    html = urlopen(url).read().decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    soup = BeautifulSoup(html, features=<span class="string">'lxml'</span>)</span><br><span class="line"></span><br><span class="line">    print(i, soup.find(<span class="string">'h1'</span>).get_text(), <span class="string">'   url:'</span>,his[<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">    sub_urls = soup.find_all(<span class="string">"a"</span>, &#123;</span><br><span class="line">        <span class="string">"target"</span>: <span class="string">"_blank"</span>,</span><br><span class="line">        <span class="string">"href"</span>: re.compile(<span class="string">"/item/(%.&#123;2&#125;)+$"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(sub_urls) != <span class="number">0</span>:</span><br><span class="line">        his.append(random.sample(sub_urls,<span class="number">1</span>)[<span class="number">0</span>][<span class="string">'href'</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        his.pop()</span><br></pre></td></tr></table></figure><h2 id="通过POST-amp-GET"><a href="#通过POST-amp-GET" class="headerlink" title="通过POST&amp;GET"></a>通过POST&amp;GET</h2><ul><li>一般情况下，与服务器的通信最多使用的就是post和get。<ul><li>post一般用于有数据给服务器，然后服务器反应回答</li><li>get用于访问某个页面，服务器直接回答</li><li>这里两者的详细区别和安全就不细说了，详情可以看我的其他笔记</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'username'</span>: <span class="string">'jelech'</span>,</span><br><span class="line">    <span class="string">'password'</span>: <span class="string">'123456'</span></span><br><span class="line">&#125;</span><br><span class="line">r = requests.post(<span class="string">'http://pythonscraping.com/pages/files/processing.php'</span>, data = data)</span><br><span class="line">print(r.url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然，get后面也能像post一样接参数</span></span><br><span class="line">r = requests.get(<span class="string">'https://www.baidu.com/s'</span>)</span><br><span class="line">print(r.url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传文件</span></span><br><span class="line">file = &#123;<span class="string">'uploadFile'</span>: open(<span class="string">'./image.png'</span>, <span class="string">'rb'</span>)&#125;</span><br><span class="line">r = requests.post(<span class="string">'http//pythonscraping.com/files/processing2.php'</span>, files = file)</span><br></pre></td></tr></table></figure><h2 id="通过cookies-amp-session"><a href="#通过cookies-amp-session" class="headerlink" title="通过cookies&amp;session"></a>通过cookies&amp;session</h2><p>在访问网站后，会有个cookies返回后保存着。之后在使用的时候，可以在requests时，将cookies附加上去</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r = requests.get(<span class="string">'https://www.baidu.com/s'</span>)</span><br><span class="line">print(r.cookies.get_dict())</span><br><span class="line">r = requests.get(<span class="string">'http://pythonscraping.com/pages/cookies/profile.php'</span>,cookies = r.cookies)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure><p>session作为保持会话功能。特别是在登录方面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">session = requests.Session()</span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'username'</span>: <span class="string">'jelech'</span>,</span><br><span class="line">    <span class="string">'password'</span>: <span class="string">'123456'</span></span><br><span class="line">&#125;</span><br><span class="line">r = session.post(<span class="string">'http://'</span>,data = data)</span><br><span class="line">r = session.get(<span class="string">'http;//'</span>)</span><br><span class="line"><span class="comment"># 之后就可以直接用session保持当前会话状态下post与get了</span></span><br></pre></td></tr></table></figure><h2 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h2><p>访问下载地址，保存到文件中。可以设置为stream，边下边保存。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlretrieve</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">image_url = <span class="string">"https://"</span></span><br><span class="line">urlretrieve(image_url, <span class="string">'./img/image1.png'</span>) <span class="comment"># 放到哪里去</span></span><br><span class="line"></span><br><span class="line">r = requests.get(image_url)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'./img/image2.png'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(r.content)</span><br><span class="line"></span><br><span class="line">r = requests.get(image_url, stream=<span class="keyword">True</span>) <span class="comment"># 边下边保存</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'./img/image3.png'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> chunk <span class="keyword">in</span> r.iter_content(chunk_size=<span class="number">32</span>): <span class="comment"># 每次下载多少字节后保存</span></span><br><span class="line">        f.write(chunk)</span><br></pre></td></tr></table></figure><p>实例：下载中国地理中的美图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- utf8 -*-</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">URL = <span class="string">"http://www.ngchina.com.cn/animals/"</span></span><br><span class="line"></span><br><span class="line">html = requests.get(URL).text()</span><br><span class="line">soup = BeautifulSoup(html, <span class="string">'lxml'</span>)</span><br><span class="line">img_url = soup.find_all(<span class="string">'ul'</span>, &#123;</span><br><span class="line">    <span class="string">"class"</span>:<span class="string">"img_list"</span></span><br><span class="line">&#125;)</span><br><span class="line">print(len(img_url))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> urls <span class="keyword">in</span> img_url:</span><br><span class="line">    imgs = urls.find_all(<span class="string">'img'</span>)</span><br><span class="line">    <span class="keyword">for</span> img <span class="keyword">in</span> imgs:</span><br><span class="line">        url = img[<span class="string">'src'</span>]</span><br><span class="line">        r = requests.get(url, stream=<span class="keyword">True</span>)</span><br><span class="line">        image_name = url.split(<span class="string">'/'</span>)[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'./img/%s'</span> % image_name, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> chunk <span class="keyword">in</span> r.iter_content(chunk_size = <span class="number">128</span>):</span><br><span class="line">                f.write(chunk)</span><br><span class="line">        print(<span class="string">'Saved %s'</span> % image_name)</span><br></pre></td></tr></table></figure><h2 id="多进程下的爬虫"><a href="#多进程下的爬虫" class="headerlink" title="多进程下的爬虫"></a>多进程下的爬虫</h2><p>多进程使用的是multiprocessing包，进行多进程的创建，他和多线程不一样。他更快，更独立。详细请参观我的其他博文。</p><p>实例：爬取网页中的超链接，访问后再获取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- utf8 -*-</span></span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen, urljoin</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> multiprocessing <span class="keyword">as</span> mp</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多进程的定义，使用来获取返回的信息</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crawl</span><span class="params">(url)</span>:</span></span><br><span class="line">    response = urlopen(url)</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)             <span class="comment"># slightly delay for downloading</span></span><br><span class="line">    <span class="keyword">return</span> response.read().decode()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多进程定义二，对获取到的信息进行解析，获取其中的信息</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(html)</span>:</span></span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">'lxml'</span>)</span><br><span class="line">    urls = soup.find_all(<span class="string">'a'</span>, &#123;<span class="string">"href"</span>: re.compile(<span class="string">'^/.+?/$'</span>)&#125;)</span><br><span class="line">    title = soup.find(<span class="string">'h1'</span>).get_text().strip()</span><br><span class="line">    page_urls = set([urljoin(base_url, url[<span class="string">'href'</span>]) <span class="keyword">for</span> url <span class="keyword">in</span> urls])   <span class="comment"># remove duplication</span></span><br><span class="line">    url = soup.find(<span class="string">'meta'</span>, &#123;<span class="string">'property'</span>: <span class="string">"og:url"</span>&#125;)[<span class="string">'content'</span>]</span><br><span class="line">    <span class="keyword">return</span> title, page_urls, url</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># base_url = "http://127.0.0.1:4000/"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># DON'T OVER CRAWL THE WEBSITE OR YOU MAY NEVER VISIT AGAIN</span></span><br><span class="line">    <span class="keyword">if</span> base_url != <span class="string">"http://127.0.0.1:4000/"</span>:</span><br><span class="line">        restricted_crawl = <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        restricted_crawl = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    unseen = set([base_url,])</span><br><span class="line">    seen = set()</span><br><span class="line"><span class="comment"># 进程池，声明了4个，在其中拿。</span></span><br><span class="line">    pool = mp.Pool(<span class="number">4</span>)                       <span class="comment"># number strongly affected</span></span><br><span class="line">    count, t1 = <span class="number">1</span>, time.time()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> len(unseen) != <span class="number">0</span>:              <span class="comment"># still get some url to visit</span></span><br><span class="line">        <span class="keyword">if</span> restricted_crawl <span class="keyword">and</span> len(seen) &gt; <span class="number">20</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 获取返回数据的进程设置。</span></span><br><span class="line">        crawl_jobs = [pool.apply_async(crawl, args=(url,)) <span class="keyword">for</span> url <span class="keyword">in</span> unseen]</span><br><span class="line">        htmls = [j.get() <span class="keyword">for</span> j <span class="keyword">in</span> crawl_jobs] <span class="comment"># request connection</span></span><br><span class="line">        htmls = [h <span class="keyword">for</span> h <span class="keyword">in</span> htmls <span class="keyword">if</span> h <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>]     <span class="comment"># remove None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取分析数据的进程设置。</span></span><br><span class="line">        parse_jobs = [pool.apply_async(parse, args=(html,)) <span class="keyword">for</span> html <span class="keyword">in</span> htmls]</span><br><span class="line">        results = [j.get() <span class="keyword">for</span> j <span class="keyword">in</span> parse_jobs] <span class="comment"># parse html</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 分析完后,需要将已看过的进行合并</span></span><br><span class="line">        seen.update(unseen)</span><br><span class="line">        unseen.clear()</span><br><span class="line"><span class="comment"># 获取新的，未访问的路径</span></span><br><span class="line">        <span class="keyword">for</span> title, page_urls, url <span class="keyword">in</span> results:</span><br><span class="line">                print(count, title, url)</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                unseen.update(page_urls - seen)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'Total time: %.1f s'</span> % (time.time()-t1, ))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.jelech.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="python" scheme="http://www.jelech.cn/tags/python/"/>
    
      <category term="笔记" scheme="http://www.jelech.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="爬虫" scheme="http://www.jelech.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>跟我一起复习操作系统（一）</title>
    <link href="http://www.jelech.cn/posts/6676/"/>
    <id>http://www.jelech.cn/posts/6676/</id>
    <published>2018-12-06T14:09:33.000Z</published>
    <updated>2018-12-10T05:53:00.066Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><a id="more"></a><h1 id="操作系统的自白（一）"><a href="#操作系统的自白（一）" class="headerlink" title="操作系统的自白（一）"></a>操作系统的自白（一）</h1><ul><li>操作系统是一种建立在电脑硬件上的计算机底层软件，他能接受上层软件的要求，也能操作下层的基础硬件。他作为帮助你进行计算机编程、使用，帮你管理底层的许多杂碎和问题…难道你不该感谢一下吗？</li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>为什么要分类？。。。。直接学啊！</li><li>其实我想说一下的章节分类….面试好像都考不到。最多和死锁搭上边。我想问用户态和内核态呢？</li></ul><h3 id="不算章节的章节"><a href="#不算章节的章节" class="headerlink" title="不算章节的章节"></a>不算章节的章节</h3><ul><li>进程描述和控制</li><li>线程</li><li>并发互斥与同步</li><li>死锁和饥饿</li><li>内存管理</li><li>虚拟内存</li><li>单处理调度</li><li>复用和实时调度</li><li>I/O管理和硬盘管理</li><li>文件管理</li></ul><blockquote><p>其实并不想这么写</p><p>而且有本Unix下的c语言开发，非常好！</p></blockquote><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><ul><li>主要是记录好所有的重点，而尽量的不进行描述，给之后复习节省脑力。看到关键词就能慢慢回忆起这部分内容。</li><li>而且…我好像不是为了开发操作系统而学习的，很多超级细节的东西应该没必要….嘤</li><li>理想真美好~</li><li>或许把linux源码读一下可能更有利于学习，但是….如果有调用底层的东西确实看不下去啊。</li><li>那没办法了</li></ul><p>嘤，开始吧</p><hr><h2 id="进程和线程是兄弟吗"><a href="#进程和线程是兄弟吗" class="headerlink" title="进程和线程是兄弟吗"></a>进程和线程是兄弟吗</h2><ul><li>不。他们是父子关系。你这种想法太可怕了。</li></ul><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><blockquote><p>进程嘛，可以直接理解为我们平常用的程序。但是呢，有点不同的是，它也是个有ID身份证的！这种身份证啊，在他们那叫做PCB - Process Control Blocks</p></blockquote><h4 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h4><ul><li>PCB是进程的身份证(唯一表示符，状态，优先级，程序控制，内存指针，文本数据，I/O状态信息，记录信息)</li><li>哎呀，看字面意思也能懂的嘛，以后用到了慢慢讲嘛，一个进程无非就为了抢数据，得有更高身份的人，操作系统这个大大才会优先给他资源嘛。</li></ul><h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><ul><li>2-state model：就跑还是没跑的区别。</li><li>5-state model：和交叉的接力棒很像哦。<ul><li>一个人来了，先准备好，然后开始跑。</li><li>第二个人来了，要和第一个交接。</li><li>一个跑，一个就准备好。好的，这就是两个人的互相py，哦不，是互相传力了。</li><li>如果有个人不想跑了，那就退出了呗。</li><li>如果有人突然想上厕所了。哎呀不能终止比赛啊，先让他去吧（阻塞了），再上另一个选手进行交叉接力。</li><li>又有人想去了？去吧去吧，拍好队，怎么去的就怎么回来。</li><li>嘿嘿，上厕所的回来了，先等着准备好。这就继续交接啦。<ul><li>需要图？不存在的，YY才是最强大的。</li></ul></li></ul></li><li>7-state model：<ul><li>嘤，有人想上大厕所，有人想回趟家(?????)，这不能让排队的一直等着啊。</li><li>那没法了，分类一下吧，时间长的假装他睡觉了，放另一个等待队列吧。</li><li>上厕所的还是继续阻塞。回家的排了一定时间，给我把它放到另一个长♂久的队列里去。</li></ul></li></ul><h2 id="平时笔记-乱"><a href="#平时笔记-乱" class="headerlink" title="平时笔记-乱"></a>平时笔记-乱</h2><p>用户态和核心态：     用户态：             用户程序执行时机器所处的状态     权限小，只能执行特定指令。<br>核心态：操作系统管理程序执行时机器所处的状态     权限大，能执行特权指令。      特权指令：I/O指令、设置中断屏蔽指令、清理内存指令、设置时钟指令。<br>核心态只向用户提供接口，使得用户态能执行特定的指令和中断等。</p><p>1、调度：进程是拥有资源和独立调度的基本单位     线程只是独立调度单位，运行时资源属于进程。</p><p>2、拥有资源： 不管是有无线程的操作系统，进程都是拥有资源的基本单位，而线程只拥有极少的私有资源（程序计数器、一组寄存器、栈。用来保存线程的执行历史和线程的执行状态，这些资源也是进程的）</p><p>3、并发性：有线程的操作系统，进程可以并发，线程也可以并发。可以理解为一个程序有好几个进程，每个进程又有好几个线程。</p><p>4、系统开销：进程大（切换进程时要保存运行环境，重新启动时又要回复） ，线程小（自己本来就那么一点可怜的资源，开销肯定小）</p><p>用户级线程和内核级线程区别：</p><p>用户级线程：当一个用户级线程阻塞，整个进程都必须等待。<br>内核级线程：当一个内核级线程阻塞，不会影响其他线程。因为一旦线程阻塞，内核会从当前或者其他进程(process)中重新选择一个线程保证程序的执行。<br>进程通信：</p><p>共享存储器系统 ：设置一个共享存储区<br>消息传递系统：直接通信方式、间接通信方式（设置一个中间实体-信箱）<br>管道通信系统：管道是用于连接读写进程以实现它们直接通信的共享文件，所以管道是共享文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.jelech.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://www.jelech.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="操作系统" scheme="http://www.jelech.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>学习的阻碍</title>
    <link href="http://www.jelech.cn/posts/45237/"/>
    <id>http://www.jelech.cn/posts/45237/</id>
    <published>2018-12-06T13:31:17.000Z</published>
    <updated>2018-12-06T14:00:57.564Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="欢迎参观我的博客，这篇文章需要密码才能阅读哦 O(∩_∩)O(点我一下)" />    <label for="pass">欢迎参观我的博客，这篇文章需要密码才能阅读哦 O(∩_∩)O(点我一下)</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      欢迎参观我的博客，O(∩_∩)O但是这篇文章是私有的哦&lt;/br&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://www.jelech.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://www.jelech.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="感想" scheme="http://www.jelech.cn/tags/%E6%84%9F%E6%83%B3/"/>
    
      <category term="学习" scheme="http://www.jelech.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP学习笔记</title>
    <link href="http://www.jelech.cn/posts/13277/"/>
    <id>http://www.jelech.cn/posts/13277/</id>
    <published>2018-12-04T04:09:33.000Z</published>
    <updated>2019-04-26T08:49:12.831Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><a id="more"></a><h1 id="TCP-IP-协议-栈-笔记"><a href="#TCP-IP-协议-栈-笔记" class="headerlink" title="TCP/IP 协议(栈)笔记"></a>TCP/IP 协议(栈)笔记</h1><ul><li><p>您的浏览器与服务器都在使用 TCP/IP 协议</p></li><li><p>您的 E-Mail 使用 TCP/IP 协议</p></li><li><p>因特网地址是 TCP/IP 协议</p></li></ul><p>网际互联及OSI七层模型：</p><p>物理层、数据链路层、网络层、传输层、表示层、会话层、应用层</p><ul><li><p>物理层</p><p>  作用：定义一些电器，机械，过程和规范，如集线器；</p><p>  PDU(协议数据单元)：bit/比特</p><p>  设备：集线器HUB;</p><p>  注意：没有寻址的概念；</p></li><li><p><strong>数据链路层</strong></p><p>  作用：定义如何格式化数据，支持错误检测；</p><p>  典型协议：以太网，帧中继（古董级VPN）</p><p>  PDU：frame（帧）设备：以太网交换机；</p><p>  备注：交换机通过MAC地址转发数据，逻辑链路控制；</p></li><li><p><strong>网络层</strong></p><p>  作用：定义一个逻辑的寻址，选择最佳路径传输，路由数据包；</p><p>  典型协议：IP，IPX，ICMP,ARP(IP-&gt;MAC),IARP;</p><p>  PDU:packet/数据包；</p><p>  设备：路由器</p><p>  备注：实现寻址</p></li><li><p><strong>传输层</strong>：</p><p>  作用：提供可靠和尽力而为的传输；</p><p>  典型协议：TCP,UDP,SPX,port(65535个端口),EIGRP,OSPF,</p><p>  PDU:fragment 段；</p><p>  无典型设备；</p><p>  备注：负责网络传输和会话建立;</p></li><li><p>会话层：</p><p>  作用：控制会话，建立管理终止应用程序会话；</p><p>  典型协议：NFS, SQL, ASP, PHP, JSP, RSVP(资源源预留协议), windows， </p><p>  备注：负责会话建立；</p></li><li><p>表示层：</p><p>  作用：格式化数据；</p><p>  典型协议：ASCII, JPEG. PNG, MP3. WAV, AVI, </p><p>  备注：可以提供加密服务；</p></li><li><p><strong>应用层：</strong></p><p>  作用：控制应用程序；</p><p>  典型协议：telnet, ssh, http, ftp, smtp, rip, BGP, (未完待续)</p><p>  备注：为应用程序提供网络服务；</p></li></ul><h2 id="在-TCP-IP-内部"><a href="#在-TCP-IP-内部" class="headerlink" title="在 TCP/IP 内部"></a>在 TCP/IP 内部</h2><p>在 TCP/IP 中包含一系列用于处理数据通信的协议：</p><ul><li>TCP (传输控制协议) - 应用程序之间通信</li><li>UDP (用户数据报协议) - 应用程序之间的简单通信</li><li>IP (网际协议) - 计算机之间的通信</li><li>ICMP (因特网消息控制协议) - 针对错误和状态</li><li>DHCP (动态主机配置协议) - 针对动态寻址</li></ul><p>当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方”握手”之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex) 的通信。</p><p>这个全双工的通信将占用两个计算机之间的通信线路，直到它被一方或双方关闭为止。</p><p>UDP 和 TCP 很相似，但是更简单，同时可靠性低于 TCP。</p><h3 id="IP-是无连接的协议"><a href="#IP-是无连接的协议" class="headerlink" title="IP 是无连接的协议"></a>IP 是无连接的协议</h3><p>IP 用于计算机之间的通信。</p><p>IP 是无连接的通信协议。它不会占用两个正在通信的计算机之间的通信线路。这样，IP 就降低了对网络线路的需求。每条线可以同时满足许多不同的计算机之间的通信需要。</p><p>通过 IP，消息（或者其他数据）被<code>分割为小的独立的包</code>，并通过因特网在计算机之间传送。</p><p>IP 负责将每个包<strong>路由</strong>至它的目的地。</p><h3 id="IP-路由器"><a href="#IP-路由器" class="headerlink" title="IP 路由器"></a>IP 路由器</h3><p>当一个 IP 包从一台计算机被发送，它会到达一个 IP 路由器。</p><p>IP 路由器负责将这个包路由至它的目的地，直接地或者通过其他的路由器。</p><p><strong>在一个相同的通信中，一个包所经由的路径可能会和其他的包不同</strong>。而路由器负责根据通信量、网络中的错误或者其他参数来进行正确地寻址。</p><h3 id="总结TCP-IP是什么"><a href="#总结TCP-IP是什么" class="headerlink" title="总结TCP/IP是什么"></a>总结TCP/IP是什么</h3><p>TCP/IP 意味着 TCP 和 IP 在一起协同工作。</p><p>TCP 负责应用软件（比如您的浏览器）和网络软件之间的通信。</p><p>IP 负责计算机之间的通信。</p><p>TCP 负责将数据分割并装入 IP 包，然后在它们到达的时候重新组合它们。</p><p>IP 负责将包发送至接受者。</p><h2 id="TCP-IP-寻址"><a href="#TCP-IP-寻址" class="headerlink" title="TCP/IP 寻址"></a>TCP/IP 寻址</h2><p>TCP/IP 使用 32 个比特或者 4 组 0 到 255 之间的数字来为计算机编址。</p><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>每个计算机必须有一个 IP 地址才能够连入因特网。</p><p>每个 IP 包必须有一个地址才能够发送到另一台计算机。</p><p>每个计算机必须有一个唯一的 4 组数字的地址，每组数字必须在 0 到 255 之间，并由点号隔开，比如：<code>192.168.1.60</code></p><h3 id="IP-V6"><a href="#IP-V6" class="headerlink" title="IP V6"></a>IP V6</h3><blockquote><p>IPv6 是 “Internet Protocol Version 6” 的缩写，也被称作下一代互联网协议，它是由 IETF 小组（Internet 工程任务组Internet Engineering Task Force）设计的用来替代现行的 IPv4（现行的）协议的一种新的 IP 协议。</p></blockquote><p>规定的标准语法建议把 IPv6 地址的 128 位（16 个字节）写成 8 个 16 位的无符号整数，每个整数用 4 个十六进制位表示，这些数之间用冒号（:）分开，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">686</span>E：<span class="number">8</span>C64：FFFF：FFFF：<span class="number">0</span>：<span class="number">1180</span>：<span class="number">96</span>A：FFFF</span><br></pre></td></tr></table></figure><p>冒号十六进制记法允许零压缩，即一串连续的0可以用一对冒号取代，只能使用一次零压缩。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FF05：0：0：0：0：0：0：B3 /*可以定成：*/ FF05：：B3</span><br></pre></td></tr></table></figure></p><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>12 个阿拉伯数字很难记忆。使用一个名称更容易。</p><p>用于 TCP/IP 地址的名字被称为域名。jelech.cn 就是一个域名。</p><ul><li><p><code>SSL</code> - 安全套接字层（Secure Sockets Layer）</p><p>  SSL 协议用于为安全数据传输加密数据。</p></li><li><p><code>SMTP</code> - 简易邮件传输协议（Simple Mail Transfer Protocol）</p><p>  SMTP 用于电子邮件的传输。</p></li><li><p><code>MIME</code> - 多用途因特网邮件扩展（Multi-purpose Internet Mail Extensions）</p><p>  MIME 协议使 SMTP 有能力通过 TCP/IP 网络传输多媒体文件，包括声音、视频和二进制数据。</p></li><li><p><code>IMAP</code> - 因特网消息访问协议（Internet Message Access Protocol）</p><p>  IMAP 用于存储和取回电子邮件。</p></li><li><p>POP - 邮局协议（Post Office Protocol）</p><p>  POP 用于从电子邮件服务器向个人电脑下载电子邮件。</p></li><li><p><code>FTP</code> - 文件传输协议（File Transfer Protocol）</p><p>  FTP 负责计算机之间的文件传输。</p></li><li><p><code>NTP</code> - 网络时间协议（Network Time Protocol）</p><p>  NTP 用于在计算机之间同步时间（钟）。</p></li><li><p><code>DHCP</code> - 动态主机配置协议（Dynamic Host Configuration Protocol）</p><p>  DHCP 用于向网络中的计算机分配动态 IP 地址。</p></li><li><p>SNMP - 简单网络管理协议（Simple Network Management Protocol）</p><p>  SNMP 用于计算机网络的管理。</p></li><li><p>LDAP - 轻量级的目录访问协议（Lightweight Directory Access Protocol）</p><p>  LDAP 用于从因特网搜集关于用户和电子邮件地址的信息。</p></li><li><p><code>ICMP</code> - 因特网消息控制协议（Internet Control Message Protocol）</p><p>  ICMP 负责网络中的错误处理。</p></li><li><p><code>ARP</code> - 地址解析协议（Address Resolution Protocol）</p><p>  ARP - 用于通过 IP 来查找基于 IP 地址的计算机网卡的硬件地址。</p></li><li><p>RARP - 反向地址转换协议（Reverse Address Resolution Protocol）</p><p>  RARP 用于通过 IP 查找基于硬件地址的计算机网卡的 IP 地址。</p></li><li><p>BOOTP - 自举协议（Boot Protocol）</p><p>  BOOTP 用于从网络启动计算机。</p></li><li><p><code>PPTP</code> - 点对点隧道协议（Point to Point Tunneling Protocol）</p><p>  PPTP 用于私人网络之间的连接（隧道）。</p></li></ul><h2 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p><strong>RFC</strong></p><ul><li>RFC是什么？RFC就是tcp/ip协议的标准文档，在<a href="http://www.ietf.org/iesg/1rfc_index.txt" target="_blank" rel="noopener">这里</a>我们可以看到RFC那长长的定义列表，现在它一共有4000多个协议的定义，当然，我们所要学习的，也就是那么十几个协议而已。</li></ul><p><strong>端口号</strong>(port)</p><ul><li>注意，这个号码是用在TCP，UDP上的一个逻辑号码，并不是一个硬件端口，我们平时说把某某端口封掉了，也只是在IP层次把带有这个号码的IP包给过滤掉了而已。</li></ul><h3 id="环回接口（loopback）"><a href="#环回接口（loopback）" class="headerlink" title="环回接口（loopback）"></a>环回接口（loopback）</h3><p>平时我们用127.0.0.1来尝试自己的机器服务器好使不好使。走的就是这个loopback接口。对于环回接口，有如下三点值得注意:</p><ul><li><p>传给环回地址（一般是127.0.0.1）的任何数据均作为I P输入。</p></li><li><p>传给广播地址或多播地址的数据报复制一份传给环回接口，然后送到以太网上。这是 因为广播传送和多播传送的定义包含主机本身。</p></li><li><p>任何传给该主机IP地址的数据均送到环回接口。</p></li></ul><h3 id="IP、ARP、RARP协议"><a href="#IP、ARP、RARP协议" class="headerlink" title="IP、ARP、RARP协议"></a>IP、ARP、RARP协议</h3><p>​    </p><ul><li>ARP协议用来找到目标主机的Ethernet网卡Mac地址，IP则承载要发送的消息</li></ul><h4 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h4><ul><li><p>TTL字段规定该数据包在穿过多少个路由之后才会被抛弃(这里就体现出来IP协议包的不可靠性，它不保证数据被送达)</p></li><li><p>稍微一般一点的情况是，主机通过若干个路由器(router)和目的主机连接。那么路由器就要通过ip包的信息来为ip包寻找到一个合适的目标来进行传递，比如合适的主机，或者合适的路由。路由器或者主机将会用如下的方式来处理某一个IP数据包</p><ul><li>如果IP数据包的TTL(生命周期)已到，则该IP数据包就被抛弃。</li><li>搜索路由表，优先搜索匹配主机，如果能找到和IP地址完全一致的目标主机，则将该包发向目标主机</li><li>搜索路由表，如果匹配主机失败，则匹配同子网的路由器，这需要“子网掩码(1.3.)”的协助。如果找到路由器，则将该包发向路由器。</li><li>搜索路由表，如果匹配同子网路由器失败，则匹配同网号(第一章有讲解)路由器，如果找到路由器，则将该包发向路由器。</li><li>搜索路由表，如果以上都失败了，就搜索默认路由，如果默认路由存在，则发包</li><li>如果都失败了，就丢掉这个包。</li></ul></li><li><p>子网掩码是由32bit的二进制数字序列,形式为是一连串的1和一连串的0，例如：255.255.255.0(二进制就是11111111.11111111.11111111.00000000)</p></li><li><p><strong>首部</strong></p><ul><li>4版本、4首长度、8服务类型、16总长度、</li><li>16标识、3标志、13位片偏移</li><li>8生存时间TTL、8协议(1ICMP, 6TCP, 17UDP)、16位首部检验和</li><li>32位源IP</li><li>32位目的IP      &lt;== 20字节</li><li>[选项]</li><li>数据</li></ul></li></ul><h4 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h4><ul><li><p>ARP(地址解析)</p></li><li><p>ARP高速缓存(就是一个IP-MAC地址对应表缓存)</p></li><li><p>如果查询的IP-MAC值对不存在，那么主机就向网络发送一个ARP协议广播包</p></li><li><p>如果收到广播包的某一个主机发现自己符合条件，那么就准备好一个包含自己的MAC地址的ARP包传送给发送ARP广播的主机</p></li><li><p>高速缓存是有时限的，一般是20分钟</p></li></ul><h3 id="ICMP协议-amp-amp-Ping-amp-amp-Traceroute"><a href="#ICMP协议-amp-amp-Ping-amp-amp-Traceroute" class="headerlink" title="ICMP协议 &amp;&amp; Ping &amp;&amp; Traceroute"></a>ICMP协议 &amp;&amp; Ping &amp;&amp; Traceroute</h3><ul><li>保证数据送达的工作应该由其他的模块来完成。其中一个重要的模块就是ICMP(网络控制报文)协议。</li><li>当传送IP数据包发生错误－－比如主机不可达，路由不可达等等，ICMP协议将会把错误信息封包，然后传送回给主机。</li><li>ICMP协议大致分为两类，一种是查询报文，一种是差错报文。<ul><li>ping查询（不要告诉我你不知道ping程序）</li><li>子网掩码查询（用于无盘工作站在初始化自身的时候初始化子网掩码）</li><li>时间戳查询（可以用来同步时间）</li></ul></li></ul><h4 id="Traceroute"><a href="#Traceroute" class="headerlink" title="Traceroute"></a>Traceroute</h4><ul><li><p>Traceroute是用来侦测主机到目的主机之间所经路由情况的重要工具，也是最便利的工具。</p></li><li><p>首先给目的主机<strong>发送</strong>一个TTL=1的UDP数据包，而经过的第一个路由器收到这个数据包以后，就自动把<strong>TTL减1</strong>，而TTL<strong>变为0</strong>以后，路由器就把这个包给<strong>抛弃</strong>了，并同时产生 一个主机<strong>不可达的ICMP数据报</strong>给主机。主机收到这个数据报以后<strong>再发一个TTL=2</strong>的UDP数据报给目的主机，然后刺激第二个路由器给主机发ICMP数据 报。如此往复直到到达目的主机。这样，traceroute就拿到了<strong>所有</strong>的路由器ip。</p></li></ul><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><ul><li>利用TCP通信的两台主机首先要经历一个“<strong>拨打电话</strong>”的过程，等到通信准备结束才开始传输数据，最后结束通话。</li><li>应用数据被分割成TCP认为最适合发送的数据块。这和UDP完全不同，应用程序产生的数据报<strong>长度</strong>将保持不变。</li><li>当TCP发出一个段后，它启动一个<strong>定时器</strong>，等待目的端确认收到这个报文段。如果不能 及时收到一个确认，将重发这个报文段。</li><li>当TCP收到发自TCP连接另一端的数据，它将发送一个<strong>确认</strong>。这个确认不是立即发送，通常将推迟几分之一秒。</li><li>TCP将保持它首部和数据的<strong>检验和</strong>。这是一个端到端的检验和，目的是检测数据在传输 过程中的任何变化。如果收到段的检验和有差错， T P将丢弃这个报文段和不确认收到此报文段（希望发端超时并重发）。</li><li>IP数据报的到达可能会失序，因此TCP报文段 的到达也可能会失序。如果必要， TCP将对收到的数据进行重新排序，将收到的数据以<strong>正确的顺序</strong>交给应用层。</li><li>TCP还能提供<strong>流量控制</strong>。TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。</li></ul><h3 id="TCP建立与终止"><a href="#TCP建立与终止" class="headerlink" title="TCP建立与终止"></a>TCP建立与终止</h3><blockquote><p>TCP是一个面向连接的协议，所以在连接双方发送数据之前，都需要首先建立一条连接。前面讲的所有协议都只是发送数据而已，大多数都不关心发送的数据是不是送到，UDP尤其明显，从编程的角度来说，UDP编程也要简单的多—-UDP都不用考虑数据分片。</p></blockquote><p>TCP连接的建立可以简单的称为<strong>三次握手</strong>，而连接的中止则可以叫做<strong>四次挥手</strong>。</p><ul><li>建立-三次握手<ul><li>第一次握手：主机A发送位码为syn＝1,随机产生seq number=1234567的数据包到服务器，主机B由SYN=1知道，A要求建立联机；</li><li>第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1),syn=1,ack=1,随机产生seq=7654321的包</li><li>第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1),ack=1，主机B收到后确认seq值与ack=1则连接建立成功。</li></ul></li><li>结束-4次挥手<ul><li>客户机给服务器一个FIN为1的TCP报文</li><li>服务器返回给客户端一个确认ACK报文</li><li>发送一个FIN报文</li><li>客户机回复ACK报文</li></ul></li><li>TIME-WAIT<ul><li>TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE</li><li>网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文</li></ul></li></ul><h4 id="最大报文长度"><a href="#最大报文长度" class="headerlink" title="最大报文长度"></a>最大报文长度</h4><ul><li>在建立连接的时候，通信的双方要互相确认对方的最大报文长度(MSS)，以便通信。</li><li>SYN长度是MTU减去固定IP首部和TCP首部长度。</li></ul><h3 id="TCP交互数据流，成块数据流"><a href="#TCP交互数据流，成块数据流" class="headerlink" title="TCP交互数据流，成块数据流"></a>TCP交互数据流，成块数据流</h3><h4 id="交互数据流"><a href="#交互数据流" class="headerlink" title="交互数据流"></a>交互数据流</h4><blockquote><p>对于交互性要求比较高的应用，TCP给出两个策略来提高发送效率和减低网络负担：（1）捎带ACK。(2)Nagle算法</p></blockquote><ul><li>捎带ACK<ul><li>当<strong>主机收到远程主机</strong>的TCP数据报之后，通常不马上发送ACK数据报</li><li>等上一个短暂的时间，如果这段时间里面<strong>主机还有发送到远程主机</strong>的TCP数据报，那么就把这个ACK数据报“捎带”着发送出去，把本来两个TCP数据报整合成一个发送</li></ul></li><li>Nagle算法<ul><li>当主机A给主机B发送了一个TCP数据报并进入等待主机B的ACK数据报的状态时，TCP的输出缓冲区里面只能有一个TCP数据报</li><li>这个数据报不断地收集后来的数据，整合成一个大的数据报</li><li>等到B主机的ACK包一到，就把这些数据“一股脑”的发送出去</li></ul></li></ul><h4 id="TCP的成块数据流"><a href="#TCP的成块数据流" class="headerlink" title="TCP的成块数据流"></a>TCP的成块数据流</h4><blockquote><p>对于FTP这样对于数据吞吐量有较高要求的要求，将总是希望每次尽量多的发送数据到对方主机，就算是有点“延迟”也无所谓</p></blockquote><ul><li><p><strong>ACK的应答策略：</strong>发送端将会连续发送数据尽量填满接受方的缓冲区，而接受方对这些数据只要发送一个ACK报文来回应就可以了，这就是ACK的累积特性，这个特性大大减少了发送端和接收端的负担。</p></li><li><p><strong>滑动窗口</strong></p><ul><li>滑动窗口本质上是<strong>描述</strong>接受方的TCP数据报<strong>缓冲区大小</strong>的数据，发送方根据这个数据来计算自己最多能发送多长的数据。</li><li>如果发送方收到接受方的窗口大小为0的TCP数据报，那么发送方将停止发送数据，等到接受方发送窗口大小不为0的数据报的到来。</li><li>窗口协议<ul><li>窗口合拢：当窗口从左边向右边靠近的时候，这种现象发生在数据被发送和确认的时候。</li><li>窗口张开：当窗口的右边沿向右边移动的时候，这种现象发生在接受端处理了数据以后。</li><li>窗口收缩：当窗口的右边沿向左边移动的时候，这种现象不常发生。</li><li>TCP就是用这个窗口，慢慢的从数据的左边移动到右边，把处于窗口范围内的数据发送出去窗口的大小是可以通过socket来制定的，4096并不是最理想的窗口大小，而16384则可以使吞吐量大大的增加。</li></ul></li></ul></li><li><strong>数据拥塞</strong><ul><li>最大的问题就是当传输时出现了瓶颈，TCP发送方需要确认连接双方的线路的数据最大吞吐量是多少<ul><li>(倍增)</li><li>TCP发送方首先发送一个数据报，然后等待对方的回应</li><li>得到回应后就把这个窗口的大小加倍，然后连续发送两个数据报</li><li>等到对方回应以后，再把这个窗口加倍</li></ul></li></ul></li></ul><h3 id="TCP的超时与重传"><a href="#TCP的超时与重传" class="headerlink" title="TCP的超时与重传"></a>TCP的超时与重传</h3><blockquote><p>超时重传是TCP协议保证数据可靠性的另一个重要机制，其原理是在发送某一个数据以后就<strong>开启一个计时器</strong>，在一定时间内如果没有得到发送的数据报的ACK报文，那么就重新发送数据，直到发送成功为止。</p></blockquote><ul><li>超时<ul><li>定时长久会造成网络利用率不高</li><li>定时太短会造成多次重传，使得网络阻塞</li></ul></li><li>计时器的使用<ul><li>一个连接中，有且仅有一个测量定时器被使用。也就是说，如果TCP连续发出3组数据，只有一组数据会被测量。</li><li>ACK数据报不会被测量，原因很简单，没有ACK的ACK回应可以供结束定时器测量。</li></ul></li><li>重传<ul><li>拥塞窗口最初使用指数增长的速度来增加自身的窗口，直到发生超时重传，再进行一次微调。</li><li>如何进行微调，拥塞避免算法和慢启动门限就是为此而生。<ul><li>慢启动门限就是说，当拥塞窗口超过这个门限的时候，就使用拥塞避免算法，而在门限以内就采用慢启动算法</li></ul></li><li>快速重传和快速恢复算法<ul><li>一般来说，重传发生在超时之后，但是如果发送端接受到3个以上的重复ACK的情况下，就应该意识到，数据丢了，需要重新传递</li><li>这个机制是不需要等到重传定时器溢出的，所以叫做<strong>快速重传</strong>，而重新传递以后，因为走的不是<strong>慢启动</strong>而是<strong>拥塞避免算法</strong>，所以这又叫做<strong>快速恢复算法</strong></li></ul></li></ul></li></ul><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h3 id="UDP端口号"><a href="#UDP端口号" class="headerlink" title="UDP端口号"></a>UDP端口号</h3><ul><li>例如某一个UDP程序A在系统中注册了3000端口，那么，以后从外面传进来的目的端口号为3000的UDP包都会交给该程序。端口号理论上可以有2^16这么多。因为它的长度是16个bit</li><li>UDP检验和覆盖UDP协议头和数据, UDP和TCP都包含一个伪首部，这是为了计算检验和而摄制的。</li><li>目的是让UDP两次检查数据是否已经正确到达目的地。</li></ul><blockquote><p>UDP可以很长很长，可以有65535字节那么长。但是一般网络在传送的时候，一次一般传送不了那么长的协议（涉及到MTU的问题），就只好对数据分片</p></blockquote><h3 id="IP分片"><a href="#IP分片" class="headerlink" title="IP分片"></a>IP分片</h3><ul><li>IP在从上层接到数据以后，要根据IP地址来判断从那个接口发送数据（通过选路），并进行MTU的查询，如果数据大小超过MTU就进行数据分片。</li><li>在IP头里面<ul><li>16bit识别号唯一记录了一个IP包的ID,具有同一个ID的IP片将会被重新组装；</li><li>而13位片偏移则记录了某IP片相对整个包的位置；</li><li>而这两个表示中间的3bit标志则标示着该分片后面是否还有新的分片。</li></ul></li></ul><h3 id="UDP服务器设计"><a href="#UDP服务器设计" class="headerlink" title="UDP服务器设计"></a>UDP服务器设计</h3><ul><li>关于客户IP和地址：服务器必须有根据客户IP地址和端口号判断数据包是否合法的能力（这似乎要求每一个服务器都要具备）</li><li>关于目的地址：服务器必须要有过滤广播地址的能力。</li><li>关于数据输入：通常服务器系统的每一个端口号都会和一块输入缓冲区对应，进来的输入根据先来后到的原则等待服务器的处理，所以难免会出现缓冲区溢出的问题，这种情况下，UDP数据包可能会被丢弃，而应用服务器程序本身并不知道这个问题。</li><li>服务器应该限制本地IP地址，就是说它应该可以把自己绑定到某一个网络接口的某一个端口上。</li></ul><h2 id="广播和多播，IGMP协议"><a href="#广播和多播，IGMP协议" class="headerlink" title="广播和多播，IGMP协议"></a>广播和多播，IGMP协议</h2><h3 id="单播-unicast"><a href="#单播-unicast" class="headerlink" title="单播(unicast)"></a>单播(unicast)</h3><ul><li>单播是说，对特定的主机进行数据传送。</li><li>例如给某一个主机发送IP数据包。这时候，数据链路层给出的数据头里面是非常具体的目的地址，对于以太网来 说，就是网卡的MAC地址。</li></ul><h3 id="广播-unicast"><a href="#广播-unicast" class="headerlink" title="广播(unicast)"></a>广播(unicast)</h3><ul><li>广播是主机针对某一个网络上的所有主机发送数据包。</li><li>这个网络可能是网络，可能是子网，还可能是所有的子网。</li><li>一般说来ARP，或者路由协议RIP应该是以广播的形式播发的。</li></ul><h3 id="多播-multicast"><a href="#多播-multicast" class="headerlink" title="多播(multicast)"></a>多播(multicast)</h3><ul><li>多播就是给一组特定的主机（多播组）发送数据</li><li>多播的数据还是要通过数据链路层进行MAC地址绑定然后进行发送。所以一个以太网卡在绑定了一个多播IP地址之后，必 定还要绑定一个多播的MAC地址，才能使得其可以像单播那样工作。</li></ul><h3 id="IGMP"><a href="#IGMP" class="headerlink" title="IGMP"></a>IGMP</h3><ul><li>IGMP的作用在于，让其他所有需要知道自己处于哪个多播组的主机和路由器知道自己的状态。</li></ul><h2 id="DNS域名系统"><a href="#DNS域名系统" class="headerlink" title="DNS域名系统"></a>DNS域名系统</h2><ul><li>它负责把FQDN(就是以”.”分隔结尾的名字)翻译成一个IP。</li><li>DNS系统是一个分布式的数据库，当一个数据库发现自己并没有某查询所需要的数据的时候，它将把查询转发出去，而转发的目的地通常是根服务器，根服 务器从上至下层层转发查询，直到找到目标为止。</li></ul><h3 id="用UDP还是TCP"><a href="#用UDP还是TCP" class="headerlink" title="用UDP还是TCP"></a>用UDP还是TCP</h3><ul><li>而大多数的查询都是UDP查询的，一般需要TCP查询的有两种情况<ul><li>当查询数据多大以至于产生了数据截断(TC标志为1)，这时，需要利用TCP的分片能力来进行数据传输</li><li>当主（master）服务器和辅（slave）服务器之间通信，辅服务器要拿到主服务器的zone信息的时候。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.jelech.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://www.jelech.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="TCP/IP" scheme="http://www.jelech.cn/tags/TCP-IP/"/>
    
      <category term="协议" scheme="http://www.jelech.cn/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>HTTP学习笔记</title>
    <link href="http://www.jelech.cn/posts/864/"/>
    <id>http://www.jelech.cn/posts/864/</id>
    <published>2018-12-03T10:09:33.000Z</published>
    <updated>2018-12-09T12:41:05.740Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><a id="more"></a><h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><p><code>HyperText Transfer Protocol</code>基于TCP/IP通讯协议来传输数据</p><h3 id="客户端请求消息"><a href="#客户端请求消息" class="headerlink" title="客户端请求消息"></a>客户端请求消息</h3><p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。</p><p><img src="../../assets/images/2012072810301161.png" alt="2012072810301161"></p><p>HTTP 协议中共定义了八种方法或者叫“动作”来表明对 Request-URI 指定的资源的不同操作方式，虽然 HTTP 的请求方式有 8 种，但是我们在实际应用中常用的也就是 <strong>get</strong> 和 <strong>post</strong>，其他请求方式也都可以通过这两种方式间接的来实现，具体介绍如下：</p><ul><li><code>OPTIONS</code>：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’的请求来测试服务器的功能性。</li><li><code>HEAD</code>：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。</li><li><code>GET</code>：向特定的资源发出请求。</li><li><code>POST</code>：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。</li><li><code>PUT</code>：向指定资源位置上传其最新内容。</li><li><code>DELETE</code>：请求服务器删除 Request-URI 所标识的资源。</li><li><code>TRACE</code>：回显服务器收到的请求，主要用于测试或诊断。</li><li><code>CONNECT</code>：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</li></ul><p><img src="assets/get-http.png" alt="get-http"></p><h5 id="客户端请求GET实例"><a href="#客户端请求GET实例" class="headerlink" title="客户端请求GET实例"></a>客户端请求GET实例</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/562f25980001b1b106000338.jpg</span> HTTP/1.1</span><br><span class="line">Host    img.mukewang.com</span><br><span class="line">User-Agent    Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36</span><br><span class="line">Accept    image/webp,image/*,*/*;q=0.8</span><br><span class="line">Referer    http://www.imooc.com/</span><br><span class="line">Accept-Encoding    gzip, deflate, sdch</span><br><span class="line">Accept-Language    zh-CN,zh;q=0.8</span><br></pre></td></tr></table></figure><ul><li>请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本<ul><li>GET说明请求类型为GET</li><li>[/562f25980001b1b106000338.jpg]为要访问的资源</li><li>该行的最后一部分说明使用的是HTTP1.1版本。</li></ul></li><li>请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息<ul><li>从第二行起为请求头部，HOST将指出请求的目的地.</li><li>User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.</li><li>该信息由你的浏览器来定义,并且在每个请求中自动发送等等</li></ul></li><li>空行，请求头部后面的空行是必须的<ul><li>即使第四部分的请求数据为空，也必须有空行</li></ul></li><li>请求数据也叫主体，可以添加任意的其他数据</li></ul><h4 id="http响应头信息"><a href="#http响应头信息" class="headerlink" title="http响应头信息"></a>http响应头信息</h4><table><thead><tr><th>应答头</th><th>说明</th></tr></thead><tbody><tr><td>Allow</td><td>服务器支持哪些请求方法（如GET、POST等）。</td></tr><tr><td>Content-Encoding</td><td>文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。<code>因此，Servlet应该通过查看Accept-Encoding头</code>（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，<code>为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面</code>。</td></tr><tr><td>Content-Length</td><td>表示内容长度。<code>只有当浏览器使用持久HTTP连接时才需要这个数据</code>。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。</td></tr><tr><td>Content-Type</td><td>表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但<code>通常需要显式地指定为text/html</code>。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。</td></tr><tr><td>Date</td><td>当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。</td></tr><tr><td>Expires</td><td>应该在什么时候认为文档已经过期，从而不再缓存它？</td></tr><tr><td>Last-Modified</td><td>文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。</td></tr><tr><td>Location</td><td>表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。</td></tr><tr><td>Refresh</td><td>表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=<code>http://host/path</code>“)让浏览器读取指定的页面。%E8%AE%A9%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%BB%E5%8F%96%E6%8C%87%E5%AE%9A%E7%9A%84%E9%A1%B5%E9%9D%A2%E3%80%82) 注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=”Refresh” CONTENT=”5;URL=<code>http://host/path</code>“＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是”N秒之后刷新本页面或访问指定页面”，而不是”每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=”Refresh” …＞。 注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。</td></tr><tr><td>Server</td><td>服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。</td></tr><tr><td>Set-Cookie</td><td>设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。</td></tr><tr><td>WWW-Authenticate</td><td>客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=＼”executives＼””)。 注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。</td></tr></tbody></table><h3 id="服务端响应"><a href="#服务端响应" class="headerlink" title="服务端响应"></a>服务端响应</h3><p>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文</p><p><img src="assets/httpmessage.jpg" alt="httpmessage"></p><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 27 Jul 2009 12:28:53 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT</span><br><span class="line">ETag: &quot;34aa387-d-1568eb00&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 51</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">Content-Type: text/plain</span><br></pre></td></tr></table></figure><h3 id="HTTP状态码列表"><a href="#HTTP状态码列表" class="headerlink" title="HTTP状态码列表"></a>HTTP状态码列表</h3><ul><li>1xx：指示信息–表示请求已接收，继续处理</li><li>2xx：成功–表示请求已被成功接收、理解、接受</li><li>3xx：重定向–要完成请求必须进行更进一步的操作</li><li><p>4xx：客户端错误–请求有语法错误或请求无法实现</p></li><li><p>5xx：服务器端错误–服务器未能实现合法的请求</p></li></ul><table><thead><tr><th>状态码</th><th>状态码英文名称</th><th>中文描述</th><th></th></tr></thead><tbody><tr><td>100</td><td>Continue</td><td>继续。客户端应继续其请求</td><td></td></tr><tr><td>101</td><td>Switching Protocols</td><td>切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td><td></td></tr><tr><td>200</td><td>OK</td><td>请求成功。一般用于GET与POST请求</td><td></td></tr><tr><td>201</td><td>Created</td><td>已创建。成功请求并创建了新的资源</td><td></td></tr><tr><td>202</td><td>Accepted</td><td>已接受。已经接受请求，但未处理完成</td><td></td></tr><tr><td>203</td><td>Non-Authoritative Information</td><td>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td><td></td></tr><tr><td>204</td><td>No Content</td><td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td><td></td></tr><tr><td>205</td><td>Reset Content</td><td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td><td></td></tr><tr><td>206</td><td>Partial Content</td><td>部分内容。服务器成功处理了部分GET请求</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>300</td><td>Multiple Choices</td><td>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td><td></td></tr><tr><td>301</td><td>Moved Permanently</td><td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td><td></td></tr><tr><td>302</td><td>Found</td><td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td><td></td></tr><tr><td>303</td><td>See Other</td><td>查看其它地址。与301类似。使用GET和POST请求查看</td><td></td></tr><tr><td>304</td><td>Not Modified</td><td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td><td></td></tr><tr><td>305</td><td>Use Proxy</td><td>使用代理。所请求的资源必须通过代理访问</td><td></td></tr><tr><td>306</td><td>Unused</td><td>已经被废弃的HTTP状态码</td><td></td></tr><tr><td>307</td><td>Temporary Redirect</td><td>临时重定向。与302类似。使用GET请求重定向</td><td></td></tr><tr><td>400</td><td>Bad Request</td><td>客户端请求的语法错误，服务器无法理解</td><td></td></tr><tr><td>401</td><td>Unauthorized</td><td>请求要求用户的身份认证</td><td></td></tr><tr><td>402</td><td>Payment Required</td><td>保留，将来使用</td><td></td></tr><tr><td>403</td><td>Forbidden</td><td>服务器理解请求客户端的请求，但是拒绝执行此请求</td><td></td></tr><tr><td>404</td><td>Not Found</td><td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td><td></td></tr><tr><td>405</td><td>Method Not Allowed</td><td>客户端请求中的方法被禁止</td><td></td></tr><tr><td>406</td><td>Not Acceptable</td><td>服务器无法根据客户端请求的内容特性完成请求</td><td></td></tr><tr><td>407</td><td>Proxy Authentication Required</td><td>请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td><td></td></tr><tr><td>408</td><td>Request Time-out</td><td>服务器等待客户端发送的请求时间过长，超时</td><td></td></tr><tr><td>409</td><td>Conflict</td><td>服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突</td><td></td></tr><tr><td>410</td><td>Gone</td><td>客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td><td></td></tr><tr><td>411</td><td>Length Required</td><td>服务器无法处理客户端发送的不带Content-Length的请求信息</td><td></td></tr><tr><td>412</td><td>Precondition Failed</td><td>客户端请求信息的先决条件错误</td><td></td></tr><tr><td>413</td><td>Request Entity Too Large</td><td>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td><td></td></tr><tr><td>414</td><td>Request-URI Too Large</td><td>请求的URI过长（URI通常为网址），服务器无法处理</td><td></td></tr><tr><td>415</td><td>Unsupported Media Type</td><td>服务器无法处理请求附带的媒体格式</td><td></td></tr><tr><td>416</td><td>Requested range not satisfiable</td><td>客户端请求的范围无效</td><td></td></tr><tr><td>417</td><td>Expectation Failed</td><td>服务器无法满足Expect的请求头信息</td><td></td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器内部错误，无法完成请求</td><td></td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不支持请求的功能，无法完成请求</td><td></td></tr><tr><td>502</td><td>Bad Gateway</td><td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td><td></td></tr><tr><td>503</td><td>Service Unavailable</td><td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td><td></td></tr><tr><td>504</td><td>Gateway Time-out</td><td>充当网关或代理的服务器，未及时从远端服务器获取请求</td><td></td></tr><tr><td>505</td><td>HTTP Version not supported</td><td>服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><blockquote><p>协议://域名/文件名#锚点?参数</p></blockquote><ol><li>协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符</li><li>域名部分：该URL的域名部分为“<a href="http://www.jelech.cn”。一个URL中，也可以使用IP地址作为域名使用" target="_blank" rel="noopener">www.jelech.cn”。一个URL中，也可以使用IP地址作为域名使用</a></li><li>端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口</li><li>虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”</li><li>文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名</li><li>锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分</li><li>参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</li></ol><p>uri &amp; url</p><ul><li>Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的</li><li>URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源</li></ul><h3 id="HTTP1-0与1-1"><a href="#HTTP1-0与1-1" class="headerlink" title="HTTP1.0与1.1"></a>HTTP1.0与1.1</h3><ol><li><strong>缓存处理</strong></li><li><strong>带宽优化及网络连接的使用</strong>，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li><strong>错误通知的管理</strong>，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li><strong>Host头处理</strong>，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</li><li><strong>长连接</strong>，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</li></ol><h3 id="HTTP与HPPTS"><a href="#HTTP与HPPTS" class="headerlink" title="HTTP与HPPTS"></a>HTTP与HPPTS</h3><ul><li>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</li><li>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。</li><li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。</li></ul><h3 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h3><blockquote><p>2012年google如一声惊雷提出了SPDY的方案，优化了HTTP1.X的请求延迟，解决了HTTP1.X的安全性</p></blockquote><ol><li><strong>降低延迟</strong>，针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。</li><li><strong>请求优先级</strong>（request prioritization）。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。</li><li><strong>header压缩。</strong>前面提到HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。</li><li><strong>基于HTTPS的加密协议传输</strong>，大大提高了传输数据的可靠性。</li><li><strong>服务端推送</strong>（server push），采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。</li></ol><blockquote><p>SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。</p></blockquote><p><strong>HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？</strong></p><ul><li>HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；</li><li>HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；</li><li>HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；</li></ul><blockquote><p>服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.jelech.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://www.jelech.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="HTTP" scheme="http://www.jelech.cn/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>python进阶学习笔记(好像还是有点基础)</title>
    <link href="http://www.jelech.cn/posts/60692/"/>
    <id>http://www.jelech.cn/posts/60692/</id>
    <published>2018-12-03T02:09:33.000Z</published>
    <updated>2018-12-03T15:17:22.177Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><a id="more"></a><h1 id="Python的学习笔记-高级编程"><a href="#Python的学习笔记-高级编程" class="headerlink" title="Python的学习笔记-高级编程"></a>Python的学习笔记-高级编程</h1><p>有关linux-python3的搭建，可以参考我的另一篇博客。</p><blockquote><p>由于现在的python分为了2.7阵营和3+阵营，但是3+优化了许多的细节问题、修改了一些bug。所以这里就以3+的python为主啦</p></blockquote><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>每个文件的开头一般会写<code>#!/usr/bin/python3</code></p><p>安装部分直接跳过，可参考我的另一篇博客</p><h3 id="python语法"><a href="#python语法" class="headerlink" title="python语法"></a>python语法</h3><p>这部分也跳过，基础部分。</p><p>但是值得一提的是，语言真的是想通的。c++可通过适当 的修改，变为python：</p><ul><li><p>去掉c++中的所有大括号</p></li><li><p>去掉c++中变量声明时的类型符号(int,float,double…)</p></li><li><p>换行和缩进必须为标准</p></li><li><p>每个判断类型的关键字(如if、else、while、for、函数…)当行的后面都需要加冒号</p><p>  这时候基本上已经很接近python语法了</p><p>  可以一行进行多条语句，语句间用<code>;</code>号分割</p></li></ul><h3 id="数据类型（不需要特殊声明）"><a href="#数据类型（不需要特殊声明）" class="headerlink" title="数据类型（不需要特殊声明）"></a>数据类型（不需要特殊声明）</h3><ul><li><p>Number（数字）</p></li><li><p>String（字符串）</p></li><li><p>List（列表）</p></li><li><p>Tuple（元组）</p></li><li><p>Set（集合）</p></li><li><p>Dictionary（字典）</p><p>  其中：</p></li><li><p><strong>不可变数据（3 个）：</strong>Number（数字）、String（字符串）、Tuple（元组）；</p></li><li><strong>可变数据（3 个）：</strong>List（列表）、Dictionary（字典）、Set（集合）。</li></ul><p>您也可以使用del语句删除一些对象引用。<code>del var1[,var2[,var3[....,varN]]]</code></p><h4 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h4><p><code>string * num</code>表示复制string字符串num次</p><p>Python 使用反斜杠()转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个 r，表示原始字符串<code>&gt;&gt;&gt; print(r&#39;Ru\noob&#39;)</code></p><p>与 C 字符串不同的是，Python 字符串不能被改变。向一个索引位置赋值，比如<code>word[0] = &#39;m&#39;</code>会导致错误。</p><h3 id="Tuple（元组）"><a href="#Tuple（元组）" class="headerlink" title="Tuple（元组）"></a>Tuple（元组）</h3><p>元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 () 里，元素之间用逗号隔开。其实，可以把字符串看作一种特殊的元组。</p><h3 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h3><p>可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(a - b)     <span class="comment"># a 和 b 的差集</span></span><br><span class="line">print(a | b)     <span class="comment"># a 和 b 的并集</span></span><br><span class="line">print(a &amp; b)     <span class="comment"># a 和 b 的交集</span></span><br><span class="line">print(a ^ b)     <span class="comment"># a 和 b 中不同时存在的元素</span></span><br></pre></td></tr></table></figure><h3 id="Dictionary（字典）-对应c-中的map"><a href="#Dictionary（字典）-对应c-中的map" class="headerlink" title="Dictionary（字典）(对应c++中的map)"></a>Dictionary（字典）(对应c++中的map)</h3><p>字典是一种映射类型，字典用”{ }”标识，它是一个<strong>无序</strong>的<strong>键(key) : 值(value)</strong>对集合。</p><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>int(x [,base])</td><td>将x转换为一个整数,进制</td></tr><tr><td>float(x)</td><td>将x转换到一个浮点数</td></tr><tr><td>complex(real [,imag])</td><td>创建一个复数</td></tr><tr><td>str(x)</td><td>将对象 x 转换为字符串</td></tr><tr><td>repr(x)</td><td>将对象 x 转换为表达式字符串</td></tr><tr><td>eval(str)</td><td>用来计算在字符串中的有效Python表达式,并返回一个对象</td></tr><tr><td>tuple(s)</td><td>将序列 s 转换为一个元组</td></tr><tr><td>list(s)</td><td>将序列 s 转换为一个列表</td></tr><tr><td>set(s)</td><td>转换为可变集合</td></tr><tr><td>dict(d)</td><td>创建一个字典。d 必须是一个序列 (key,value)元组。</td></tr><tr><td>frozenset(s)</td><td>转换为不可变集合</td></tr><tr><td>chr(x)</td><td>将一个整数转换为一个字符</td></tr><tr><td>ord(x)</td><td>将一个字符转换为它的整数值</td></tr><tr><td>hex(x)</td><td>将一个整数转换为一个十六进制字符串</td></tr><tr><td>oct(x)</td><td>将一个整数转换为一个八进制字符串</td></tr></tbody></table><p>is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。</p><h3 id="随机数函数"><a href="#随机数函数" class="headerlink" title="随机数函数"></a>随机数函数</h3><table><thead><tr><th>函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td>choice(seq)</td><td style="text-align:left">从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。</td></tr><tr><td>randrange ([start,] stop [,step])</td><td style="text-align:left">从指定范围内，按指定基数递增的集合中获取一个随机数，基数缺省值为1</td></tr><tr><td>random()</td><td style="text-align:left">随机生成下一个实数，它在[0,1)范围内。</td></tr><tr><td>seed([x])</td><td style="text-align:left">改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。</td></tr><tr><td>shuffle(lst)</td><td style="text-align:left">将序列的所有元素随机排序</td></tr><tr><td>uniform(x, y)</td><td style="text-align:left">随机生成下一个实数，它在[x,y]范围内。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.jelech.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="python" scheme="http://www.jelech.cn/tags/python/"/>
    
      <category term="笔记" scheme="http://www.jelech.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>c++进阶学习笔记(好像就是基础)</title>
    <link href="http://www.jelech.cn/posts/26201/"/>
    <id>http://www.jelech.cn/posts/26201/</id>
    <published>2018-12-02T10:09:33.000Z</published>
    <updated>2018-12-03T15:10:58.110Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><a id="more"></a><h1 id="cpp进阶学习"><a href="#cpp进阶学习" class="headerlink" title="cpp进阶学习"></a>cpp进阶学习</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="基类和派生类"><a href="#基类和派生类" class="headerlink" title="基类和派生类"></a>基类和派生类</h3><p>一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span>-<span class="title">class</span>:</span> access-specifier base-<span class="class"><span class="keyword">class</span></span></span><br></pre></td></tr></table></figure><p>其中，访问修饰符 access-specifier 是 <strong>public、protected</strong> 或 <strong>private</strong> 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。</p><h3 id="继承类型"><a href="#继承类型" class="headerlink" title="继承类型"></a>继承类型</h3><p>当一个类派生自基类，该基类可以被继承为 <strong>public、protected</strong> 或 <strong>private</strong> 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。</p><p>我们几乎不使用 <strong>protected</strong> 或 <strong>private</strong> 继承，通常使用 <strong>public</strong> 继承。当使用不同类型的继承时，遵循以下几个规则：</p><ul><li><strong>公有继承（public）：</strong>当一个类派生自<strong>公有</strong>基类时，基类的<strong>公有</strong>成员也是派生类的<strong>公有</strong>成员，基类的<strong>保护</strong>成员也是派生类的<strong>保护</strong>成员，基类的<strong>私有</strong>成员不能直接被派生类访问，但是可以通过调用基类的<strong>公有</strong>和<strong>保护</strong>成员来访问。</li><li><strong>保护继承（protected）：</strong> 当一个类派生自<strong>保护</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>保护</strong>成员。</li><li><strong>私有继承（private）：</strong>当一个类派生自<strong>私有</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>私有</strong>成员。</li></ul><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>多继承即一个子类可以有多个父类，它继承了多个父类的特性。</p><p>C++ 类可以从多个类继承成员，语法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;派生类名&gt;:</span>&lt;继承方式<span class="number">1</span>&gt;&lt;基类名<span class="number">1</span>&gt;,&lt;继承方式<span class="number">2</span>&gt;&lt;基类名<span class="number">2</span>&gt;,…</span><br><span class="line">&#123;</span><br><span class="line">&lt;派生类类体&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="多继承-环状继承时"><a href="#多继承-环状继承时" class="headerlink" title="多继承(环状继承时)"></a>多继承(环状继承时)</h4><p>A-&gt;D, B-&gt;D, C-&gt;(A，B)，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class D&#123;......&#125;;</span><br><span class="line">class B: public D&#123;......&#125;;</span><br><span class="line">class A: public D&#123;......&#125;;</span><br><span class="line">class C: public B, public A&#123;.....&#125;;</span><br></pre></td></tr></table></figure><p>这个继承会使D创建两个对象,要解决上面问题就要用<code>虚拟继承格式</code></p><p>格式：class 类名: virtual 继承方式 父类名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class D&#123;......&#125;;</span><br><span class="line">class B: virtual public D&#123;......&#125;;</span><br><span class="line">class A: virtual public D&#123;......&#125;;</span><br><span class="line">class C: public B, public A&#123;.....&#125;;</span><br></pre></td></tr></table></figure><p>虚继承–（在创建对象的时候会创建一个虚表）在创建父类对象的时候</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A:virtual public D</span><br><span class="line">B:virtual public D</span><br></pre></td></tr></table></figure><h2 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h2><h3 id="可重载运算符-不可重载运算符"><a href="#可重载运算符-不可重载运算符" class="headerlink" title="可重载运算符/不可重载运算符"></a>可重载运算符/不可重载运算符</h3><p>下面是可重载的运算符列表：</p><table><thead><tr><th>双目算术运算符</th><th>+ (加)，-(减)，*(乘)，/(除)，% (取模)</th></tr></thead><tbody><tr><td>关系运算符</td><td>==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于&gt;，&lt;=(小于等于)，&gt;=(大于等于)</td></tr><tr><td>逻辑运算符</td><td>\</td><td>\</td><td>(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非)</td></tr><tr><td>单目运算符</td><td>+ (正)，-(负)，*(指针)，&amp;(取地址)</td></tr><tr><td>自增自减运算符</td><td>++(自增)，–(自减)</td></tr><tr><td>位运算符</td><td>\</td><td>(按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移)</td></tr><tr><td>赋值运算符</td><td>=, +=, -=, *=, /= , % = , &amp;=, \</td><td>=, ^=, &lt;&lt;=, &gt;&gt;=</td></tr><tr><td>空间申请与释放</td><td>new, delete, new[ ] , delete[]</td></tr><tr><td>其他运算符</td><td>()(函数调用)，-&gt;(成员访问)，,(逗号)，<a href="下标"></a></td></tr></tbody></table><p>下面是不可重载的运算符列表：</p><ul><li><code>.</code>：成员访问运算符</li><li><code>., -&gt;</code>：成员指针访问运算符</li><li><code>::</code>：域运算符</li><li><code>sizeof</code>：长度运算符</li><li><code>?:</code>：条件运算符</li><li><code>#</code>： 预处理符号</li></ul><h4 id="类成员访问运算符"><a href="#类成员访问运算符" class="headerlink" title="类成员访问运算符"></a>类成员访问运算符</h4><p>类成员访问运算符（ -&gt; ）可以被重载，但它较为麻烦。它被定义用于为一个类赋予”指针”行为。运算符 -&gt; 必须是一个成员函数。如果使用了 -&gt; 运算符，返回类型必须是指针或者是类的对象。</p><p>运算符 -&gt; 通常与指针引用运算符 * 结合使用，用于实现”智能指针”的功能。这些指针是行为与正常指针相似的对象，唯一不同的是，当您通过指针访问对象时，它们会执行其他的任务。比如，当指针销毁时，或者当指针指向另一个对象时，会自动删除对象。</p><p>间接引用运算符 -&gt; 可被定义为一个一元后缀运算符。也就是说，给出一个类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Ptr&#123;</span><br><span class="line">   //...</span><br><span class="line">   X * operator-&gt;();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类 <strong>Ptr</strong> 的对象可用于访问类 <strong>X</strong> 的成员，使用方式与指针的用法十分相似。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void f(Ptr p )</span><br><span class="line">&#123;</span><br><span class="line">   p-&gt;m = 10 ; // (p.operator-&gt;())-&gt;m = 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语句 p-&gt;m 被解释为 (p.operator-&gt;())-&gt;m。</p><h3 id="值得注意的是"><a href="#值得注意的是" class="headerlink" title="值得注意的是:"></a>值得注意的是:</h3><ul><li>1、运算重载符不可以改变语法结构。</li><li>2、运算重载符不可以改变操作数的个数。</li><li>3、运算重载符不可以改变优先级。</li><li>4、运算重载符不可以改变结合性。</li></ul><h3 id="静态多态"><a href="#静态多态" class="headerlink" title="静态多态"></a>静态多态</h3><p>或<strong>静态链接</strong> - 函数调用在程序执行前就准备好了。有时候这也被称为<strong>早绑定</strong>，因为 area() 函数在程序编译期间就已经设置好了。</p><p>但现在，让我们对程序稍作修改，在 Shape 类中，area() 的声明前放置关键字 <strong>virtual</strong>。此时，编译器看的是指针的内容，而不是它的类型。因此，由于 tri 和 rec 类的对象的地址存储在 <em>shape</em> 中，所以会调用各自的 area() 函数。</p><p>正如您所看到的，每个子类都有一个函数 area() 的独立实现。这就是<strong>多态</strong>的一般使用方式。有了多态，您可以有多个不同的类，都带有同一个名称但具有不同实现的函数，函数的参数甚至可以是相同的。</p><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p><strong>虚函数</strong> 是在基类中使用关键字 <strong>virtual</strong> 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。</p><p>我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为<strong>动态链接</strong>，或<strong>后期绑定</strong>。</p><h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又<strong>不能对虚函数给出有意义的实现</strong>，这个时候就会用到纯虚函数。</p><p>我们可以把基类中的虚函数 area() 改写如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:       </span><br><span class="line"><span class="keyword">int</span> width, height;</span><br><span class="line"><span class="keyword">public</span>:       </span><br><span class="line">Shape( <span class="keyword">int</span> a=<span class="number">0</span>, <span class="keyword">int</span> b=<span class="number">0</span>) &#123;</span><br><span class="line">width = a;</span><br><span class="line">height = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// pure virtual function</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">area</span><span class="params">()</span> </span>= <span class="number">0</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a>数据抽象</h2><p>数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。</p><p>例如，您的程序可以调用 <strong>sort()</strong> 函数，而不需要知道函数中排序数据所用到的算法。实际上，函数排序的底层实现会因库的版本不同而有所差异，只要接口不变，函数调用就可以照常工作。</p><h3 id="访问标签强制抽象"><a href="#访问标签强制抽象" class="headerlink" title="访问标签强制抽象"></a>访问标签强制抽象</h3><p>在 C++ 中，我们使用访问标签来定义类的抽象接口。一个类可以包含零个或多个访问标签：</p><ul><li>使用公共标签定义的成员都可以访问该程序的所有部分。一个类型的数据抽象视图是由它的公共成员来定义的。</li><li>使用私有标签定义的成员无法访问到使用类的代码。私有部分对使用类型的代码隐藏了实现细节。</li></ul><p>访问标签出现的频率没有限制。每个访问标签指定了紧随其后的成员定义的访问级别。指定的访问级别会一直有效，直到遇到下一个访问标签或者遇到类主体的关闭右括号为止。</p><blockquote><ul><li>类的内部受到保护，不会因无意的用户级错误导致对象状态受损。</li><li>类实现可能随着时间的推移而发生变化，以便应对不断变化的需求，或者应对那些要求不改变用户级代码的错误报告。</li></ul></blockquote><h3 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h3><ul><li><strong>程序语句（代码）：</strong>这是程序中执行动作的部分，它们被称为函数。</li><li><strong>程序数据：</strong>数据是程序的信息，会受到程序函数的影响。</li></ul><p><strong>数据封装</strong>是一种把数据和操作数据的函数捆绑在一起的机制，<strong>数据抽象</strong>是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。</p><h3 id="接口（抽象类）"><a href="#接口（抽象类）" class="headerlink" title="接口（抽象类）"></a>接口（抽象类）</h3><p>如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。</p><p>抽象类不能被用于实例化对象，它只能作为<strong>接口</strong>使用。如果试图实例化一个抽象类的对象，会导致编译错误。因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>C++ 异常是指在程序<code>运行时</code>发生的特殊情况，比如尝试除以零的操作。</p><ul><li><p><strong>throw:</strong> 当问题出现时，程序会抛出一个异常。这是通过使用 <strong>throw</strong> 关键字来完成的。可以使用 <strong>throw</strong> 语句在代码块中的任何地方抛出异常</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( b == <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">"Division by zero condition!"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>catch:</strong> 在您想要处理问题的地方，通过异常处理程序捕获异常。<strong>catch</strong> 关键字用于捕获异常。</p></li><li><p><strong>try:</strong> <strong>try</strong> 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。下面的代码会捕获一个类型为 <code>ExceptionName</code> 的异常。如果您想让 catch 块能够处理 try 块抛出的任何类型的异常，则必须在异常声明的括号内使用省略号 <code>...</code></p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 保护代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>( ExceptionName e )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 处理 ExceptionName 异常的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>C++ 提供了一系列标准的异常，定义在 <code>&lt;exception&gt;</code>中。</p><p><img src="assets/exceptions_in_cpp-1543739044716.png" alt="C++ 异常的层次结构"></p><h3 id="异常表"><a href="#异常表" class="headerlink" title="异常表"></a>异常表</h3><table><thead><tr><th>异常</th><th>描述</th></tr></thead><tbody><tr><td><strong>std::exception</strong></td><td>该异常是所有标准 C++ 异常的父类。</td></tr><tr><td>std::bad_alloc</td><td>该异常可以通过 <strong>new</strong> 抛出。</td></tr><tr><td>std::bad_cast</td><td>该异常可以通过 <strong>dynamic_cast</strong> 抛出。</td></tr><tr><td>std::bad_exception</td><td>这在处理 C++ 程序中无法预期的异常时非常有用。</td></tr><tr><td>std::bad_typeid</td><td>该异常可以通过 <strong>typeid</strong> 抛出。</td></tr><tr><td><strong>std::logic_error</strong></td><td>理论上可以通过读取代码来检测到的异常。</td></tr><tr><td>std::domain_error</td><td>当使用了一个无效的数学域时，会抛出该异常。</td></tr><tr><td>std::invalid_argument</td><td>当使用了无效的参数时，会抛出该异常。</td></tr><tr><td>std::length_error</td><td>当创建了太长的 std::string 时，会抛出该异常。</td></tr><tr><td>std::out_of_range</td><td>该异常可以通过方法抛出，例如 std::vector 和 std::bitset&lt;&gt;::operator<a href=""></a>。</td></tr><tr><td><strong>std::runtime_error</strong></td><td>理论上不可以通过读取代码来检测到的异常。</td></tr><tr><td>std::overflow_error</td><td>当发生数学上溢时，会抛出该异常。</td></tr><tr><td>std::range_error</td><td>当尝试存储超出范围的值时，会抛出该异常。</td></tr><tr><td>std::underflow_error</td><td>当发生数学下溢时，会抛出该异常。</td></tr></tbody></table><h3 id="C-动态内存"><a href="#C-动态内存" class="headerlink" title="C++ 动态内存"></a>C++ 动态内存</h3><ul><li><strong>栈：</strong>在函数内部声明的所有变量都将占用栈内存。</li><li><strong>堆：</strong>这是程序中未使用的内存，在程序运行时可用于动态分配内存。</li></ul><p>在 C++ 中，您可以使用特殊的运算符为给定类型的变量在运行时分配<code>堆</code>内的内存，这会返回所分配的空间地址。这种运算符即 <strong>new</strong> 运算符。</p><p>如果您不再需要动态分配的内存空间，可以使用 <strong>delete</strong> 运算符，删除之前由 new 运算符分配的内存。</p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt; <span class="title">ret</span>-<span class="title">type</span> <span class="title">func</span>-<span class="title">name</span>(<span class="title">parameter</span> <span class="title">list</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="comment">// 函数的主体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// eg.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="keyword">const</span>&amp; <span class="title">Max</span> <span class="params">(T <span class="keyword">const</span>&amp; a, T <span class="keyword">const</span>&amp; b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? b:a; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h4><p>正如我们定义函数模板一样，我们也可以定义类模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt; <span class="title">class</span> <span class="title">class</span>-<span class="title">name</span> &#123;</span></span><br><span class="line"><span class="comment">// class thing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h2><p><code>#define</code> 预处理指令用于创建符号常量。该符号常量通常称为<strong>宏</strong>.</p><p>条件编译 <code>#ifndef</code> <code>#define</code> <code>#endif</code>。可以使用 #if 0 语句注释掉程序的一部分</p><p><code>#</code> 运算符会把 replacement-text 令牌转换为用引号引起来的字符串。</p><p><code>##</code> 运算符用于连接两个令牌。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MKSTR( x ) #x</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; MKSTR(HELLO C++) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//out-&gt; HELLO C++</span></span><br></pre></td></tr></table></figure><p>其他特殊编译符号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Value of __LINE__ : "</span> &lt;&lt; __LINE__ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Value of __FILE__ : "</span> &lt;&lt; __FILE__ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Value of __DATE__ : "</span> &lt;&lt; __DATE__ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Value of __TIME__ : "</span> &lt;&lt; __TIME__ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Value of __LINE__ : 6</span></span><br><span class="line"><span class="comment">Value of __FILE__ : test.cpp</span></span><br><span class="line"><span class="comment">Value of __DATE__ : Feb 28 2011</span></span><br><span class="line"><span class="comment">Value of __TIME__ : 18:52:48</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>一般情况下，两种类型的多任务处理：<strong>基于进程和基于线程</strong>。</p><ul><li>基于进程的多任务处理是程序的并发执行。</li><li>基于线程的多任务处理是同一程序的片段的并发执行。</li></ul><p>假设在<code>linux</code>系统下</p><h3 id="创建一个-POSIX-线程："><a href="#创建一个-POSIX-线程：" class="headerlink" title="创建一个 POSIX 线程："></a>创建一个 POSIX 线程：</h3><p><code>#include &lt;pthread.h&gt;</code></p><p><code>pthread_create (thread, attr, start_routine, arg)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>thread</td><td>指向线程标识符指针。</td></tr><tr><td>attr</td><td>一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。</td></tr><tr><td>start_routine</td><td>线程运行函数起始地址，一旦线程被创建就会执行。</td></tr><tr><td>arg</td><td>运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。</td></tr></tbody></table><p>终止：<code>pthread_exit (status)</code></p><h3 id="连接和分离线程"><a href="#连接和分离线程" class="headerlink" title="连接和分离线程"></a>连接和分离线程</h3><p>我们可以使用以下两个函数来连接或分离线程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread_join (threadid, status) </span><br><span class="line">pthread_detach (threadid)</span><br></pre></td></tr></table></figure><p><code>pthread_join()</code> 子程序阻碍调用程序，直到指定的<strong>threadid</strong>线程终止为止。当创建一个线程时，它的某个属性会定义它是否是可连接的（joinable）或可分离的（detached）。只有创建时定义为可连接的线程才可以被连接。如果线程创建时被定义为可分离的，则它永远也不能被连接。</p><h2 id="什么是-CGI？"><a href="#什么是-CGI？" class="headerlink" title="什么是 CGI？"></a>什么是 CGI？</h2><ul><li>公共网关接口（CGI），是一套标准，定义了信息是如何在 Web 服务器和客户端脚本之间进行交换的。</li><li>CGI 规范目前是由 NCSA 维护的，NCSA 定义 CGI 如下：</li><li>公共网关接口（CGI），是一种用于外部网关程序与信息服务器（如 HTTP 服务器）对接的接口标准。</li><li>目前的版本是 CGI/1.1，CGI/1.2 版本正在推进中。</li></ul><p>比如我们点击一个超链接，浏览一个特定的网页或 URL时</p><ul><li>您的浏览器联系上 HTTP Web 服务器，并请求 URL，即文件名。</li><li>Web 服务器将解析 URL，并查找文件名。如果找到请求的文件，Web 服务器会把文件发送回浏览器，否则发送一条错误消息，表明您请求了一个错误的文件。</li><li>Web 浏览器从 Web 服务器获取响应，并根据接收到的响应来显示文件或错误消息。</li></ul><p>以这种方式搭建起来的 HTTP 服务器，不管何时请求目录中的某个文件，HTTP 服务器发送回来的不是该文件，而是以程序形式执行，并把执行产生的输出发送回浏览器显示出来。(比如php的响应<code>echo</code>)</p><h3 id="HTTP-头信息"><a href="#HTTP-头信息" class="headerlink" title="HTTP 头信息"></a>HTTP 头信息</h3><table><thead><tr><th>头信息</th><th>描述</th></tr></thead><tbody><tr><td>Content-type:</td><td>MIME 字符串，定义返回的文件格式。例如 Content-type:text/html。</td></tr><tr><td>Expires: Date</td><td>信息变成无效的日期。浏览器使用它来判断一个页面何时需要刷新。一个有效的日期字符串的格式应为 01 Jan 1998 12:00:00 GMT。</td></tr><tr><td>Location: URL</td><td>这个 URL 是指应该返回的 URL，而不是请求的 URL。你可以使用它来重定向一个请求到任意的文件。</td></tr><tr><td>Last-modified: Date</td><td>资源的最后修改日期。</td></tr><tr><td>Content-length: N</td><td>要返回的数据的长度，以字节为单位。浏览器使用这个值来表示一个文件的预计下载时间。</td></tr><tr><td>Set-Cookie: String</td><td>通过 <em>string</em> 设置 cookie。</td></tr></tbody></table><h3 id="CGI-环境变量"><a href="#CGI-环境变量" class="headerlink" title="CGI 环境变量"></a>CGI 环境变量</h3><table><thead><tr><th>变量名</th><th>描述</th></tr></thead><tbody><tr><td>CONTENT_TYPE</td><td>内容的数据类型。当客户端向服务器发送附加内容时使用。例如，文件上传等功能。</td></tr><tr><td>CONTENT_LENGTH</td><td>查询的信息长度。只对 POST 请求可用。</td></tr><tr><td>HTTP_COOKIE</td><td>以键 &amp; 值对的形式返回设置的 cookies。</td></tr><tr><td>HTTP_USER_AGENT</td><td>用户代理请求标头字段，递交用户发起请求的有关信息，包含了浏览器的名称、版本和其他平台性的附加信息。</td></tr><tr><td>PATH_INFO</td><td>CGI 脚本的路径。</td></tr><tr><td>QUERY_STRING</td><td>通过 GET 方法发送请求时的 URL 编码信息，包含 URL 中问号后面的参数。</td></tr><tr><td>REMOTE_ADDR</td><td>发出请求的远程主机的 IP 地址。这在日志记录和认证时是非常有用的。</td></tr><tr><td>REMOTE_HOST</td><td>发出请求的主机的完全限定名称。如果此信息不可用，则可以用 REMOTE_ADDR 来获取 IP 地址。</td></tr><tr><td>REQUEST_METHOD</td><td>用于发出请求的方法。最常见的方法是 GET 和 POST。</td></tr><tr><td>SCRIPT_FILENAME</td><td>CGI 脚本的完整路径。</td></tr><tr><td>SCRIPT_NAME</td><td>CGI 脚本的名称。</td></tr><tr><td>SERVER_NAME</td><td>服务器的主机名或 IP 地址。</td></tr><tr><td>SERVER_SOFTWARE</td><td>服务器上运行的软件的名称和版本。</td></tr></tbody></table><h3 id="GET-POST"><a href="#GET-POST" class="headerlink" title="GET/POST"></a>GET/POST</h3><p>GET 方法发送已编码的用户信息追加到页面请求中。页面和已编码信息通过 ? 字符分隔开，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.test.com/cgi-bin/cpp.cgi?key1=value1&amp;key2=value2</span><br></pre></td></tr></table></figure><p>GET 方法有大小限制，在一个请求字符串中最多可以传 1024 个字符。敏感信息不要使用 GET 方法。</p><h3 id="在-CGI-中使用-Cookies"><a href="#在-CGI-中使用-Cookies" class="headerlink" title="在 CGI 中使用 Cookies"></a>在 CGI 中使用 Cookies</h3><p>使用 cookies 是记忆和跟踪有关用户喜好、购买、佣金以及其他为追求更好的游客体验或网站统计所需信息的最有效的方法。</p><h4 id="它是如何工作的"><a href="#它是如何工作的" class="headerlink" title="它是如何工作的"></a>它是如何工作的</h4><p>服务器以 cookie 的形式向访客的浏览器发送一些数据。如果浏览器接受了 cookie，则 cookie 会以纯文本记录的形式存储在访客的硬盘上。现在，当访客访问网站上的另一个页面时，会检索 cookie。一旦找到 cookie，服务器就知道存储了什么。</p><ul><li><strong>Expires :</strong> cookie 的过期日期。如果此字段留空，cookie 会在访客退出浏览器时过期。</li><li><strong>Domain :</strong> 网站的域名。</li><li><strong>Path :</strong> 设置 cookie 的目录或网页的路径。如果您想从任意的目录或网页检索 cookie，此字段可以留空。</li><li><strong>Secure :</strong> 如果此字段包含单词 “secure”，那么 cookie 只能通过安全服务器进行检索。如果此字段留空，则不存在该限制。</li><li><strong>Name=Value :</strong> cookie 以键值对的形式被设置和获取。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.jelech.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://www.jelech.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="c++" scheme="http://www.jelech.cn/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>static的那些事</title>
    <link href="http://www.jelech.cn/posts/52795/"/>
    <id>http://www.jelech.cn/posts/52795/</id>
    <published>2018-12-02T10:09:33.000Z</published>
    <updated>2018-12-05T14:41:12.116Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><a id="more"></a><h3 id="1-先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）"><a href="#1-先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）" class="headerlink" title="1.先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）"></a>1.先来介绍它的<strong>第一条也是最重要的一条：隐藏</strong>。（static函数，static变量均可）</h3><p>当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。<br>举例来说明。同时编译两个源文件，一个是a.c，另一个是main.c。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//a.c</span><br><span class="line">char a = &apos;A&apos;; // global variable</span><br><span class="line">void msg()</span><br><span class="line">&#123;</span><br><span class="line">     printf(&quot;Hello\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//main.c</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">     extern char a; // extern variable must be declared before use</span><br><span class="line">     printf(&quot;%c &quot;, a);</span><br><span class="line">     (void)msg();</span><br><span class="line">     return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的运行结果是：</p><p>A Hello</p><p>为什么在a.c中定义的全局变量a和函数msg能在main.c中使用？前面说过，所有未加static前缀的全局变量和函数都具有全局可见性，其它的源文件也能访问。此例中，a是全局变量，msg是函数，并且都没有加static前缀，因此对于另外的源文件main.c是可见的。<br>如果加了static，就会对其它源文件隐藏。例如在a和msg的定义前加上static，main.c就看不到它们了。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏.</p><h3 id="2-static的第二个作用是保持变量内容的持久。（static变量中的记忆功能和全局生存期）"><a href="#2-static的第二个作用是保持变量内容的持久。（static变量中的记忆功能和全局生存期）" class="headerlink" title="2.static的第二个作用是保持变量内容的持久。（static变量中的记忆功能和全局生存期）"></a><strong>2.static的第二个作用是保持变量内容的持久</strong>。（static变量中的记忆功能和全局生存期）</h3><p>存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。虽然这种用法不常见</p><p>PS：如果作为static局部变量在函数内定义，它的生存期为整个源程序，但是其作用域仍与自动变量相同，只能在定义该变量的函数内使用该变量。退出该函数后， 尽管该变量还继续存在，但不能使用它。</p><p>程序举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">＃include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int fun()&#123;</span><br><span class="line">    static int count = 10; //在第一次进入这个函数的时候，变量a被初始化为10！并接着自减1，以后每次进入该函数，a</span><br><span class="line">    return count--; //就不会被再次初始化了，仅进行自减1的操作；在static发明前，要达到同样的功能，则只能使用全局变量：    </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int count = 1;</span><br><span class="line"> </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">     printf(&quot;global\t\tlocal static\n&quot;);</span><br><span class="line">     for(; count &lt;= 10; ++count)</span><br><span class="line">               printf(&quot;%d\t\t%d\n&quot;, count, fun());</span><br><span class="line">     return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的运行结果是：</p><p>global  local static<br>1 10<br>2 9<br>3 8<br>4 7<br>5 6<br>6 5<br>7 4<br>8 3<br>9 2<br>10 1</p><p>基于以上两点可以得出一个结论：<code>把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。因此static 这个说明符在不同的地方所起的作用是不同的。</code></p><h3 id="3-static的第三个作用是默认初始化为0（static变量）"><a href="#3-static的第三个作用是默认初始化为0（static变量）" class="headerlink" title="3.static的第三个作用是默认初始化为0（static变量）"></a><strong>3.static的第三个作用是默认初始化为0（static变量）</strong></h3><p>其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏矩阵，我们可以一个一个地把所有元素都置0，然后把不是0的几个元素赋值。如果定义成静态的，就省去了一开始置0的操作。再比如要把一个字符数组当字符串来用，但又觉得每次在字符数组末尾加‘\0’;太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是‘\0’;不妨做个小实验验证一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">＃include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int a;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">     int i;</span><br><span class="line">     static char str[10];</span><br><span class="line">     printf(&quot;integer: %d; string: (begin)%s(end)&quot;, a, str);</span><br><span class="line">     return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的运行结果是：</p><p>integer: 0; string: (begin) (end) </p><p>最后对static的三条作用做一句话总结。首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0. </p><h3 id="4-static的第四个作用：C-中的类成员声明static（有些地方与以上作用重叠）"><a href="#4-static的第四个作用：C-中的类成员声明static（有些地方与以上作用重叠）" class="headerlink" title="4.static的第四个作用：C++中的类成员声明static（有些地方与以上作用重叠）"></a><strong>4.static的第四个作用：C++中的类成员声明static</strong>（有些地方与以上作用重叠）</h3><p> 在类中声明static变量或者函数时，初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员，这样就出现以下作用：</p><p>(1)类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致 了它仅能访问类的静态数据和静态成员函数。      </p><p>(2)不能将静态成员函数定义为虚函数。      </p><p>(3)由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊 ，变量地址是指向其数据类型的指针 ，函数地址类型是一个“nonmember函数指针”。</p><p>(4)由于静态成员函数没有this指针，所以就差不多等同于nonmember函数，结果就 产生了一个意想不到的好处：成为一个callback函数，使得我们得以将C++和C-based X W indow系统结合，同时也成功的应用于线程函数身上。 （这条没遇见过）  </p><p>(5)static并没有增加程序的时空开销，相反她还缩短了子类对父类静态成员的访问 时间，节省了子类的内存空间。      </p><p>(6)静态数据成员在&lt;定义或说明&gt;时前面加关键字static。      </p><p>(7)静态数据成员是静态存储的，所以必须对它进行初始化。 （程序员手动初始化，否则编译时一般不会报错，但是在Link时会报错误） </p><p>(8)静态成员初始化与一般数据成员初始化不同:</p><p>初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆；<br>初始化时不加该成员的访问权限控制符private，public等；<br>初始化时使用作用域运算符来标明它所属类；<br>​           所以我们得出静态数据成员初始化的格式：<br>&lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt;=&lt;值&gt;</p><p>(9)为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响。这里有一点需要注意：我们说静态成员为父类和子类共享，但我们有重复定义了静态成员，这会不会引起错误呢？不会，我们的编译器采用了一种绝妙的手法：name-mangling 用以生成唯一的标志。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.jelech.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://www.jelech.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="c++" scheme="http://www.jelech.cn/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>mysql学习笔记</title>
    <link href="http://www.jelech.cn/posts/51482/"/>
    <id>http://www.jelech.cn/posts/51482/</id>
    <published>2018-11-30T02:09:33.000Z</published>
    <updated>2018-12-09T13:34:54.360Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><a id="more"></a><h1 id="mysql设计"><a href="#mysql设计" class="headerlink" title="mysql设计"></a>mysql设计</h1><h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h2><ul><li>键：一个识别每一个特定用户的字段。</li><li>外键：一个表引用了其他表中的主键，那么这个字段就是外键。</li><li>模式：数据库整套表格的完整设计蓝图。</li><li>关系：两个表格数据之间的关系，可以通过外键表达。</li></ul><h2 id="设计时需要注意"><a href="#设计时需要注意" class="headerlink" title="设计时需要注意"></a>设计时需要注意</h2><ul><li>每个对象应该有自己的表。</li><li>避免保存冗余的数据，比如相同的数据保存在了多个表当中（当然外键不算）。</li><li>考虑耦合性，减少空属性的出现。如果出现了，尝试拆成多个表。</li><li>使用原子列值，每一行的每个属性只储存一个数据。</li><li>键要选择的有意义。</li><li>考虑需要询问数据库时的问题，比如多值、多层查询时。</li><li>注意表格的大体分类：描述世界的简单表、描述关系的关联表。</li></ul><h1 id="mysql数据库的创建"><a href="#mysql数据库的创建" class="headerlink" title="mysql数据库的创建"></a>mysql数据库的创建</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#----临时笔记处----#</span><br><span class="line">#修改密码，注意mysql5.7中user表中密码改为了authentication_string</span><br><span class="line">    update mysql.user set authentication_string1=password(&apos;123456&apos;) where User=&quot;jelech&quot; and Host=&quot;localhost&quot;;</span><br><span class="line"></span><br><span class="line">    # 密码进入数据库，创建新数据库，授权新用户，刷新改动，设置根密码(初始使用一次就行)</span><br><span class="line">    mysql -u root -p</span><br><span class="line">  create database blog_db charset=utf8;</span><br><span class="line">    grant all on db_music.* to jelech@localhost identified by &quot;123456&quot;;</span><br><span class="line">    flush privileges;</span><br><span class="line">    set password for root@localhost=password(&quot;abccba&quot;);</span><br><span class="line"></span><br><span class="line">    # 修改表格格式信息</span><br><span class="line">    ALTER TABLE userInfo MODIFY password VARCHAR(100) NOT NULL;</span><br><span class="line"></span><br><span class="line">    # 删除表中所有内容，以及索引 用这种方法相当于重载了表格内容，全新的！</span><br><span class="line">    truncate table wp_comments;</span><br></pre></td></tr></table></figure><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p><code>msyql -h hostname -u username -p</code></p><p>eg.<code>msyql -u root -p</code></p><ul><li>-h 指定希望连接的主机，默认为localhost</li><li>-u 指定用户名称，默认为登录操作系统的用户名</li><li>-p 使用一个密码来连接他</li></ul><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p><code>create database dbname;</code></p><p>eg.<code>create database db_music;</code></p><h2 id="mysql权限问题"><a href="#mysql权限问题" class="headerlink" title="mysql权限问题"></a>mysql权限问题</h2><ul><li>最少权限原则，一个用户不应该拥有超过他的功能的多余权限。</li><li><code>grant</code> <code>revoke</code> 授予和收回权限</li></ul><h2 id="授予权限"><a href="#授予权限" class="headerlink" title="授予权限"></a>授予权限</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grant privileges # 用逗号分开的权限：all, select, create...</span><br><span class="line">on item_name # 可控制的部分:*.*, item_name.*, item_name.th_table</span><br><span class="line">to user_name # 授予一个用户：可附加通过密码 identified by &apos;password&apos;</span><br><span class="line">[require ssl_options] # 决定用户连接时，是否应该通过加密套接字连接</span><br><span class="line">[with grant potion] # 决定用户是否可以授权给别自己拥有的权限。</span><br></pre></td></tr></table></figure><h3 id="with语句也可以"><a href="#with语句也可以" class="headerlink" title="with语句也可以"></a>with语句也可以</h3><p>决定这个用户每小时可以访问的数量</p><p><code>MAX_QUERIES_PER_HOUR n</code> <code>MAX_UPDATES_PER_HOUR n</code> <code>MAX_CONNECTIONS_PER_HOUR n</code></p><p>这个在共享系统上限制单个用户的负载非常有用。</p><blockquote><p>mysql中分为3个基本权限：适用一般用户权限、适用赋予管理员权限、几个特定权限。<br>mysql中存放了所有用户名、密码的地方，这里的访问权限不应随意授予。</p></blockquote><h3 id="用户的权限"><a href="#用户的权限" class="headerlink" title="用户的权限"></a>用户的权限</h3><ul><li>select：从表中选择行</li><li>insert：插入新行</li><li>udpate：修改表行中值</li><li>delete：删除表中的行</li><li>index：创建和拖动特定表的索引</li><li>alter：修改表的结构，比如添加列、重名列|表、修改列的数据类型…</li><li>create：新建数据库|表，如果grant授予的特定的数据库，则他们只能创建该数据库|表，也就是他们需要先删除</li><li>drop：删除数据库和表</li></ul><h3 id="管理员的权限"><a href="#管理员的权限" class="headerlink" title="管理员的权限"></a>管理员的权限</h3><ul><li>create temporary tables：允许使用temporary关键字</li><li>file：允许将数据从文件中读入表、输出到文件</li><li>lock table：允许使用lock table语句</li><li>process：允许管理员查看属于所有用户的服务器进程</li><li>reload：允许管理员重新载入授权表、清空授权、主机、日志和表</li><li>replication client：允许复制主机、使用show status</li><li>replication slave：允许复制从服务器连接到主服务器</li><li>show databases：允许查看所有数据库列表，没有这个权限，用户就只能看到他们自己的</li><li>shutdown：允许关闭mysql服务器</li><li>super：允许关闭属于任何用户的线程</li></ul><h3 id="特别权限"><a href="#特别权限" class="headerlink" title="特别权限"></a>特别权限</h3><ul><li>all：授予以上所有权限</li><li>usage：不授予权限，只允许用户登录，但不能进行任何操作。这样做的目的是为了以后授予权限</li></ul><h2 id="收回权限"><a href="#收回权限" class="headerlink" title="收回权限"></a>收回权限</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">revoke privileges # 收回某种权限</span><br><span class="line">on item # 从某个数据库或者表中</span><br><span class="line">from username #从一个用户中</span><br></pre></td></tr></table></figure><p>其余部分和授权相似。</p><h2 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h2><p><code>use db_name</code></p><p>在登录后应切换到需要使用的数据库</p><h2 id="使用数据库表"><a href="#使用数据库表" class="headerlink" title="使用数据库表"></a>使用数据库表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table table_name(</span><br><span class="line"># 字段属性</span><br><span class="line">  table_id int auto_increment not null primary key,</span><br><span class="line">  table_name varchar(255) not null,</span><br><span class="line">  table_float float(6,2),</span><br><span class="line">  #...unsigned意思是他只能是0或者一个正数</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>text：该类型用于表示更长的数据，比如文章</li><li>zerofill：该属性可以让数字类型添加前导0。</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ol><li><p>整数数据类型</p><ul><li>tinyint(1)：非常小的整数</li><li>bit、bool：同tinyint</li><li>smallint(2)：小整形数</li><li>mediumint(3)：中整形数</li><li>int(4)：一般整数</li><li>integer：同int</li><li>bigint(8)：大整形数</li></ul></li><li><p>浮点数据类型</p><ul><li>float(精度)：可用于指定单精度和双精度的浮点数</li><li>float[(M,D)]：指定显示宽度和小数位数===float(4)</li><li>double[(M,D)]：指定了显示宽度和小数位数===float(8)</li><li>duoble：同上</li><li>precision[(M,D)]</li><li>real[(M,D)]：同上</li><li>decimal[(M [,D])]：以char储存的浮点数</li><li>numeric\dec\fixed：同上</li></ul></li><li>日期和时间类型<em>值得注意的是如果不手动设置，特定行中的timestamp将被修改为最近修改改行的日期和时间，这对事物记录很有帮助</em><ul><li>date：一个日期，以YYYY-MM-DD格式</li><li>time：一个时间，以HH:MM:SS格式</li><li>datetime：日期和时间，以YYYY-MM-DD HH:MM:SS格式</li><li>timestamp[(M)]：时间标签，在处理报告中有意义</li><li>year[(2/4)]：可指定显示格式地显示年份</li></ul></li><li>字符串类型<ul><li>char：小段文本，varchar为可变长度的类型，指定的是每种类型的宽度</li><li>text、blob：大小可变，分别适用于长文本、二进制数据(<em>二进制是万金油</em>)。text区分大小写，blob不区分大小写</li><li>set、enum：set最大可以有64个元素，列值必须来自其中。enum枚举最大65535个元素，同时只能有一个为null或者为枚举中的值</li></ul></li></ol><h3 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h3><p><code>show tables</code>：显示当前用户的数据库下的所有表。</p><p><code>show databases</code>：显示当前用户的所有数据库。</p><p><code>descibe table_name</code>：也作<em>desc</em>，显示表格的结构。</p><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><blockquote><p>索引有利于提高数据库的查询速度</p></blockquote><p><code>create index index_name on table_name (index_col_name ...)</code></p><h1 id="使用mysql数据库"><a href="#使用mysql数据库" class="headerlink" title="使用mysql数据库"></a>使用mysql数据库</h1><hr><h1 id="MySql优化"><a href="#MySql优化" class="headerlink" title="MySql优化"></a>MySql优化</h1><ul><li><p>三大方向</p><ul><li>优化MySQL所在服务器内核</li><li>对MySQL配置参数进行优化（my.cnf）此优化需要进行压力测试来进行参数调整。</li><li>对SQL语句以及表优化。</li></ul></li></ul><h2 id="MySQL参数优化"><a href="#MySQL参数优化" class="headerlink" title="MySQL参数优化"></a>MySQL参数优化</h2><ul><li><p>MySQL 默认的最大连接数为 100，可以在 mysql 客户端使用以下命令查看</p><p><code>mysql&gt; show variables like &#39;max_connections&#39;;</code></p></li><li><p>查看当前访问Mysql的线程</p><p><code>mysql&gt; show processlist;</code></p></li><li><p>设置最大连接数</p><p><code>mysql&gt;set globle max_connections = 5000;</code></p><p>最大可设置16384,超过没用</p></li><li><p>查看当前被使用的connections</p><p>  <code>mysql&gt;show globle status like &#39;max_user_connections&#39;</code></p></li></ul><h2 id="16经验"><a href="#16经验" class="headerlink" title="16经验"></a>16经验</h2><ol><li><p>为查询缓存优化查询</p><ul><li><p>大多数的MySQL服务器都开启了查询缓存。</p><p>  <code>SELECT username FROM user WHERE    signup_date &gt;= CURDATE()</code></p><p>  CURDATE(), NOW() 和 RAND() 或是其它的诸如此类的SQL函数都不会开启查询缓存，因为这些函数的返回是会不定的易变的。所以，你所需要的就是用一个变量来代替MySQL的函数，从而开启缓存。</p></li></ul></li><li><p>EXPLAIN 我们的SELECT查询(可以查看执行的行数)</p><ul><li>使用EXPLAIN关键字可以使我们知道MySQL是如何处理SQL语句的，这样可以帮助我们分析我们的查询语句或是表结构的性能瓶颈；EXPLAIN的查询结果还会告诉我们索引主键是如何被利用的，数据表是如何被被搜索或排序的….等等。语法格式是：<code>EXPLAIN +SELECT语句</code></li></ul></li><li><p>当只要一行数据时使用LIMIT 1</p><ul><li>加上LIMIT 1可以增加性能。MySQL数据库引擎会在查找到一条数据后停止搜索，而不是继续往后查询下一条符合条件的数据记录。</li></ul></li><li><p>为搜索字段建立索引</p><ul><li><p>索引不一定就是给主键或者是唯一的字段，如果在表中，有某个字段经常用来做搜索，需要将其建立索引。</p></li><li><p>在执行CREATE TABLE语句时可以创建索引，也可以单独用CREATE INDEX或ALTER TABLE来为表增加索引。</p><ul><li><code>ALTER TABLE</code> 用来创建普通索引、唯一索引、主键索引和全文索引<ul><li><code>ALTER TABLE table_name ADD INDEX index_name (column_list);</code></li><li><code>ALTER TABLE table_name ADD UNIQUE (column_list);</code></li><li><code>ALTER TABLE table_name ADD PRIMARY KEY (column_list);</code></li><li><code>ALTER TABLE table_name ADD FULLTEXT (column_list);</code></li></ul></li><li><code>CREATE INDEX</code>可对表增加普通索引或UNIQUE索引以及全文索引，但是不可以对表增加主键索引<ul><li><code>CREATE INDEX index_name ON table_name (column_list);</code></li><li><code>CREATE UNIQUE index_name ON table_name (column_list);</code></li><li><code>CREATE FULLTEXT index_name ON table_name (column_list);</code></li></ul></li></ul></li><li><p>索引类型</p><ul><li>普通索引INDEX：适用于name、email等一般属性</li><li>唯一索引UNIQUE：与普通索引类似，不同的是唯一索引要求索引字段值在表中是<strong>唯一</strong>的，这一点和主键索引类似，但是不同的是，唯一索引<strong>允许有空值</strong>。唯一索引一般适用于身份证号码、用户账号等不允许有重复的属性字段上。</li><li>主键索引：其实就是主键，一般在建表时就指定了，不需要额外添加。</li><li>全文检索FULLTEXT：只适用于VARCHAR和Text类型的字段。<em>全文索引和普通索引是有很大区别的，如果建立的是普通索引，一般会使用like进行模糊查询</em><ul><li>MySql自带的全文索引只能对英文进行全文检索，目前无法对中文进行全文检索。</li><li>如果需要对包含中文在内的文本数据进行全文检索，我们需要采用Sphinx（斯芬克斯）/Coreseek技术来处理中文</li><li>MySql自带的全文索引时，如果查询字符串的长度过短将无法得到期望的搜索结果</li><li>MySql全文索引所能找到的词默认最小长度为4个字符</li><li>另外，如果查询的字符串包含停止词，那么该停止词将会被忽略</li></ul></li></ul></li><li><p>组合索引</p><ul><li>组合索引又称多列索引，就是建立索引时指定多个字段属性。有点类似于字典目录，比如查询 ‘guo’ 这个拼音的字时，首先查找g字母，然后在g的检索范围内查询第二个字母为u的列表，最后在u的范围内查找最后一个字母为o的字</li><li><code>where a=3 and c=5</code>  这种情况下b就是断点，a发挥了效果，c没有效果</li></ul></li><li><p>查看索引</p><ul><li><code>mysql&gt; show index from tblname;</code></li><li><code>mysql&gt; show keys from tblname;</code></li></ul></li><li><p>删除</p><ul><li><code>DORP INDEX IndexName ON tab_name；</code></li></ul></li><li><blockquote><p>对于普通索引而言 在使用like进行通配符模糊查询时,如果首尾之间都使用了通配符，索引时无效的。</p></blockquote></li></ul></li><li><p>在Join表的时候使用相当类型的列，并将其索引</p><ul><li>如果在程序中有很多JOIN查询，应该保证两个表中join的字段时被建立过索引的。这样MySQL颞部会启动优化JOIN的SQL语句的机制。</li><li><code>SELECT company_name FROM users LEFT JOIN companies ON (users.state = companies.state) WHERE users.id = “user_id”·</code></li><li>两个 state 字段应该是被建过索引的，而且应该是相当的类型，相同的字符集。</li></ul></li><li><p>千万不要ORDER BY RAND  ()</p></li><li><p>避免SELECT *</p><ul><li>从数据库里读出越多的数据，那么查询就会变得越慢,并且，如果我们的数据库服务器和WEB服务器是两台独立的服务器的话，这还会增加网络传输的负载。所以，我们应该养成一个需要什么就取什么的好的习惯。</li></ul></li><li><p>永远为每张表设置一个ID</p></li><li><p>可以使用ENUM 而不要VARCHAR</p><ul><li>ENUM 类型是非常快和紧凑的。在实际上，其保存的是 TINYINT，但其外表上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美。 </li><li>如果我们有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，我们知道这些字段的取值是有限而且固定的，那么，我们应该使用 ENUM 而不是 VARCHAR。</li></ul></li><li><p>尽可能的使用NOT NULL</p><ul><li>NULL也需要占用存储空间，并且会使我们的程序判断时更加复杂</li></ul></li><li><p>固定长度的表会更快</p><ul><li>如果表中的所有字段都是“固定长度”的，整个表会被认为是 “static” 或 “fixed-length”。 例如，表中没有如下类型的字段： VARCHAR，TEXT，BLOB。只要我们包括了其中一个这些字段，那么这个表就不是“固定长度静态表”了，这样，MySQL 引擎会用另一种方法来处理。</li></ul></li><li><p>垂直分割</p><ul><li>“垂直分割”是一种把数据库中的表按列变成几张表的方法，这样可以降低表的复杂度和字段的数目，从而达到优化的目的。</li></ul></li><li><p>拆分打的DELETE或INSERT语句</p><ul><li>如果我们需要在一个在线的网站上去执行一个大的 DELETE 或 INSERT 查询，我们需要非常小心，要避免我们的操作让我们的整个网站停止相应。因为这两个操作是会锁表的，表一锁住了，别的操作都进不来了</li><li>所以在使用时使用LIMIT 控制数量操作记录的数量。</li></ul></li><li><p>越小的列会越快</p><ul><li>对于大多数的数据库引擎来说，硬盘操作可能是最重大的瓶颈。所以，把我们的数据变得紧凑会对这种情况非常有帮助，因为这减少了对硬盘的访问。</li><li>如果一个表只会有几列,使用 MEDIUMINT, SMALLINT 或是更小的 TINYINT 会更经济一些</li></ul></li><li><p>选择正确的存储引擎</p><ul><li>在MYSQL中有两个存储引擎MyISAM和InnoDB,每个引擎都有利有弊。</li><li>MyISAM<ul><li>good: 适合于一些需要大量<strong>查</strong>询的应用, SELECT  COUNT(*)这类的计算是超快无比的</li><li>bad: 但是对于大量<strong>写</strong>操作的支持不是很好, 甚至一个update语句就会进行锁表操作</li><li>以前默认的存储引擎，基于传统的ISAM类型，支持B-Tree，全文检索，但是不是事务安全的，而且不支持外键。不具有原子性。支持锁表。</li></ul></li><li>InnoDB<ul><li>good: 支持“行锁” ，于是在<strong>写</strong>操作比较多的时候，会更优秀</li><li>bad: 趋势会是一个非常复杂的存储引擎，对于一些<strong>小</strong>的应用，它会比 MyISAM 还<strong>慢</strong>。</li><li>事务型引擎，支持ACID事务(实现4种事务隔离机制)、回滚、崩溃恢复能力、行锁。以及提供与Oracle一致的不加锁的读取方式。InnoDB存储它的表和索引在一个表空间中，表空间可以包含多个文件。</li></ul></li></ul></li><li><p>小心 “永久链接”</p><ul><li>“永久链接”的目的是用来减少重新创建MySQL链接的次数。当一个链接被创建了，它会永远处在连接的状态，就算是数据库操作已经结束了。</li><li>Apache 运行在极端并行的环境中，会创建很多很多的了进程。这就是为什么这种“永久链接”的机制工作地不好的原因。在我们决定要使用“永久链接”之前，我们需要好好地考虑一下我们的整个系统的架构。</li></ul></li></ol><h1 id="next"><a href="#next" class="headerlink" title="next"></a>next</h1>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.jelech.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://www.jelech.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="mysql" scheme="http://www.jelech.cn/tags/mysql/"/>
    
  </entry>
  
</feed>
